<?xml version="1.0" encoding="UTF-8"?>
<root file_prefix="">
    <d xmlns:xi="http://www.w3.org/2001/XInclude" n="src">
        <d n="core">
            <f n="app.xql">module namespace app="http://sade/app"; import module namespace
                templates="http://exist-db.org/xquery/templates" at "templates.xql"; import module
                namespace config="http://exist-db.org/xquery/apps/config" at "config.xqm"; import
                module namespace project = "http://aac.ac.at/content_repository/project" at
                "project.xqm"; import module namespace
                resource="http://aac.ac.at/content_repository/resource" at "resource.xqm"; import
                module namespace rf="http://aac.ac.at/content_repository/resourcefragment" at
                "resourcefragment.xqm"; import module namespace
                config-params="http://exist-db.org/xquery/apps/config-params" at "config.xql";
                import module namespace repo-utils = "http://aac.ac.at/content_repository/utils" at
                "repo-utils.xqm"; declare namespace xhtml= "http://www.w3.org/1999/xhtml"; (:~
                OBSOLETED by app:info($key) reads project title from project-dmd :) declare
                %templates:wrap function app:title($node as node(), $model as map(*)) {
                config:param-value($model, 'project-title') }; (:~ generates an html-snippet for the
                templates (with current user and login/logout links) :) declare %templates:wrap
                function app:user ($node as node(), $model as map(*)) { let $back-url :=
                replace(replace(request:get-url(),'http:','https:'),'exist2/apps/cr-xq-mets','lrp')
                let $shib-user := config:shib-user() let $user := if ($shib-user) then $shib-user
                else xmldb:get-current-user() return &lt;div id="user" &gt;user: &lt;span
                class="current-user"&gt;{$user}&lt;/span&gt;&lt;br/&gt; &lt;a
                href="https://clarin.oeaw.ac.at/Shibboleth.sso/Login?target={$back-url}"&gt;Log
                on&lt;/a&gt;| &lt;a href="https://clarin.oeaw.ac.at/Shibboleth.sso/Logout"&gt;Log
                off&lt;/a&gt;&lt;/div&gt; }; declare %templates:wrap function app:logo($node as
                node(), $model as map(*)) { let $logo-image := config:param-value($model,
                'logo-image') let $logo-link := config:param-value($model, 'logo-link') return &lt;a
                xmlns="http://www.w3.org/1999/xhtml" href="{$logo-link}" target="_blank"&gt; &lt;img
                src="{$logo-image}" class="logo right"/&gt; &lt;/a&gt; }; (:~ generic function to
                insert (by default html-formatted) application information into the templates passes
                onto the config:param-value function to get the data :) declare %templates:wrap
                %templates:default("x-format", "html") function app:info ($node as node(), $model as
                map(*), $key, $x-format) { let $val := config:param-value($model, $key) let $ret :=
                if (contains($x-format,'html')) then typeswitch ($val) (:case xs:string return
                &lt;span class="{$key}"&gt;{$val}&lt;/span&gt; case text() return &lt;span
                class="{$key}"&gt;{$val}&lt;/span&gt;:) case element() return
                repo-utils:serialise-as($val, $x-format, $key, $model("config")) default return
                &lt;span class="{$key}"&gt;{$val}&lt;/span&gt; else $val return $ret }; declare
                %templates:wrap %templates:default("x-format", "html") function
                app:list-resources($node as node(), $model as map(*), $x-format) { let $log :=
                util:log-app("INFO",$config:app-name,"app:list-resources") (: let $structMap :=
                project:list-resources($model("config")):) (: project/resource:* couldn't correctly
                handle the config sequence chaos as is in $model("config") so rather give them just
                the project-pid :) let $project-pid :=
                config:param-value($model("config"),$config:PROJECT_PID_NAME) let $ress :=
                project:list-resources-resolved($project-pid) let $log :=
                util:log-app("INFO",$config:app-name,"app:list-resources-END") (:for $res in $ress
                let $dmd := resource:dmd($res, $model("config") ):) return
                repo-utils:serialise-as($ress, $x-format, 'resource-list', $model("config")) (:
                return $dmd:) }; declare %templates:wrap %templates:default("x-format", "html")
                function app:toc($node as node(), $model as map(*), $x-format) { let $project-pid :=
                $model('config')/xs:string(@OBJID) let $struct :=
                project:get-toc-resolved($project-pid) return repo-utils:serialise-as($struct,
                $x-format, 'structMap', $model("config")) }; declare %templates:wrap
                %templates:default("filter", "") function app:list-projects($node as node(), $model
                as map(*), $filter as xs:string) { let $filter-seq:= tokenize($filter,',') let
                $projects := if ($filter='') then config:list-projects() else $filter-seq (: get the
                absolute path to controller, for the image-urls :) let $exist-controller :=
                config:param-value($model, 'exist-controller') let $request-uri:=
                config:param-value($model, 'request-uri') let $base-uri:= if
                (contains($request-uri,$exist-controller)) then
                concat(substring-before($request-uri,$exist-controller),$exist-controller) else
                $request-uri for $pid in $projects let $config-map := map { "config" :=
                config:project-config($pid)} (: try to get the base-project (could be different then
                the current $project-id for the only-config-projects :) let $config-dir :=
                substring-after(config:param-value($config-map,
                'project-dir'),$config-params:projects-dir) let $visibility :=
                config:param-value($config-map, 'visibility') let $title :=
                config:param-value($config-map, 'project-title') let $link := if
                (config:param-value($config-map, 'project-url')!='') then
                config:param-value($config-map, 'project-url') else concat($base-uri, '/', $pid,
                '/index.html') let $teaser-image := concat($base-uri, '/', $config-dir,
                config:param-value($config-map, 'teaser-image')) let $teaser-text:= if
                (config:param-value($config-map, 'teaser-text')!='') then
                config:param-value($config-map, 'teaser-text') else (: welcome message as fallback
                for teaser:) let $teaser := collection(config:param-value($config-map,
                'project-static-dir'))//*[xs:string(@id)= 'teaser'][1]/p let $welcome :=
                collection(config:param-value($config-map,
                'project-static-dir'))//*[xs:string(@id)='welcome'][1]/p return if ($teaser) then
                $teaser else $welcome (: let $teaser := config:param-value($config-map, 'teaser'):)
                return if ($visibility != 'private') then &lt;div class="teaser"
                xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;img class="teaser"
                src="{$teaser-image}" /&gt; &lt;h3&gt;&lt;a
                href="{$link}"&gt;{$title}&lt;/a&gt;&lt;/h3&gt; {$teaser-text} &lt;/div&gt; else ()
                (: return $projects:) }; </f>
            <f n="config.template.xql">xquery version "3.0";&#xd; &#xd; module namespace
                config="http://exist-db.org/xquery/apps/config-params";&#xd; &#xd; (:~ &#xd;
                config.template.xql file is copied (manually or during build) to config.xql and
                optionally adapted&#xd; config.xql is part of the app - imported by config.xqm&#xd;
                :)&#xd; &#xd; (: the simple variant, however with projects-collection inside
                /db/apps&#xd; declare variable $config:projects-dir :=
                "/db/apps/@projects.dir@/";&#xd; declare variable $config:projects-baseuri:=
                "/@projects.dir@/";&#xd; :)&#xd; &#xd; (: this variant allows the projects-folder
                outside /db/apps&#xd; (mark the trick with parent folder for the baseuri - this is
                necessary to fool the controller ):&#xd; :) &#xd; declare variable
                $config:projects-dir := "/db/@projects.dir@/";&#xd; declare variable
                $config:data-dir := "/db/@data.dir@/";&#xd; declare variable
                $config:projects-baseuri:= "/@app.name@/../../@projects.dir@/";&#xd; declare
                variable $config:system-account-user:= "@system.account.user@";&#xd; declare
                variable $config:system-account-pwd:= "@system.account.pwd@";&#xd; declare variable
                $config:shib-user-pwd:= "@shib.user.pwd@";&#xd; </f>
            <f n="config.xql">xquery version "3.0";&#xd; &#xd; module namespace
                config="http://exist-db.org/xquery/apps/config-params";&#xd; &#xd; (:~ &#xd;
                config.template.xql file is copied (manually or during build) to config.xql and
                optionally adapted&#xd; config.xql is part of the app - imported by config.xqm&#xd;
                :)&#xd; &#xd; (: the simple variant, however with projects-collection inside
                /db/apps&#xd; declare variable $config:projects-dir := "/db/apps/cr-projects/";&#xd;
                declare variable $config:projects-baseuri:= "/cr-projects/";&#xd; :)&#xd; &#xd; (:
                this variant allows the projects-folder outside /db/apps&#xd; (mark the trick with
                parent folder for the baseuri - this is necessary to fool the controller ):&#xd; :)
                &#xd; declare variable $config:projects-dir := "/db/cr-projects/";&#xd; declare
                variable $config:data-dir := "/db/cr-data/";&#xd; declare variable
                $config:projects-baseuri:= "/cr-xq-mets/../../cr-projects/";&#xd; declare variable
                $config:system-account-user:= "cr-xq";&#xd; declare variable
                $config:system-account-pwd:= "cr-xq!!";&#xd; declare variable
                $config:shib-user-pwd:= "@shib.user.pwd@";&#xd; </f>
            <f n="config.xqm">xquery version "3.0";&#xd; (:~&#xd; : A set of helper functions to
                access the application context from&#xd; : within a module. &#xd; :&#xd; : Based on
                config.xqm provided by the exist:templating system &#xd; : extended to recognize
                multiple projects and templates and project-specific configuration&#xd; :)&#xd;
                module namespace config="http://exist-db.org/xquery/apps/config";&#xd; &#xd; import
                module namespace config-params="http://exist-db.org/xquery/apps/config-params" at
                "config.xql";&#xd; import module namespace
                templates="http://exist-db.org/xquery/templates" at "templates.xql";&#xd; &#xd;
                declare namespace repo="http://exist-db.org/xquery/repo";&#xd; declare namespace
                expath="http://expath.org/ns/pkg";&#xd; declare namespace
                mets="http://www.loc.gov/METS/";&#xd; declare namespace
                mods="http://www.loc.gov/mods/v3";&#xd; declare namespace
                xlink="http://www.w3.org/1999/xlink";&#xd; declare namespace
                cmd="http://www.clarin.eu/cmd/";&#xd; declare namespace
                sm="http://exist-db.org/xquery/securitymanager";&#xd; &#xd; &#xd; &#xd; (:~&#xd; :
                Contains the uri of the application root collection, determined from the current
                module load path.&#xd; ~:)&#xd; declare variable $config:app-root := &#xd; let
                $rawPath := system:get-module-load-path()&#xd; let $modulePath :=&#xd; (: strip the
                xmldb: part :)&#xd; if (starts-with($rawPath, "xmldb:exist://")) &#xd; then&#xd; if
                (starts-with($rawPath, "xmldb:exist://null")) &#xd; then&#xd; (: seems necessary
                when the calling module is not stored (e.g. test script in exide) :)&#xd;
                substring($rawPath, 19)&#xd; else &#xd; if (starts-with($rawPath,
                "xmldb:exist://embedded-eXist-server")) &#xd; then substring($rawPath, 36)&#xd; else
                substring($rawPath, 15)&#xd; else $rawPath&#xd; return substring-before($modulePath,
                "/core")&#xd; ;&#xd; &#xd; declare variable $config:app-name := 'cr-xq';&#xd;
                declare variable $config:app-root-key := 'app-root';&#xd; &#xd; (:~ &#xd; :
                extracting the context collection of the application &#xd; ~:) &#xd; declare
                variable $config:app-root-collection := concat( '/', (tokenize($config:app-root,
                '/'))[not(.='')][position()=last()], '/');&#xd; &#xd; &#xd; &#xd; declare variable
                $config:cr-config-filename := "conf.xml";&#xd; declare variable $config:cr-config :=
                doc($config:app-root||"/"||$config:cr-config-filename);&#xd; &#xd; declare variable
                $config:templates-dir := "templates/";&#xd; declare variable $config:modules-dir :=
                $config:app-root||"/modules/";&#xd; declare variable $config:project-static-dir :=
                "static/";&#xd; declare variable $config:templates-baseuri:=
                $config:app-root-collection||$config:templates-dir;&#xd; declare variable
                $config:repo-descriptor := doc($config:app-root||"/repo.xml")/repo:meta;&#xd;
                declare variable $config:expath-descriptor :=
                doc($config:app-root||"/expath-pkg.xml")/expath:package;&#xd; &#xd; declare variable
                $config:default-data-path := "/db/cr-data/";&#xd; declare variable
                $config:default-workingcopy-path := config:path("workingcopy");&#xd; declare
                variable $config:default-resourcefragments-path :=
                config:path("resourcefragments");&#xd; declare variable
                $config:default-lookuptable-path := config:path("lookuptables");&#xd; &#xd; declare
                variable $config:DEFAULT_PROJECT_ID :="defaultProject";&#xd; declare variable
                $config:PROJECT_DATA_FILEGRP_ID:="projectData";&#xd; declare variable
                $config:PROJECT_STRUCTMAP_ID:="cr-data";&#xd; declare variable
                $config:PROJECT_STRUCTMAP_TYPE:="internal";&#xd; declare variable
                $config:PROJECT_TOC_STRUCTMAP_TYPE:="logical";&#xd; declare variable
                $config:PROJECT_TOC_STRUCTMAP_ROOT_TYPE:="cr-xq-corpus";&#xd; declare variable
                $config:PROJECT_RESOURCE_DIV_TYPE:="resource";&#xd; declare variable
                $config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE:="resourcefragment";&#xd; declare variable
                $config:PROJECT_PID_NAME:="project-pid";&#xd; &#xd; (: Project Account naming
                conventions :)&#xd; declare variable
                $config:PROJECT_ACCOUNTS_ADMIN_ACCOUNTNAME_PREFIX:= "";&#xd; declare variable
                $config:PROJECT_ACCOUNTS_ADMIN_ACCOUNTNAME_SUFFIX:= "Admin";&#xd; declare variable
                $config:PROJECT_ACCOUNTS_USER_ACCOUNTNAME_PREFIX:= "";&#xd; declare variable
                $config:PROJECT_ACCOUNTS_USER_ACCOUNTNAME_SUFFIX:= "";&#xd; &#xd; &#xd; declare
                variable $config:PROJECT_STATUS_AVAILABLE := "available";&#xd; declare variable
                $config:PROJECT_STATUS_REVISION := "under revision";&#xd; declare variable
                $config:PROJECT_STATUS_REMOVED := "removed"; &#xd; declare variable
                $config:PROJECT_STATUS_RESTRICTED := "restricted";&#xd; &#xd; declare variable
                $config:PROJECT_DMDSEC_ID := "projectDMD";&#xd; declare variable
                $config:PROJECT_AMDSEC_ID := "projectAMD";&#xd; declare variable
                $config:PROJECT_MAPPINGS_ID := "projectMappings";&#xd; declare variable
                $config:PROJECT_PARAMETERS_ID := "projectParameters";&#xd; declare variable
                $config:PROJECT_MODULECONFIG_ID := "moduleConfig";&#xd; declare variable
                $config:PROJECT_RIGHTSMD_ID := "projectLicense";&#xd; declare variable
                $config:PROJECT_ACL_ID := "projectACL";&#xd; &#xd; declare variable
                $config:PROJECT_FACS_FILEGRP_ID := "imgResources";&#xd; declare variable
                $config:PROJECT_FACS_FILEGRP_USE := "Image Resources";&#xd; &#xd; (:~&#xd; : This
                variable stores the content of the @USE attribute on the &lt;fileGrp&gt;
                element,&#xd; : which contains all &lt;file&gt;s of a resource. &#xd; ~:)&#xd;
                declare variable $config:PROJECT_RESOURCE_FILEGRP_USE:="RESOURCE FILES";&#xd;
                declare variable $config:PROJECT_RESOURCE_FILEGRP_SUFFIX:="_files";&#xd; &#xd;
                declare variable $config:RESOURCE_FACS_SUFFIX:="_facs";&#xd; &#xd; (:~&#xd; : The
                variable &lt;code&gt;&lt;/code&gt; stores the content of the @USE attribute on the
                &lt;file&gt; element,&#xd; : which contains the working copy of a resources. &#xd;
                ~:)&#xd; declare variable $config:RESOURCE_WORKINGCOPY_FILE_USE:="WORKING
                COPY";&#xd; declare variable $config:RESOURCE_MASTER_FILE_USE:="MASTER";&#xd;
                declare variable $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE:="EXTRACTED
                RESOURCEFRAGMENTS";&#xd; declare variable
                $config:RESOURCE_LOOKUPTABLE_FILE_USE:="LOOKUP TABLE";&#xd; &#xd; declare variable
                $config:RESOURCE_WORKINGCOPY_FILEID_SUFFIX:="_wc";&#xd; (: the id of the mets:file
                element representing the resourcefragments file is &#xd; generated by resource-pid +
                $config:RESOURCE_RESOURCEFRAGMENT_FILEID_SUFFIX :)&#xd; declare variable
                $config:RESOURCE_RESOURCEFRAGMENT_FILEID_SUFFIX:="_frgts";&#xd; (: the
                resourcefragment-pid is generated by &#xd; resource-pid +
                $config:RESOURCE_RESORUCEFRAGMENT_ID_SUFFIX + running number &#xd; :)&#xd; declare
                variable $config:RESOURCE_RESOURCEFRAGMENT_ID_SUFFIX := "_";&#xd; declare variable
                $config:RESOURCE_MASTER_FILEID_SUFFIX:="_master";&#xd; declare variable
                $config:RESOURCE_LOOKUPTABLE_FILEID_SUFFIX:="_lt";&#xd; &#xd; declare variable
                $config:RESOURCE_DMDID_SUFFIX:="_dmd";&#xd; declare variable
                $config:RESOURCE_PID_NAME:="resource-pid";&#xd; (:~&#xd; : Declaration of XML
                element names and namespaces for stored resource fragments and lookup tables. &#xd;
                ~:)&#xd; declare variable
                $config:RESOURCE_RESOURCE_ELEMENT_NSURI:="http://clarin.eu/fcs/1.0";&#xd; declare
                variable $config:RESOURCE_RESOURCE_ELEMENT_NAME:="resource";&#xd; declare variable
                $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NSURI:=$config:RESOURCE_RESOURCE_ELEMENT_NSURI;&#xd;
                declare variable
                $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME:="resourceFragment";&#xd; declare
                variable
                $config:RESOURCE_LOOKUPTABLE_ELEMENT_NSURI:=$config:RESOURCE_RESOURCE_ELEMENT_NSURI;&#xd;
                declare variable $config:RESOURCE_LOOKUPTABLE_ELEMENT_NAME:="lookupTable";&#xd;
                &#xd; &#xd; declare variable
                $config:RESOURCEFRAGMENT_PID_NAME:="resourcefragment-pid";&#xd; declare variable
                $config:RESOURCEFRAGMENT_LABEL_NAME:="rf-label";&#xd; &#xd; declare variable
                $config:INDEX_RESOURCEFRAGMENT_DELIMITER:="rf";&#xd; declare variable
                $config:INDEX_INTERNAL_RESOURCEFRAGMENT:="fcs.rf";&#xd; &#xd; (:~&#xd; : Prefixes to
                prepend to the filename of a resource, when storing working copies, &#xd; : lookup
                tables and extracted resource fragments. &#xd; ~:)&#xd; declare variable
                $config:RESOURCE_WORKINGCOPY_FILENAME_PREFIX := "wc-";&#xd; declare variable
                $config:RESOURCE_LOOKUPTABLE_FILENAME_PREFIX := "lt-";&#xd; declare variable
                $config:RESOURCE_RESOURCEFRAGMENT_FILENAME_PREFIX := "frg-";&#xd; declare variable
                $config:RESOURCE_DMD_FILENAME_PREFIX := "md-";&#xd; &#xd; declare variable
                $config:cr-writer-accountname := if
                (doc-available("../modules/access-control/writer.xml"))&#xd; then
                doc("../modules/access-control/writer.xml")/write/xs:string(write-user)&#xd; else
                "cr-writer";&#xd; &#xd; &#xd; declare variable $config:app-version :=
                $config:expath-descriptor/xs:string(@version);&#xd; declare variable
                $config:app-name-full := $config:expath-descriptor/xs:string(@name);&#xd; declare
                variable $config:app-name-abbreviation :=
                $config:expath-descriptor/xs:string(@abbrev);&#xd; &#xd; &#xd; declare function
                config:path-relative-to-absolute ($path as element(config:path)) as xs:string?
                {&#xd; if (starts-with($path,'/'))&#xd; then $path&#xd; else
                config:path-relative-to-absolute($path, ())&#xd; };&#xd; &#xd; declare function
                config:path-relative-to-absolute($path as element(config:path), $steps-before as
                element(config:path)*) as xs:string? {&#xd; if (starts-with($path,'/'))&#xd; then
                string-join(($path,reverse($steps-before)),'/')&#xd; else&#xd; let $parent-id :=
                substring-after($path/@base,'#')&#xd; let $parent:=
                $config:cr-config//config:path[@xml:id eq $parent-id]&#xd; return&#xd; if
                (exists($parent))&#xd; then
                config:path-relative-to-absolute($parent,($steps-before,$path))&#xd; else if
                ($parent-id eq $config:app-root-key) then
                string-join(($config:app-root,$path,reverse($steps-before)),'/') &#xd; else
                string-join(($path,reverse($steps-before)),'/')&#xd; };&#xd; &#xd; declare variable
                $config:paths as map := &#xd; map:new(for $p in $config:cr-config//config:path&#xd;
                return map:entry($p/@key, data($p)))&#xd; ;&#xd; &#xd; declare function
                config:path($key as xs:string) as xs:string? {&#xd; let
                $path:=$config:cr-config//config:path[@key eq $key]&#xd; return&#xd; if
                (exists($path))&#xd; then config:path-relative-to-absolute($path)&#xd; else ()&#xd;
                };&#xd; &#xd; (:~&#xd; : Returns the xml resource by resolving the relative path
                $relPath using the current application context. &#xd; : If the app resides in the
                file system, the resource will be loaded from there. &#xd; :&#xd; : @param $relPath
                the relative path to the xml resource&#xd; : @return the xml resource &#xd; :)&#xd;
                declare function config:resolve($relPath as xs:string) as document-node()? {&#xd; if
                (starts-with($config:app-root, "/db")) &#xd; then
                doc($config:app-root||"/"||$relPath)&#xd; else
                doc("file://"||$config:app-root||"/"||$relPath)&#xd; };&#xd; &#xd; (:~&#xd; :
                Extended resolver. Tries to locate the requested XML resource in the following
                locations:&#xd; : &#xd; : &lt;ol&gt;&#xd; : &lt;li&gt;'template' collection of the
                current project (as set in $model)&lt;/li&gt;&#xd; : &lt;li&gt;'static' collection
                of the current project (ibd.)&lt;/li&gt;&#xd; : &lt;li&gt;'template' collection in
                which the current template resides&lt;/li&gt;&#xd; : &lt;/ol&gt;&#xd; : &#xd; :
                Checks the availability of the resource via doc-available, which will throw an error
                when&#xd; : confronted with a binary doc.&#xd; : &#xd; : @param $model the model map
                as passed by the eXist-templating framework&#xd; : @param $relPath the relative path
                to the XML resource to be loaded&#xd; : @return the XML resource&#xd; ~:)&#xd;
                declare function config:resolve($model as map(*), $relPath as xs:string) as
                document-node()? {&#xd; doc(config:resolve-to-dbpath($model, $relPath))&#xd; };&#xd;
                &#xd; &#xd; (:~&#xd; : Auxiliary function for the extended resolver. &#xd; : @see
                xqdoc/xqdoc-config;config:resolve&#xd; : &#xd; : Checks the availability of the
                resource via &lt;code&gt;fn:doc-available()&lt;/code&gt;, &#xd; : which will throw
                an error when confronted with a binary resource.&#xd; : &#xd; : @param $model the
                model map as passed by the eXist-templating framework&#xd; : @param $relPath the
                relative path to the xml resource to be loaded&#xd; : @return the absolute path to
                the resource as anyURI&#xd; :)&#xd; declare function config:resolve-to-dbpath($model
                as map(*), $relPath as xs:string) as xs:anyURI {&#xd; let $project-template-dir :=
                config:param-value($model, 'project-template-dir'),&#xd; $project-dir :=
                config:param-value($model, 'project-static-dir'),&#xd; $template-dir :=
                config:param-value($model, 'template-dir')&#xd; return &#xd; if
                (doc-available($project-template-dir||$relPath)) &#xd; then
                xs:anyURI($project-template-dir||$relPath)&#xd; else &#xd; if
                (doc-available($project-dir||$relPath)) &#xd; then
                xs:anyURI($project-dir||$relPath)&#xd; else xs:anyURI($template-dir||$relPath)&#xd;
                };&#xd; &#xd; (:~ &#xd; : Delivers the relative path (to base cr-xq-controller) of a
                template-resource, with precedence &#xd; : for templates from the current project.
                It checks for the resource in the following locations:&#xd; : &#xd; :
                &lt;ol&gt;&#xd; : &lt;li&gt;in the 'templates' collection of the current project (as
                set in $model),&lt;/li&gt;&#xd; : &lt;li&gt;in the 'static' collection of the
                current project (as set in $model),&lt;/li&gt;&#xd; : &lt;li&gt;in the 'data'
                collection for the current project (as set in $model),&lt;/li&gt;&#xd; :
                &lt;li&gt;in the 'template' collection in which the current template
                resides,&lt;/li&gt;&#xd; : &lt;li&gt;in the root collection of the cr-xq
                app.&lt;/li&gt;&#xd; : &lt;li&gt;Otherwise returns $relPath as
                received.&lt;/li&gt;&#xd; : &lt;/ol&gt; &#xd; ~:)&#xd; declare function
                config:resolve-template-to-uri($model as map(*), $relPath as xs:string) as xs:anyURI
                {&#xd; let $project-template-dir := config:param-value($model,
                'project-template-dir'),&#xd; $project-template-baseuri:= config:param-value($model,
                'project-template-baseuri'),&#xd; $project-static-dir := config:param-value($model,
                'project-static-dir'),&#xd; $project-static-baseuri:= config:param-value($model,
                'project-static-baseuri'),&#xd; $project-data-dir := config:param-value($model,
                'project-data-dir'),&#xd; $project-data-baseuri:= config:param-value($model,
                'project-data-baseuri'),&#xd; $template-dir := config:param-value($model,
                'template-dir'),&#xd; $template-baseuri := config:param-value($model,
                'template-baseuri')&#xd; let $dirs:=( $project-template-dir||$relPath,&#xd;
                $project-static-dir||$relPath,&#xd; $project-data-dir||$relPath,&#xd;
                $template-dir||$relPath,&#xd; $config:app-root||$relPath)&#xd; &#xd; let
                $base-uris:=( $project-template-baseuri||$relPath,&#xd;
                $project-static-baseuri||$relPath,&#xd; $project-data-baseuri||$relPath,&#xd;
                $template-baseuri||$relPath,&#xd; $config:app-root-collection||$relPath)&#xd;
                return&#xd; let $available:=&#xd; for $i at $pos in $dirs &#xd; let
                $is-binary-doc:=util:is-binary-doc($i)&#xd; return&#xd; switch (true())&#xd; case
                ($is-binary-doc and util:binary-doc-available(xs:anyURI($i))) return
                $base-uris[$pos]&#xd; case (doc-available($i)) return $base-uris[$pos]&#xd; default
                return ()&#xd; return &#xd; if (exists($available))&#xd; then
                xs:anyURI($available[1])&#xd; else xs:anyURI($relPath)&#xd; };&#xd; &#xd; (:~&#xd; :
                Fetches XHTML-snippets from the project to be inserted into the &lt;head&gt; of the
                page-template. &#xd; : &#xd; : either put code directly into : `&lt;container
                key="html-head"&gt;`&#xd; : or if a module is mentioned in the config, its config is
                checked for &lt;container key="html-head" &gt;&#xd; : &#xd; : @return zero or more
                XHTML fragment &#xd; ~:)&#xd; declare function config:html-head($node as node(),
                $model as map(*)) as element()* {&#xd;
                ($model("config")//mets:file[@USE='projectHtmlHead']/mets:FContent/mets:xmlData/*,&#xd;
                $model("config")//container[@key='html-head']/*)&#xd; };&#xd; &#xd; &#xd; &#xd;
                (:~&#xd; : Returns the repo.xml descriptor for the current application.&#xd; : &#xd;
                : @return the repo.xml descriptor for the running cr-xq instance.&#xd; :)&#xd;
                declare function config:repo-descriptor() as element(repo:meta) {&#xd;
                $config:repo-descriptor&#xd; };&#xd; &#xd; (:~&#xd; : Returns the expath-pkg.xml
                descriptor for the current application.&#xd; :&#xd; : @return the expath-pkg.xml
                descriptor for the running cr-xq instance.&#xd; :)&#xd; declare function
                config:expath-descriptor() as element(expath:package) {&#xd;
                $config:expath-descriptor&#xd; };&#xd; &#xd; &#xd; &#xd; &#xd; &#xd; &#xd; &#xd;
                &#xd; &#xd; &#xd; &#xd; declare %templates:wrap function config:app-title($node as
                node(), $model as map(*)) as text() {&#xd;
                $config:expath-descriptor/expath:title/text()&#xd; };&#xd; &#xd; declare
                %templates:wrap function config:app-description($node as node(), $model as map(*))
                as text() {&#xd; $config:repo-descriptor/repo:description/text()&#xd; };&#xd; &#xd;
                (:~&#xd; : For debugging: generates a table showing all properties defined&#xd; : in
                the application descriptors.&#xd; :)&#xd; declare function config:app-info($node as
                node(), $model as map(*)) {&#xd; &lt;table class="table table-bordered
                table-striped"&gt;{&#xd; for $key in config:param-keys($model)&#xd; order by
                $key&#xd; return &#xd; &lt;tr&gt;&#xd; &lt;td&gt;{$key}&lt;/td&gt;&#xd;
                &lt;td&gt;{config:param-value($node, $model,'','',$key)}&lt;/td&gt;&#xd;
                &lt;/tr&gt;&#xd; }&lt;/table&gt;&#xd; };&#xd; &#xd; (:~ lists all parameter keys in
                the configuration file&#xd; : sorted alphabetically&#xd; ~:)&#xd; declare function
                config:param-keys($config as map(*)*) as xs:string* {&#xd; let $config :=
                $config("config")&#xd; let $special-params := ('app-root', 'app-root-collection',
                'base-url', 'project-dir', 'template-dir', 'template-baseuri',&#xd;
                'project-template-dir', 'project-template-baseuri', &#xd; 'project-data-dir',
                'project-data-baseuri',&#xd; 'project-static-dir', 'project-static-baseuri',&#xd;
                'exist-controller', 'exist-path', 'exist-prefix', 'exist-resource',
                'exist-root',&#xd; 'request-uri', 'request-url')&#xd; &#xd; for $key in
                (distinct-values($config//param/xs:string(@key)), $special-params)&#xd; order by
                $key&#xd; return $key&#xd; &#xd; };&#xd; &#xd; (:~ Helper function which reads
                mets:file element and returns either the value from FContent or the @xlink:href uri
                from FLocat. If both are provided, the former is returned.&#xd; :&#xd; : @param
                element(mets:file) &#xd; : @return uri or xmldata&#xd; ~:)&#xd; declare function
                config:mets-file($file as element(mets:file)?) as item()* {&#xd; switch
                (true())&#xd; case (not(exists($file))) return ()&#xd; case
                (exists($file/mets:FContent/mets:xmlData)) return&#xd;
                $file/mets:FContent/mets:xmlData/*&#xd; case (exists($file/mets:FLocat)) return&#xd;
                let $uri:=$file/mets:FLocat/@xlink:href&#xd; return
                config:db-to-relative-path(xs:string($uri))&#xd; default return ()&#xd; };&#xd;
                &#xd; (:~&#xd; : Returns the relative path of a project resource as needed by the
                config module. &#xd; ~:)&#xd; declare function config:db-to-relative-path($path as
                xs:string) as xs:string {&#xd; let $steps:=tokenize($path,'/')&#xd; return
                ($steps[position() eq count($steps)-1]||"/"||$steps[last()])&#xd; };&#xd; &#xd;
                &#xd; (:~ Lookup function for values in the current configuration and request.
                T&#xd; : Following precedence levels:&#xd; : &lt;ol&gt;&#xd; : &lt;li&gt;a few
                special parameters regarding project and template collections&lt;/li&gt;&#xd; :
                &lt;li&gt;request parameter&lt;/li&gt;&#xd; : &lt;li&gt;config parameter for given
                function within given container (config:container/function/param)&lt;/li&gt;&#xd; :
                &lt;li&gt;config parameter for given function
                (config:function/param)&lt;/li&gt;&#xd; : &lt;li&gt;config parameter for given
                module (config:module/param)&lt;/li&gt;&#xd; : &lt;li&gt;global config param
                (config:param)&lt;/li&gt;&#xd; : &lt;/ol&gt;&#xd; : &#xd; : @param strict only
                returns a value if it exists for given level of precedence (module) &#xd; : @return
                either the string-value of the @value-attribute or the content of the param-node (in
                that order)&#xd; :)&#xd; declare function config:param-value($node as node()*,
                $model, $module-key as xs:string, $function-key as xs:string, $param-key as
                xs:string, $strict as xs:boolean) as item()* {&#xd; &#xd; let $node-id :=
                $node/xs:string(@id)&#xd; let $config := if ($model instance of map(*)) then
                $model("config") else $model,&#xd; $mets :=
                $config/descendant-or-self::mets:mets[@TYPE='cr-xq project'],&#xd;
                $crProjectParameters:=
                $mets//mets:techMD[@ID=$config:PROJECT_PARAMETERS_ID]/mets:mdWrap/mets:xmlData&#xd;
                &#xd; let $param-special:=&#xd; switch($param-key)&#xd; case "app-root" return
                $config:app-root&#xd; case "app-root-collection" return
                $config:app-root-collection&#xd; case "projects-baseuri" return
                $config-params:projects-baseuri &#xd; case "shib-user-pwd" return
                $config-params:shib-user-pwd&#xd; case "request-uri" return
                xs:string(request:get-uri())&#xd; (: case "base-url" return
                string-join(tokenize(request:get-url(),'/')[position() != last()],'/')||'/':)&#xd;
                case "base-url" return
                substring-before(request:get-url(),$config:app-root-collection)||$config:app-root-collection
                &#xd; case $config:PROJECT_PID_NAME return $mets/xs:string(@OBJID)&#xd; case
                "project-dir" return util:collection-name($config[self::mets:mets])||"/"&#xd; case
                "project-static-dir" return &#xd; let $project-dir:=
                util:collection-name($config[self::mets:mets])&#xd; return concat($project-dir, "/",
                $config:project-static-dir)&#xd; case "project-static-baseuri" return&#xd; let
                $project-id:=$mets/xs:string(@OBJID)&#xd; return
                $config-params:projects-baseuri||$project-id||"/"||$config:project-static-dir&#xd;
                &#xd; case "public-project-baseurl" return
                replace($config:cr-config//param[@key='public-repo-baseurl'],'/$','')||"/"||$mets/xs:string(@OBJID)||"/"&#xd;
                &#xd; case 'project-template-dir' return&#xd; let $project-dir:=
                util:collection-name($config[self::mets:mets])&#xd; let $template :=
                $crProjectParameters//param[@key='template']&#xd; return
                $project-dir||'/'||$config:templates-dir||$template||'/'&#xd; case
                'project-template-baseuri' return&#xd; let $project-id:=$mets/xs:string(@OBJID)&#xd;
                let $template := $crProjectParameters//param[@key='template']&#xd; return
                $config-params:projects-baseuri||$project-id||'/'||$config:templates-dir||$template||"/"&#xd;
                case 'template-dir' return&#xd; let $template :=
                $crProjectParameters//param[@key='template']&#xd; return
                $config:app-root||'/'||$config:templates-dir||$template||"/"&#xd; case
                'template-baseuri' return&#xd; let $template :=
                $crProjectParameters//param[@key='template']&#xd; return
                $config:templates-baseuri||$template||"/"&#xd; case 'project-data-dir' return&#xd;
                let $project-id:=$mets/xs:string(@OBJID)&#xd; let
                $data-path:=config:common-path-from-FLocat($model,'projectData')&#xd; return
                $config-params:projects-baseuri||$project-id||'/'||$data-path&#xd; case
                'project-data-baseuri' return&#xd; let $project-id:=$mets/xs:string(@OBJID)&#xd; let
                $data-path:=config:common-path-from-FLocat($model,'projectData')||"/"&#xd; return
                $config-params:projects-baseuri||$project-id||'/'||$data-path&#xd; case 'visibility'
                return &#xd; let $ace:=$mets//sm:ace[@who='other']&#xd; return &#xd; if
                ($ace/(@access_type='DENIED' and starts-with(@mode,'r')))&#xd; then 'protected'&#xd;
                else 'unprotected'&#xd; case 'users' return&#xd; (: sm:get-group-members-function
                need to be executed as a logged in user :)&#xd; (: let $login:=
                xmldb:login($config:app-root,"cr-xq","cr=xq!"):)&#xd; let $ace:=
                $mets//sm:ace[@access_type='ALLOWED' and starts-with(@mode,'r')],&#xd; $users:=
                $ace[@target='USER']/@who,&#xd; $groups:= $ace[@target='GROUP']/@who,&#xd;
                $group-members:=()&#xd; (:for $g in $groups&#xd; return&#xd;
                system:as-user("cr-xq","cr=xq!",&#xd; if (sm:group-exists($g))&#xd; then
                sm:get-group-members($g)&#xd; else ()&#xd; ):),&#xd; $allowed-users:=
                ($group-members,$users)&#xd; return string-join($allowed-users,',')&#xd; &#xd; case
                $config:PROJECT_DMDSEC_ID return
                $mets//mets:dmdSec[@ID=$config:PROJECT_DMDSEC_ID]/(mets:mdWrap/mets:xmlData|doc(mets:mdRef/@xlink:href))/cmd:CMD&#xd;
                case 'project-title' return
                ($mets//mets:dmdSec[@ID=$config:PROJECT_DMDSEC_ID]/(mets:mdWrap/mets:xmlData|doc(mets:mdRef/@xlink:href))//cmd:CollectionInfo/cmd:Title[text()],$mets/@LABEL)[1]&#xd;
                &#xd; case 'mappings' return
                $mets//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID]/mets:mdWrap/mets:xmlData/map&#xd;
                case 'teaser-text' return
                config:mets-file($mets//mets:file[@USE='projectTeaserText'])&#xd; case 'logo-image'
                return config:mets-file($mets//mets:file[@USE='projectLogoImage']) &#xd; case
                'logo-text' return config:mets-file($mets//mets:file[@USE='projectLogoLink'])&#xd;
                &#xd; default return ()&#xd; &#xd; &#xd; let $param-request := try {
                request:get-parameter($param-key,'') } catch * { () }&#xd; let $param-cr :=
                $config:cr-config//param[@key=$param-key]&#xd; let $param-container :=
                $config//container[@key=$node-id]/function[xs:string(@key)=concat($module-key, ':',
                $function-key)]/param[xs:string(@key)=$param-key]&#xd; let $param-function :=
                $config//function[xs:string(@key)=concat($module-key, ':',
                $function-key)]/param[xs:string(@key)=$param-key]&#xd; let $param-module :=
                $config//module[xs:string(@key)=$module-key]/param[xs:string(@key)=$param-key]&#xd;
                let $param-repo := $config:cr-config//param[xs:string(@key)=$param-key]&#xd; let
                $param-global:= $config//param[xs:string(@key)=$param-key]&#xd; &#xd; (: $strict
                currently only implemented for module :)&#xd; let $param := &#xd; if ($strict) &#xd;
                then&#xd; if ($module-key ne '' and exists($param-module)) &#xd; then
                $param-module[1]&#xd; else ""&#xd; else&#xd; switch(true())&#xd; case
                ($param-special != '') return $param-special&#xd; case ($param-request != '') return
                $param-request[1]&#xd; case (exists($param-cr)) return $param-cr[1]&#xd; case
                (exists($param-container)) return $param-container[1]&#xd; case
                (exists($param-repo)) return $param-repo[1]&#xd; case (exists($param-function))
                return $param-function[1]&#xd; case (exists($param-module)) return
                $param-module[1]&#xd; case (exists($param-global)) return $param-global[1]&#xd;
                default return ""&#xd; &#xd; let $param-value := &#xd; switch(true())&#xd; case
                ($param instance of text() or $param instance of xs:string) return $param&#xd; case
                ($param instance of attribute()) return data($param)&#xd; case
                (exists($param/@value)) return $param/xs:string(@value)&#xd; case (exists($param/*))
                return $param&#xd; default return $param/text() &#xd; return ($param-value)&#xd;
                &#xd; };&#xd; &#xd; &#xd; (:~&#xd; : This functions generates a data-path parameter
                by looking for common path to all files listed in project-data mets:fileGrp.&#xd; :
                It is needed for compatability reasons as
                &lt;code&gt;config:param-value()&lt;/code&gt; has to provide a 'project-data-dir'
                param which&#xd; : was formerly hardcoded in conf.xml. With the METS-based project
                catalog, this is not necessary any more, strictly speaking.&#xd; : &#xd; : Beware:
                This obviously only works, when all the data listed in project.xml share a common
                path.&#xd; : &#xd; : @param $model a map with a "config" key, which provides the
                project's project.xml setup.&#xd; : @result returns a path common to all project
                data files or the empty sequence if there's no common path. &#xd; ~:)&#xd; declare
                function config:common-path-from-FLocat($model as map(*), $fileGrpID as xs:string)
                as xs:string? {&#xd; let $config:= $model("config"),&#xd; $data:=
                $config//mets:fileGrp[@ID=$fileGrpID]//mets:FLocat/xs:string(@xlink:href)&#xd; &#xd;
                let $tokenized:=for $d in $data return tokenize($d,'/'),&#xd; $pathSteps:=for $t in
                $tokenized&#xd; where count(index-of($tokenized,$t)) eq count($data)&#xd; return
                $t&#xd; return &#xd; if (exists(distinct-values($pathSteps)))&#xd; then
                string-join(distinct-values($pathSteps[.!='']),'/')&#xd; else ()&#xd; };&#xd; &#xd;
                (:~ override the full-function, without (later added) $strict-parameter (set to
                false() &#xd; :)&#xd; declare function config:param-value($node as node()*, $model,
                $module-key as xs:string, $function-key as xs:string, $param-key as xs:string) as
                item()* {&#xd; config:param-value($node,$model,$module-key,$function-key,$param-key,
                false())&#xd; };&#xd; &#xd; (:~ returns the value of a parameter, but regards only
                request or global config param &#xd; :)&#xd; declare function
                config:param-value($model, $param-key as xs:string) as item()* {&#xd;
                config:param-value((),$model,'','',$param-key)&#xd; };&#xd; &#xd; &#xd; &#xd; (:~
                &#xd; : Fetches the configuration (&lt;code&gt;project.xml&lt;/code&gt;) of the
                requested project &#xd; : plus the configuration files
                (&lt;code&gt;config.xml&lt;/code&gt;) of all modules.&#xd; :&#xd; : This function is
                called by templates:init() where it is used to pass all available &#xd; :
                configuration down to the eXist HTML templating function. &#xd; :&#xd; : @param
                $project Project ID&#xd; : @return&#xd; ~:)&#xd; declare function
                config:config($project as xs:string) as item()* {&#xd; let $project-config:=
                config:project-config($project),&#xd; $module-config:= config:module-config(),&#xd;
                $repo-config := $config:cr-config//params&#xd; return ($project-config,
                $module-config,$repo-config)&#xd; };&#xd; &#xd; declare function
                config:config-map($project as xs:string) as item()* {&#xd; map { "config" :=
                config:config($project)}&#xd; };&#xd; &#xd; (:~ Gets the catalog file for the given
                project. &#xd; : &lt;b&gt;Beware:&lt;/b&gt; Former fall-back mechanisms have been
                deprecated.&#xd; : &#xd; : @param $project project identifier&#xd; : @return config
                element with relevant parameters.&#xd; :)&#xd; declare function
                config:project-config($project as xs:string) as element()* {&#xd; let $project :=
                collection($config-params:projects-dir)//mets:mets[@OBJID eq $project]&#xd; return
                $project&#xd; };&#xd; &#xd; &#xd; (:~&#xd; : Getter function for a cr-project's
                mappings.&#xd; :&#xd; : @param $item: input. We accept strings or elements() as well
                as a map. This may contain one of the following keys:&#xd; : &lt;ol&gt;&#xd; :
                &lt;li&gt;'config': the 'classic' config with project and module-wide
                configuration&lt;/li&gt;&#xd; : &lt;li&gt;'mets': the cr-project file of the
                project&lt;/li&gt;&#xd; : &lt;li&gt;'mappings': a &lt;map&gt; of this specific
                project&lt;/li&gt;&#xd; : &lt;/ol&gt;&#xd; : @result: one or more &lt;map&gt;
                elements &#xd; ~:)&#xd; declare function config:mappings($config as item()*) as
                element(map)* {&#xd; for $item in $config return &#xd; typeswitch ($item)&#xd; case
                map() return &#xd;
                ($item("config")//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID]/mets:mdWrap[1]/mets:xmlData/map,&#xd;
                $item("mets")//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID]/mets:mdWrap[1]/mets:xmlData/map,&#xd;
                $item("mappings"))[1]&#xd; case xs:string return
                config:project-config($item)//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID]/mets:mdWrap[1]/mets:xmlData/*&#xd;
                case text() return
                config:project-config($item)//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID]/mets:mdWrap[1]/mets:xmlData/*&#xd;
                case element() return
                $item//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID]/mets:mdWrap[1]/mets:xmlData/*&#xd;
                default return ()&#xd; };&#xd; &#xd; (:~ lists all defined projects based on the
                project-id param in the config.&#xd; : this would only read the projects in separate
                folders:&#xd; let $projects :=
                xmldb:get-child-collections($config-params:projects-dir)&#xd; and we want to take
                also projects into account without a separate folder, defined solely by their
                config&#xd; (especially meant for external projects, that shall have only a minimal
                mention)&#xd; &#xd; @returns the ids of all projects &#xd; :)&#xd; declare function
                config:list-projects() {&#xd;
                collection($config-params:projects-dir)//mets:mets/xs:string(@OBJID)&#xd; };&#xd;
                &#xd; &#xd; (:~&#xd; : Lists the names of currently available modules. &#xd; : This
                function simply lists the children in the cr-xq's 'modules'-collection as defined in
                $config:modules-dir. &#xd; :&#xd; : @return sequence of modules' names &#xd;
                ~:)&#xd; declare function config:list-modules() as xs:string* {&#xd;
                xmldb:get-child-collections($config:modules-dir)&#xd; };&#xd; &#xd; &#xd; (:~
                Fetches configuration files for all avaiable modules.&#xd; : This function tries to
                locate the file 'conf.xml' in each of the modules' collection &#xd; : found by
                &lt;code&gt;config:list:modules()&lt;/code&gt;. &#xd; : &#xd; : @returns a sequence
                of module-config documents. &#xd; ~:)&#xd; declare function config:module-config()
                as item()* { &#xd; for $module in config:list-modules()&#xd; return &#xd; if
                (doc-available($config:modules-dir||$module||"/config.xml"))&#xd; then
                doc($config:modules-dir||$module||"/config.xml")&#xd; else ()&#xd; };&#xd; &#xd; (:~
                checks if there is a cr-catalog file for given project&#xd; : &#xd; : @param
                $project project identifier&#xd; ~:)&#xd; declare function
                config:project-exists($project as xs:string) {&#xd;
                exists(collection($config-params:projects-dir)//mets:mets[@OBJID = $project])&#xd;
                };&#xd; &#xd; declare function config:shib-user() {&#xd; (for $attribute-name in
                ('cn', 'eppn', 'REMOTE_USER','affiliation') &#xd; return
                request:get-attribute($attribute-name))[1]&#xd; };</f>
            <f n="cr.xql">xquery version "3.0";&#xd; &#xd; import module namespace project =
                "http://aac.ac.at/content_repository/project" at "project.xqm";&#xd; import module
                namespace resource = "http://aac.ac.at/content_repository/resource" at
                "resource.xqm";&#xd; import module namespace rf =
                "http://aac.ac.at/content_repository/resourcefragment" at
                "resourcefragment.xqm";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd; &#xd; declare
                namespace public = "http://aac.ac.at/content_repository/project/public";&#xd;
                declare namespace mets = "http://www.loc.gov/METS/";&#xd; declare namespace cr =
                "http://aac.ac.at/content_repository"; &#xd; &#xd; (:~&#xd; : This XQuery is the
                endpoint for any user-driven content management.&#xd; : It basically maps the lower
                level functions in project.xqm, resource.xqm and resourcefragment.xqm to a &#xd; :
                public interface by interpreting the annotations in the &#xd; : modules' function
                definitions.&#xd; :&#xd; : @author Daniel Schopper&#xd; : @since 2013-11 &#xd;
                ~:)&#xd; &#xd; (:~&#xd; : We automatically determine which entity has been
                requested. In the following order: &#xd; : - if present, the header/parameter
                'entity'&#xd; : - if there's only a project-pid, 'project' is assumed,&#xd; : - if
                there's a project-pid and a resource-pid, latter is assumed,&#xd; : - if there's
                project-pid, resource-pid and resource-fragment-pid, latter is assumed.&#xd; : - by
                default 'project' is returned &#xd; ~:)&#xd; declare variable $entity :=&#xd; let
                $req:= local:get-parameter("entity"),&#xd; $params:=
                local:get-parameter-names()&#xd; return&#xd; switch (true())&#xd; case $req !=""
                return $req&#xd; case $params='project-pid' and not($params='resource-pid') and
                not($params='resourcefragment-pid') return "project"&#xd; case $params='project-pid'
                and $params='resource-pid' and not($params='resourcefragment-pid') return
                "resource"&#xd; case $params='project-pid' and $params='resource-pid' and
                $params='resourcefragment-pid' return " "&#xd; default return "project"&#xd; ; &#xd;
                &#xd; declare variable $namespaces := map {&#xd; "project" :=
                "http://aac.ac.at/content_repository/project",&#xd; "resource" :=
                "http://aac.ac.at/content_repository/resource",&#xd; "resourcefragment" :=
                "http://aac.ac.at/content_repository/resourcefragment"&#xd; };&#xd; &#xd; declare
                variable $prefixes := map {&#xd; "project" := "project",&#xd; "resource" :=
                "resource",&#xd; "resourcefragment" := "rf"&#xd; };&#xd; &#xd; declare variable
                $entity-ns := $namespaces($entity);&#xd; declare variable $entity-ns-prefix :=
                $prefixes($entity);&#xd; &#xd; &#xd; declare variable $functions:=&#xd; for $f in
                inspect:module-functions(xs:anyURI($config:app-root||"/core/"||$entity||".xqm"))&#xd;
                return inspect:inspect-function($f);&#xd; &#xd; &#xd; declare variable
                $local:properties := $functions[annotation[@name='property:name']];&#xd; declare
                variable $public-properties :=
                $local:properties[annotation[@name='property:realm']/value='public'];&#xd; declare
                variable $protected-properties :=
                $local:properties[annotation[@name='property:realm']/value='protected'];&#xd;
                declare variable $properties-names :=
                $local:properties/annotation[@name="property:name"]/data(value);&#xd; &#xd; declare
                variable $local:methods := $functions[annotation/@name='method:name'];&#xd; declare
                variable $public-methods :=
                $local:methods[annotation[@name='method:realm']/value='public'];&#xd; declare
                variable $protected-methods :=
                $local:methods[annotation[@name='method:realm']/value='protected'];&#xd; declare
                variable $methods-names :=
                $local:methods/annotation[@name='method:name']/data(value);&#xd; &#xd; &#xd; declare
                variable $project-pid := local:get-parameter("project-pid");&#xd; declare variable
                $resource-pid := local:get-parameter("resource-pid");&#xd; declare variable
                $resourcefragment-pid := local:get-parameter("resourcefragment-pid");&#xd; &#xd; (:
                a shortcut to the main entity's id :)&#xd; declare variable $id :=&#xd;
                switch($entity)&#xd; case "resourcefragment" return $resourcefragment-pid&#xd; case
                "resource" return $resource-pid&#xd; case "project" return $project-pid&#xd; default
                return $project-pid&#xd; ;&#xd; &#xd; &#xd; declare function local:get() {&#xd;
                switch($entity)&#xd; case "project" return project:get($project-pid)&#xd; case
                "resource" return resource:get($resource-pid,$project-pid)&#xd; case
                "resourcefragment" return
                rf:get($resourcefragment-pid,$resource-pid,$project-pid)&#xd; default return ()&#xd;
                };&#xd; &#xd; (:~&#xd; : Helper functions for output formatting&#xd; ~:)&#xd;
                declare function local:wrap($id as xs:string, $content as item()*){&#xd; element
                {QName($entity-ns,$entity)} {&#xd; attribute id {$id},&#xd; $content&#xd; }&#xd;
                };&#xd; &#xd; (: TODO transfer to WSDL :)&#xd; declare function
                local:format-content($content as item()*){&#xd; let $format :=
                request:get-header("Accept") &#xd; return &#xd; switch (true())&#xd; case
                contains($format,"xml") return $content&#xd; case contains($format,"html") return
                $content&#xd; default return $content&#xd; };&#xd; &#xd; &#xd; (:~&#xd; : Helper
                function which gets parameters either as reqeust parameters or http headers, &#xd; :
                depending on the reqeust method. &#xd; ~:)&#xd; declare function
                local:get-parameter($name as xs:string) {&#xd; local:get-parameter($name,"")&#xd;
                };&#xd; &#xd; declare function local:get-parameter($name as xs:string, $default as
                item()?) {&#xd; if ($name eq 'data')&#xd; then $default&#xd; else &#xd; if
                (request:get-method() = ("POST","DELETE","PUT")) &#xd; then
                (request:get-header($name),$default)[1] &#xd; else
                request:get-parameter($name,$default)&#xd; };&#xd; &#xd; (:~&#xd; : Get parameter
                names and add a 'virtual' parameter $data when the request body is not empty.&#xd;
                ~:)&#xd; declare function local:get-parameter-names() as xs:string* {&#xd; if
                (request:get-method() = ("POST","DELETE","PUT")) &#xd; then
                (request:get-header-names(),if(exists(request:get-data())) then 'data' else ())&#xd;
                else (request:get-parameter-names(),if(exists(request:get-data())) then 'data' else
                ())&#xd; };&#xd; &#xd; &#xd; declare function local:user-role(){&#xd; ()&#xd;
                };&#xd; &#xd; declare function local:describe($id){&#xd; local:wrap($id,(&#xd;
                element {QName($entity-ns,'properties')} {&#xd; &lt;usage&gt;Properties are queried
                via GET requests, adding one or more request parameters with name 'property' and the
                name of the property to retrieve. Request parameter id (id of the project to query)
                is required. 'Realm' denotes whether the property is world readable or
                not.&lt;/usage&gt;,&#xd; for $p in $local:properties&#xd; let $name :=
                $p/annotation[@name='property:name']/data(value),&#xd; $realm :=
                $p/annotation[@name='property:realm']/data(value)&#xd; return &#xd; element
                {QName($entity-ns,'property')} {&#xd; attribute realm {$realm},&#xd; attribute name
                {$name},&#xd; element description {data($p/normalize-space(description))}&#xd;
                }&#xd; },&#xd; element {QName($entity-ns,'methods')} {&#xd; &lt;usage&gt;Methods are
                execute via POST, PUT or DELETE requests, adding one or more request headers with
                appropriate names. Header 'id' (id of the project to query) is
                required.&lt;/usage&gt;,&#xd; for $me in $local:methods &#xd; let $parameters:=
                $me/argument[@var!='data'],&#xd; $realm :=
                $me/annotation[@name='method:realm']/data(value),&#xd; $group :=
                $me/annotation[@name='method:group']/data(value),&#xd; $name :=
                $me/annotation[@name='method:name']/data(value)&#xd; return &#xd; element
                {QName($entity-ns,'method')} {&#xd; attribute name {$name},&#xd; attribute method
                {"POST"}, &#xd; attribute realm {$realm},&#xd; attribute groups {$group},&#xd;
                attribute data {exists($me/argument[@var='data'])},&#xd; element description
                {data($me/normalize-space(description))},&#xd; for $p in $parameters return&#xd;
                element {QName($entity-ns,'parmeter')} {&#xd; attribute name {$p/@var},&#xd;
                attribute type {$p/@type},&#xd; element description {data($p)}&#xd; }&#xd; }&#xd;
                }&#xd; ))&#xd; };&#xd; &#xd; declare function local:find-function($description as
                element(function)) as item()* {&#xd; try {&#xd;
                function-lookup(xs:QName($description/xs:string(@name)),count($description/argument))&#xd;
                } catch * {&#xd; ()&#xd; }&#xd; };&#xd; &#xd; declare function local:apply($f as
                function, $s as item()*){&#xd; switch(count($s))&#xd; case 0 return $f()&#xd; case 1
                return $f($s)&#xd; case 2 return $f($s[1],$s[2])&#xd; case 3 return
                $f($s[1],$s[2],$s[3])&#xd; case 4 return $f($s[1],$s[2],$s[3],$s[4])&#xd; case 5
                return $f($s[1],$s[2],$s[3],$s[4],$s[5])&#xd; case 6 return
                $f($s[1],$s[2],$s[3],$s[4],$s[5],$s[6])&#xd; case 7 return
                $f($s[1],$s[2],$s[3],$s[4],$s[5],$s[6],$s[7])&#xd; case 8 return
                $f($s[1],$s[2],$s[3],$s[4],$s[5],$s[6],$s[7],$s[8])&#xd; case 9 return
                $f($s[1],$s[2],$s[3],$s[4],$s[5],$s[6],$s[7],$s[8],$s[9])&#xd; case 10 return
                $f($s[1],$s[2],$s[3],$s[4],$s[5],$s[6],$s[7],$s[8],$s[9],$s[10])&#xd; default return
                $f($s)&#xd; };&#xd; &#xd; (: we only accept one project-id and one method (to avoid
                side-effects), but several 'property' request parameters :)&#xd; let $request-method
                := request:get-method()&#xd; let $method :=
                local:get-parameter("method","")[1],&#xd; $property
                :=local:get-parameter("property","")&#xd; &#xd; &#xd; let $data := &#xd; let
                $d:=request:get-data()&#xd; return &#xd; typeswitch($d)&#xd; case document-node()
                return $d/node()&#xd; default return $d&#xd; &#xd; &#xd; let $content:=&#xd; switch
                (true())&#xd; (: all request methods except PUT require an id to be set :)&#xd; case
                ($id = "" and $request-method != 'PUT') return &lt;cr:error&gt;missing required
                parameter id&lt;/cr:error&gt;&#xd; case $request-method != 'PUT' and
                not(local:get()) return &lt;cr:error&gt;{$entity-ns-prefix} with id "{$id}" does not
                exist&lt;/cr:error&gt;&#xd; default return&#xd; switch ($request-method)&#xd; case
                'DELETE' return&#xd; switch($entity)&#xd; case "project" return&#xd; if
                (xs:boolean(local:get-parameter("purge")) eq true())&#xd; then
                project:purge($id,true())&#xd; else project:purge($id)&#xd; case "project"
                return&#xd; if (xs:boolean(local:get-parameter("purge")) eq true())&#xd; then
                resource:purge($id,true())&#xd; else resource:purge($id,false())&#xd; default return
                ()&#xd; case 'POST' return&#xd; if ($method = $methods-names)&#xd; then &#xd; (:
                here we map request parameters to function arguemnts, i.e. remove 'method' request
                parmaeter, add a data argument with the content of the request body :)&#xd; (: get
                all function definitions for this function name :)&#xd; let $all-defs :=
                $local:methods[annotation[@name='method:name']/value = $method]&#xd; (: iterate over
                all fn definitions and find those, whose arguments are provided in
                request-parameters :)&#xd; let $def:= &#xd; let $match-args:=for $x in $all-defs
                return $x[every $a in $x/argument/xs:string(@var) satisfies $a =
                local:get-parameter-names()]&#xd; (: get the matching function with the most number
                of arguments :)&#xd; return $match-args[count(arguments) =
                max(count($match-args/arguments))]&#xd; let $fn := &#xd; if (exists($def)) &#xd;
                then local:find-function($def) &#xd; else () &#xd; return &#xd; if
                (exists($fn))&#xd; then &#xd; let $args:= &#xd; for $x in
                $def/argument/xs:string(@var) return &#xd; if ($x eq 'data') then $data&#xd; else
                local:get-parameter($x)&#xd; return local:apply($fn,$args) &#xd; else
                &lt;error&gt;no function found for method {$method}&lt;/error&gt; &#xd; else&#xd; if
                ($method = '')&#xd; then &lt;cr:error&gt;Missing parameter
                'method'.&lt;/cr:error&gt;&#xd; else &lt;cr:error&gt;undefined method
                '{$method}'&lt;/cr:error&gt;&#xd; &#xd; case 'PUT' return&#xd; switch
                ($entity-ns-prefix)&#xd; case "project" return &#xd; switch (true())&#xd; case
                ($id!='' and $data instance of element (mets:mets)) return project:new($data,
                $id)&#xd; case ($id!='') return project:new($id)&#xd; default return
                project:new()&#xd; case "resource" return &#xd; let $resource-pid:=&#xd; if
                (local:get-parameter("prepareData") = true())&#xd; then
                resource:new($data,$project-pid, true())&#xd; else resource:new($data,$project-pid,
                false())&#xd; return resource:get($resource-pid,$project-pid)&#xd; default return
                ()&#xd; &#xd; (: GET only serves static properties :)&#xd; case 'GET' return&#xd; if
                (exists($property))&#xd; then &#xd; let $values := &#xd; (: filter: only consider
                valid propertise:)&#xd; let $properties := distinct-values($property),&#xd; $total
                := count($properties)&#xd; return&#xd; for $p at $pos in $properties return&#xd;
                element project:property {&#xd; attribute id {$p},&#xd; attribute n {$pos},&#xd;
                attribute total {$total},&#xd; attribute known {$p = $properties-names},&#xd; if ($p
                = $properties-names)&#xd; then &#xd; let $description :=
                $local:properties[annotation[@name='property:name']/value=$p]&#xd; let $f :=
                local:find-function($description)&#xd; return&#xd; if (exists($f))&#xd; then
                $f($id)&#xd; else &lt;error&gt;function for property {$p} not found.
                {xs:anyURI($description/@name)} {count($description/argument)}
                {$local:properties[annotation[@name='property:name']/value=$p]}&lt;/error&gt;&#xd;
                else ()&#xd; }&#xd; return &#xd; if (some $x in $property satisfies $x != '')&#xd;
                then local:wrap($id,$values)&#xd; (: by default just describe the available
                properties and methods :)&#xd; else local:describe($id)&#xd; else
                local:describe($id)&#xd; default &#xd; return local:describe($id) &#xd; &#xd; return
                local:format-content($content)</f>
            <f n="cr.xqm">xquery version "3.0";&#xd; module namespace
                cr="http://aac.ac.at/content_repository";&#xd; &#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd; import module
                namespace repo-utils="http://aac.ac.at/content_repository/utils" at
                "repo-utils.xqm";&#xd; import module namespace
                project="http://aac.ac.at/content_repository/project" at "project.xqm";&#xd; import
                module namespace resource="http://aac.ac.at/content_repository/resource" at
                "resource.xqm";&#xd; &#xd; declare namespace
                xlink="http://www.w3.org/1999/xlink";&#xd; declare namespace mets =
                "http://www.loc.gov/METS/";&#xd; declare namespace fcs =
                "http://clarin.eu/fcs/1.0";&#xd; declare namespace
                mods="http://www.loc.gov/mods/v3";&#xd; declare namespace metsrights =
                "http://cosimo.stanford.edu/sdr/metsrights/";&#xd; declare namespace
                sm="http://exist-db.org/xquery/securitymanager";&#xd; &#xd; declare namespace
                rest="http://exquery.org/ns/restxq";&#xd; &#xd; &#xd; &#xd; declare function
                cr:project-pids(){&#xd; let
                $projects:=collection(config:path("projects"))//mets:mets[@TYPE eq "cr-xq
                project"]&#xd; return&#xd; &lt;cr:projects n="{count($projects)}"&gt;{&#xd; for $p
                in $projects&#xd; return &lt;cr:project
                project-pid="{$p/@OBJID}"&gt;{$p//mets:dmdSec[@ID eq
                $config:PROJECT_DMDSEC_ID]}&lt;/cr:project&gt;&#xd; }&lt;/cr:projects&gt;&#xd;
                };&#xd; &#xd; (:~ This function returns a node set consisting of all available
                documents of the project as listed in mets:fileGrp[@USE="Project Data"] &#xd; :
                &#xd; : @param $x-context: a ,-separted sequence of identifiers&#xd; ~:)&#xd; &#xd;
                declare function cr:resolve-id-to-data($x-context as xs:string, $also-project as
                xs:boolean ) as item()* {&#xd; let $projects:=config:path("projects"),&#xd; $rf-coll
                := collection(config:path('resourcefragments')),&#xd;
                $contexts:=tokenize($x-context,",")&#xd; &#xd; let $data := &#xd; for $c in
                $contexts&#xd; let $id := normalize-space($c),&#xd; $entry:=
                cr:resolve-id-to-entry($id),&#xd; $is-project := ($entry instance of
                element(mets:mets))&#xd; return&#xd; if ($is-project) then&#xd; if ($also-project)
                then &#xd; let $project-pid := $entry/xs:string(@OBJID) &#xd; (: go file by
                file:&#xd; let $files := $entry//mets:file[@USE =
                $config:RESOURCE_WORKINGCOPY_FILE_USE]&#xd; return
                $files/mets:FLocat!concat("doc('",./@xlink:href,"')")&#xd; VS. go for whole
                collection :)&#xd; return
                collection(project:path($project-pid,"workingcopies"))&#xd; else ()&#xd; else &#xd;
                let $project-pid := root($entry)/mets:mets/xs:string(@OBJID)&#xd; return if
                ($entry/xs:string(@TYPE) ='resource') then resource:get-data($id,
                $project-pid,'workingcopy')&#xd; else
                $rf-coll//fcs:resourceFragment[@resourcefragment-pid eq $id] &#xd; &#xd; (: return
                util:eval("("||string-join($paths,',')||")"):)&#xd; return $data&#xd; };&#xd; &#xd;
                &#xd; declare function cr:resolve-id-to-data($x-context as xs:string) as item()*
                {&#xd; cr:resolve-id-to-data($x-context, true())&#xd; };&#xd; &#xd; &#xd; declare
                function cr:context-to-fragments($x-context as xs:string) as item()* {&#xd; let
                $projects:=config:path("projects"),&#xd; $contexts:=tokenize($x-context,",")&#xd;
                let $paths := &#xd; for $c in $contexts&#xd; let $id := normalize-space($c),&#xd;
                $div:= collection($projects)//mets:div[@ID eq $id],&#xd; $project := if
                (exists($div)) then () else collection($projects)//mets:mets[@OBJID eq $id],&#xd;
                $fileid := ($div/mets:fptr/@FILEID,$div/mets:fptr/mets:area/@FILEID),&#xd;
                $data-file := root($div)//mets:file[@ID = $fileid][@USE =
                ($config:RESOURCE_WORKINGCOPY_FILE_USE,$config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE)][ancestor::mets:fileGrp[@ID
                eq $config:PROJECT_DATA_FILEGRP_ID]],&#xd; $uri :=
                $data-file/mets:FLocat/@xlink:href,&#xd; $fileptr := $fileid[. =
                $data-file/@ID]/parent::*&#xd; return&#xd; if (exists($project))&#xd; then &#xd; let
                $files := $project//mets:file[@USE = $config:RESOURCE_WORKINGCOPY_FILE_USE]&#xd;
                return $files/mets:FLocat!concat("doc('",./@xlink:href,"')")&#xd; else &#xd; if
                ($fileptr/self::mets:area)&#xd; then
                "doc('"||$uri||"')//fcs:ResourceFragment[@resourcefragment-pid='"||$fileptr/@BEGIN||"']"&#xd;
                else "doc('"||$uri||"')"&#xd; (: return
                util:eval("("||string-join($paths,',')||")"):)&#xd; return $paths&#xd; };&#xd; &#xd;
                (:~ tries to resolve an id, irrespective if it identifies a project a resource or a
                resourcefragment&#xd; and return the appropriate mets:entry (mets:mets or
                mets:div)&#xd; :)&#xd; &#xd; declare function cr:resolve-id-to-entry ($x-context as
                xs:string) as element()* {&#xd; &#xd; let $contexts:=tokenize($x-context,",")&#xd;
                &#xd; for $c in $contexts&#xd; let $id := normalize-space($c),&#xd; $project :=
                project:get($id), &#xd; $mets := if (exists($project)) then $project&#xd; else
                collection(config:path("projects"))//mets:div[@ID eq $id] &#xd; return $mets&#xd;
                &#xd; };&#xd; &#xd; (:~ delivers the project-config for any id (project, resource,
                resourcefragment) :)&#xd; declare function cr:resolve-id-to-project ($x-context as
                xs:string) as element(mets:mets)* {&#xd; &#xd; let $metss :=
                cr:resolve-id-to-entry($x-context)&#xd; &#xd; for $mets in $metss &#xd; let $project
                := if ($mets instance of element(mets:mets)) then $mets&#xd; else
                root($mets)/mets:mets &#xd; return $project&#xd; };&#xd; &#xd; (:~ delivers the
                project-config for any id (project, resource, resourcefragment) :)&#xd; declare
                function cr:resolve-id-to-project-pid ($x-context as xs:string) as xs:string* {&#xd;
                let $project := cr:resolve-id-to-project($x-context)&#xd; return
                distinct-values($project/xs:string(@OBJID))&#xd; };&#xd; (::)&#xd; (::)&#xd;
                (:declare function cr:resolve-id-to-data ($id as xs:string) as item()* {:)&#xd;
                (::)&#xd; (:let $entry := cr:resolve-id-to-entry($id):)&#xd; (:let $rf-path :=
                config:path('resourcefragments'),:)&#xd; (: $wc-path :=
                config:path('workingcopies'),:)&#xd; (: $rf-coll := collection($rf-path):)&#xd;
                (::)&#xd; (:let $data := switch (true()):)&#xd; (: case ($entry instance of
                element(mets:mets)) return
                collection(project:path($project-pid,"workingcopies")):)&#xd; (: case
                ($entry/xs:string(@TYPE) eq 'resource') return:)&#xd; (: let $project-id :=
                $entry//ancestor::mets:mets/xs:string(@OBJID):)&#xd; (: return
                resource:get-data($id, $project-id, 'workingcopy'):)&#xd; (: case
                ($entry/xs:string(@TYPE) eq 'resourcefragment') return
                $rf-coll//fcs:resourceFragment[ft:query(@resourcefragment-pid, $id)]:)&#xd; (:
                default return ():)&#xd; (: return $data :)&#xd; (:};:)</f>
            <f n="facs.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                facs="http://aac.ac.at/content_repository/facs";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd; import module
                namespace index = "http://aac.ac.at/content_repository/index" at "index.xqm";&#xd;
                import module namespace project="http://aac.ac.at/content_repository/project" at
                "project.xqm";&#xd; import module namespace
                rf="http://aac.ac.at/content_repository/resourcefragment" at
                "resourcefragment.xqm";&#xd; import module namespace
                resource="http://aac.ac.at/content_repository/resource" at "resource.xqm";&#xd;
                import module namespace repo-utils="http://aac.ac.at/content_repository/utils" at
                "repo-utils.xqm";&#xd; import module namespace
                wc="http://aac.ac.at/content_repository/workingcopy" at "wc.xqm";&#xd; declare
                namespace cr="http://aac.ac.at/content_repository";&#xd; declare namespace
                mets="http://www.loc.gov/METS/";&#xd; declare namespace
                xlink="http://www.w3.org/1999/xlink";&#xd; &#xd; (: will be used, if there's not
                param @key = "facs.version" in project.xml :)&#xd; declare variable
                $facs:default-version := "default";&#xd; &#xd; (:~&#xd; : Getter and Setter for
                facsimiles of resources and resource fragments. &#xd; :)&#xd; &#xd; &#xd; (:~&#xd; :
                Generates a facs-file for a single resource fragment, using the default &#xd; :
                version/quality as specified in the facs module config. &#xd; : @param
                $resourcefragment-pid&#xd; : @param $resource-pid&#xd; : @param $project-pid &#xd;
                ~:)&#xd; declare function facs:generate-file($resourcefragment-pid as xs:string,
                $resource-pid as xs:string, $project-pid as xs:string) as element(mets:file)* {&#xd;
                facs:generate-file((),$resourcefragment-pid,$resource-pid,$project-pid)&#xd; };&#xd;
                &#xd; (:~&#xd; : Generates a facs-file for a single resource fragment in a given
                resource&#xd; : @param $resourcefragment-pid&#xd; : @param $resource-pid&#xd; :
                @param $project-pid &#xd; ~:)&#xd; declare function
                facs:generate-file($version-param as xs:string?, $resourcefragment-pid as xs:string,
                $resource-pid as xs:string, $project-pid as xs:string) as element(mets:file)* {&#xd;
                let $file-id :=
                facs:id-by-resourcefragment($resourcefragment-pid,$resource-pid,$project-pid),&#xd;
                $version :=
                ($version-param,config:param-value(project:get($project-pid),'facs.version'),$facs:default-version)[.!=''][1]&#xd;
                let $url := facs:generate-url($file-id, $version,
                $resourcefragment-pid,$resource-pid,$project-pid)&#xd; let $file-elt:=&#xd;
                switch(true())&#xd; case $file-id ="" return
                util:log-app("ERROR",$config:app-name,"No value in index 'facs' for resource
                fragment "||$resourcefragment-pid)&#xd; case $url = "" return ()&#xd; default return
                &#xd; for $f at $pos in $file-id&#xd; return&#xd; &lt;mets:file
                ID="{$resourcefragment-pid}_{$version}{$config:RESOURCE_FACS_SUFFIX}{$pos}"&gt;&#xd;
                &lt;mets:FLocat LOCTYPE="URL" xlink:href="{$url}"/&gt;&#xd; &lt;/mets:file&gt;&#xd;
                return $file-elt&#xd; &#xd; };&#xd; &#xd; (:~&#xd; : Gets the global file group for
                facsmilies of the project.&#xd; : @param $resourcefragment-pid the PID of the
                Resource Fragment&#xd; : @param $resource-pid the PID of the Resource&#xd; : @param
                $project-pid the PID of the Project&#xd; : @return zero or one mets:fileGrp element
                containing one mets:fileGrp element for each resource that has facsimlies.&#xd;
                ~:)&#xd; declare function facs:get-fileGrp($project-pid as xs:string) as
                element(mets:fileGrp)? {&#xd; project:get($project-pid)//mets:fileGrp[@ID eq
                $config:PROJECT_FACS_FILEGRP_ID]&#xd; };&#xd; &#xd; (:~&#xd; : sets facs-files and
                fptrs for a single resource fragment in a given resource&#xd; : @param $mets:file a
                mets:file element, generated by facs:generate-file()&#xd; : @param
                $resourcefragment-pid the PID of the Resource Fragment&#xd; : @param $resource-pid
                the PID of the Resource&#xd; : @param $project-pid the PID of the Project &#xd;
                ~:)&#xd; declare function facs:set($version as xs:string, $mets:file as
                element(mets:file)+, $resourcefragment-pid as xs:string, $resource-pid as xs:string,
                $project-pid as xs:string) as empty() {&#xd; let $file :=
                facs:get-file($version,$resourcefragment-pid, $resource-pid, $project-pid)&#xd; let
                $mets:div := rf:record($resourcefragment-pid, $resource-pid, $project-pid)&#xd; (:
                set the mets:fptr in mets:div :)&#xd; let $set-fptr := &#xd; let $del := if
                (exists($file))&#xd; then update delete $mets:div//mets:fptr[@FILEID =
                $file/@ID]&#xd; else ()&#xd; return &#xd; for $f in $mets:file&#xd; return update
                insert &lt;mets:fptr FILEID="{$f/@ID}"/&gt; into $mets:div&#xd; &#xd; (: set
                mets:file element :) &#xd; let $set-file := &#xd; if (exists($file))&#xd; then&#xd;
                (: a facsimilie of the same quality exists, so we just delete it and insert the new
                one(s) :)&#xd; let $fileGrp := $file/parent::mets:fileGrp[1]&#xd; let $rm-old-files
                := update delete $file&#xd; return update insert $mets:file into $fileGrp&#xd; else
                &#xd; (: we need the resource's main facsimile filegrp, parent of all
                'version'-specific fileGrps :)&#xd; let $fileGrp :=
                root($mets:div)//mets:fileGrp[@ID =
                $config:PROJECT_FACS_FILEGRP_ID]/mets:fileGrp[@ID =
                $resource-pid||$config:RESOURCE_FACS_SUFFIX]&#xd; return &#xd; if
                (exists($fileGrp))&#xd; then &#xd; if (exists($fileGrp/mets:fileGrp[@USE =
                $version]))&#xd; then update insert $mets:file into $fileGrp/mets:fileGrp[@USE =
                $version]&#xd; else update insert &lt;mets:fileGrp
                USE="{$version}"&gt;{$mets:file}&lt;/mets:fileGrp&gt; into $fileGrp &#xd; else&#xd;
                let $new_fileGrp := &#xd; &lt;mets:fileGrp
                ID="{$resource-pid}{$config:RESOURCE_FACS_SUFFIX}"
                USE="{$config:PROJECT_FACS_FILEGRP_USE}"&gt;&#xd; &lt;mets:fileGrp
                USE="{$version}"&gt;{$mets:file}&lt;/mets:fileGrp&gt;&#xd;
                &lt;/mets:fileGrp&gt;&#xd; return &#xd; if
                (exists(facs:get-fileGrp($project-pid)))&#xd; then update insert $new_fileGrp into
                facs:get-fileGrp($project-pid)&#xd; else update insert &lt;mets:fileGrp
                ID="{$config:PROJECT_FACS_FILEGRP_ID}" USE="Visual representations of the project's
                data (Facsimile et. alt.)"&gt;{$new_fileGrp}&lt;/mets:fileGrp&gt; into
                root($mets:div)//mets:fileSec&#xd; &#xd; return ()&#xd; };&#xd; &#xd; &#xd; (:~&#xd;
                : Returns one or more URLs to the facsimile(s) of the given resource fragment &#xd;
                : in the default version/quality as set in the projects configuration. Returns the
                &#xd; : empty sequence, if the resource fragment does not exist.&#xd; ~:)&#xd;
                declare function facs:get-url($resourcefragment-pid as xs:string, $resource-pid as
                xs:string, $project-pid as xs:string) as xs:anyURI* {&#xd;
                facs:get-url((),$resourcefragment-pid,$resource-pid,$project-pid)&#xd; };&#xd; &#xd;
                (:~&#xd; : Returns one or more URLs to the facsimile(s) of the given resource
                fragment&#xd; : in the version / quality specified in the first function parameter.
                &#xd; ~:)&#xd; declare function facs:get-url($version-param as xs:string?,
                $resourcefragment-pid as xs:string, $resource-pid as xs:string, $project-pid as
                xs:string) as xs:anyURI* {&#xd; let $version :=
                ($version-param,config:param-value(project:get($project-pid),'facs.version'),$facs:default-version)[.!=''][1]&#xd;
                let $file := facs:get-file($resourcefragment-pid,$resource-pid,$project-pid),&#xd;
                $global-imgFileGrp := facs:get-fileGrp($project-pid)&#xd; return&#xd; for $f in
                $file&#xd; let $href := $f/mets:FLocat/@xlink:href&#xd; let $admid :=
                $file/ancestor-or-self::*[some $x in ancestor-or-self::*[@ADMID] satisfies $x is
                $global-imgFileGrp]/@ADMID&#xd; let $credentials :=
                root($file)//mets:amdSec[@ID=$admid]/mets:rightsMD/mets:mdWrap/mets:xmlData/credentials&#xd;
                return&#xd; if (exists($credentials))&#xd; then &#xd; let $session:=&#xd;
                (session:set-attribute($href||"-username",$credentials/username),&#xd;
                session:set-attribute($href||"-password",$credentials/password))&#xd; return
                xs:anyURI("proxy.xql?url="||$href)&#xd; else $href&#xd; };&#xd; &#xd; &#xd; (:~&#xd;
                : Gets the mets:file of the facsimile(s) of one resourcefragment &#xd; ~:)&#xd;
                declare function facs:get-file($resourcefragment-pid as xs:string, $resource-pid as
                xs:string, $project-pid as xs:string) as element(mets:file)* {&#xd;
                facs:get-file((),$resourcefragment-pid,$resource-pid,$project-pid)&#xd; };&#xd;
                &#xd; declare function facs:get-file($version-param as xs:string?,
                $resourcefragment-pid as xs:string, $resource-pid as xs:string, $project-pid as
                xs:string) as element(mets:file)* {&#xd; let $version :=
                ($version-param,config:param-value(project:get($project-pid),'facs.version'),$facs:default-version)[.!=''][1]&#xd;
                let $mets:div := rf:record($resourcefragment-pid, $resource-pid, $project-pid),&#xd;
                (: we assume that a fptr to a facs points to the &#xd; file as a whole, not to an
                area :)&#xd; $fids:= $mets:div/mets:fptr/@FILEID&#xd; return
                root($mets:div)//mets:file[@ID = $fids][ancestor-or-self::*/@USE = $version]&#xd;
                };&#xd; &#xd; (: gest all facsimile file elements, regardless of the
                quality/version, of a resource :)&#xd; declare function facs:get-files($resource-pid
                as xs:string, $project-pid as xs:string) as element(mets:file)* {&#xd;
                facs:get-files((),$resource-pid,$project-pid)&#xd; };&#xd; &#xd; declare function
                facs:get-files($version-param as xs:string?, $resource-pid as xs:string,
                $project-pid as xs:string) as element(mets:file)* {&#xd; let $version :=
                ($version-param,config:param-value(project:get($project-pid),'facs.version'),$facs:default-version)[.!=''][1]&#xd;
                let $entry := resource:get($resource-pid,$project-pid),&#xd; $fileids :=
                $entry//mets:fptr/@FILEID&#xd; return root($entry)//mets:file[@ID =
                $fileids][ancestor-or-self::*/@USE = $version]&#xd; };&#xd; &#xd; (:~&#xd; :
                Generates (or replaces) the files and fptrs to a resource's facsimiles in the
                default version/quality.&#xd; : @param $resourcefragment-pid the pid of the
                resourcefragment to get the file-id from&#xd; : @param $resource-pid the pid of the
                resource&#xd; : @param $project-pid the pid of the project&#xd; ~:)&#xd; declare
                function facs:generate($resource-pid as xs:string, $project-pid as xs:string) as
                empty() {&#xd; facs:generate((),$resource-pid,$project-pid)&#xd; };&#xd; &#xd; &#xd;
                (:~&#xd; : Generates (or replaces) the files and fptrs to a resource's facsimiles in
                the version/quality indicated.&#xd; : @param $version the quality of the
                facsimiles&#xd; : @param $resourcefragment-pid the pid of the resourcefragment to
                get the file-id from&#xd; : @param $resource-pid the pid of the resource&#xd; :
                @param $project-pid the pid of the project&#xd; ~:)&#xd; declare function
                facs:generate($version-param as xs:string?, $resource-pid as xs:string, $project-pid
                as xs:string) as empty() {&#xd; let $fragments := resource:get($resource-pid,
                $project-pid)/mets:div[@TYPE=$config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE],&#xd;
                $version :=
                ($version-param,config:param-value(project:get($project-pid),'facs.version'),$facs:default-version)[.!=''][1]&#xd;
                (: we generate the first fragment outside of the for-in expression in order to make
                &#xd; sure it is instantly written to the project.xml :)&#xd; let $log :=
                util:log-app("INFO",$config:app-name,"Generating "||count($fragments)||" facs
                entries for "||$resource-pid||" (project "||$project-pid||")")&#xd; let $first
                :=&#xd; let $resourcefragment-pid := $fragments[1]/@ID&#xd; let $file :=
                facs:generate-file($version,$resourcefragment-pid,$resource-pid,$project-pid)&#xd;
                return facs:set($version,$file,$resourcefragment-pid,$resource-pid,$project-pid)
                &#xd; return &#xd; for $f in $fragments[position() gt 1]&#xd; let
                $resourcefragment-pid := $f/@ID&#xd; let $file :=
                facs:generate-file($version,$resourcefragment-pid,$resource-pid,$project-pid)&#xd;
                return
                facs:set($version,$file,$resourcefragment-pid,$resource-pid,$project-pid)&#xd;
                };&#xd; &#xd; &#xd; &#xd; (:~&#xd; : Gets one or more file-ids (filename(s) of
                facsimile(s) of a given resourcefragment.&#xd; : NB This function is set to private
                as it is only needed once, when the filepaths &#xd; : are written to the mets
                project.&#xd; : @param $resourcefragment-pid the pid of the resourcefragment to get
                the file-id from&#xd; : @param $resource-pid the pid of the resource&#xd; : @param
                $project-pid the pid of the project&#xd; : @result one or more file-ids (filenames)
                &#xd; ~:)&#xd; declare %private function
                facs:id-by-resourcefragment($resourcefragment-pid as xs:string, $resource-pid as
                xs:string, $project-pid as xs:string) as xs:string?{&#xd; let $rf :=
                rf:get($resourcefragment-pid, $resource-pid,$project-pid)&#xd; (: let's get the
                element that the "resourcefragment-pid" index refers to in the full data. &#xd; (in
                the variable $fragment-elt-in-wc). &#xd; This indirection is necessary, as our
                "facs" index does not have to point to &#xd; a descendant of the resourcefragment,
                so that an expression like $rf/preceding::pb &#xd; will easily lead to strange
                results. :) &#xd; let $fragment-pid-in-rf:=
                index:apply-index($rf,"rf",$project-pid)/ancestor-or-self::*[@cr:id][1],&#xd;
                $fragment-in-wc :=
                wc:lookup($fragment-pid-in-rf/xs:string(@cr:id),$resource-pid,$project-pid) &#xd; (:
                ... then apply the "facs" index to the fragment-element in the working copy :)&#xd;
                let $facs:= index:apply-index($fragment-in-wc,"facs",$project-pid)&#xd; return
                $facs/xs:string(.)&#xd; };&#xd; &#xd; &#xd; (:~&#xd; : Generates the URL(s) to a
                facsimile of a resourcefragment, to be &#xd; : stored into a
                mets:file/mets:FLocat/@xlink:href. &#xd; : NB: We can hold more than one version of
                a facsmilie (thumbnail, web, archive etc.).&#xd; : This stores the default version
                specified in the facs modules configuration. &#xd; : To generate a specific version,
                use the four-parameter version of this function.&#xd; : This function is set to
                private as it is only needed once, when the filepaths &#xd; : are written to the
                mets project.&#xd; : @param $file-id the id (or filename) of the facs, e.g. the
                value of pb/@facs &#xd; : @param $resourcefragment-pid the pid of the resource&#xd;
                : @param $resource-pid the pid of the resource &#xd; : @param $project-pid the pid
                of the project&#xd; : @return zero or more URLs (a resourcefragment may be split or
                span over more than one page)&#xd; ~:)&#xd; declare %private function
                facs:generate-url($file-id as xs:string, $resourcefragment-pid as xs:string,
                $resource-pid as xs:string, $project-pid as xs:string) as xs:string* {&#xd;
                facs:generate-url($file-id,(),$resourcefragment-pid, $resource-pid,
                $project-pid)&#xd; };&#xd; &#xd; (:~&#xd; : Generates the URL to a facsimile of a
                resourcefragment, to be &#xd; : stored into a
                mets:file/mets:FLocat/@xlink:href.&#xd; : NB: We can hold more than one version of a
                facsmilie (thumbnail, web, archive etc.).&#xd; : This stores the version indicated
                by parameter number 2.&#xd; : NB This function is set to private as it is only
                needed once, when the filepaths &#xd; : are written to the mets project.&#xd; :
                @param $file-id the id (or filename) of the facs, e.g. the value of pb/@facs&#xd; :
                @param $version the version / qualitiy of the facsimile the URL has to point to.
                &#xd; : @param $resourcefragment-pid the pid of the resource&#xd; : @param
                $resource-pid the pid of the resource &#xd; : @param $project-pid the pid of the
                project&#xd; : @return zero or more URLs (a resourcefragment may be split or span
                over more than one page)&#xd; ~:)&#xd; declare function facs:generate-url($file-id
                as xs:string, $version as xs:string?, $resourcefragment-pid as xs:string,
                $resource-pid as xs:string, $project-pid as xs:string) as xs:string* {&#xd; let
                $config := project:get($project-pid)&#xd; let $facs:pattern:=
                repo-utils:config-value($config,"facs.url-pattern")&#xd; let $config-ok := &#xd;
                switch(true())&#xd; case repo-utils:config-value($config,"facs.url-pattern")=""
                return (util:log-app("ERROR",$config:app-name,"config parameter facs.url-pattern
                missing in project "||$project-pid),false())&#xd; (:case
                repo-utils:config-value($config,"facs.default")="" return
                (util:log-app("ERROR",$config:app-name,"config parameter facs.default missing in
                project "||$project-pid),false()):)&#xd; case
                repo-utils:config-value($config,"facs.base-uri")="" return
                (util:log-app("ERROR",$config:app-name,"config parameter facs.base-uri missing in
                project "||$project-pid),false())&#xd; default return true()&#xd; return&#xd; if
                ($config-ok)&#xd; then &#xd; let $substrings :=
                fn:analyze-string($facs:pattern,"\$([\w+\-\.]+)"),&#xd; $keys:=
                $substrings//fn:group/xs:string(.), &#xd; $maps := &#xd; for $k in $keys &#xd; let
                $val := try {&#xd;
                (util:eval("$"||$k),repo-utils:config-value($config,"facs."||$k))[1]&#xd; } catch *
                {&#xd; repo-utils:config-value($config,"facs."||$k)&#xd; } &#xd; return
                map:entry($k,$val)&#xd; let $params := map:new($maps)&#xd; let $pattern-expanded :=
                facs:generate-url-expandParams($substrings,$params) &#xd; return
                string-join($pattern-expanded,'')&#xd; else
                util:log-app("INFO",$config:app-name,"Can't generate facsimile because of missing
                config parameters.")&#xd; };&#xd; &#xd; (:~&#xd; : Helper function that replaces
                variable names in the url-pattern of the &#xd; : facs module config (param key
                "facs.url-pattern") with their actual values.&#xd; ~:)&#xd; declare %private
                function facs:generate-url-expandParams($node as node(), $params as map()) as
                item()* {&#xd; typeswitch($node)&#xd; case element(fn:analyze-string-result) return
                &#xd; for $n in $node/node() &#xd; return facs:generate-url-expandParams($n,
                $params)&#xd; case element(fn:match) return
                facs:generate-url-expandParams($node/fn:group[1],$params)&#xd; case
                element(fn:group) return map:get($params,xs:string($node))&#xd; case
                element(fn:non-match) return xs:string($node)&#xd; default return $node &#xd; };
                &#xd; &#xd; &#xd; </f>
            <f n="index.xqm">xquery version "3.0";&#xd; &#xd; module namespace index =
                "http://aac.ac.at/content_repository/index";&#xd; import module namespace project =
                "http://aac.ac.at/content_repository/project" at "project.xqm";&#xd; import module
                namespace config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd;
                import module namespace repo-utils = "http://aac.ac.at/content_repository/utils" at
                "repo-utils.xqm";&#xd; declare namespace xconf =
                "http://exist-db.org/collection-config/1.0";&#xd; &#xd; declare variable
                $index:INDEX_TYPE_FT := 'ft';&#xd; &#xd; (:~&#xd; @param $project id of the working
                context project or project-file&#xd; :)&#xd; declare function index:map($project) as
                element(map) {&#xd; project:map($project)&#xd; };&#xd; &#xd; (:~&#xd; @param
                $project id of the working context project or project-file&#xd; :)&#xd; declare
                function index:index($key as xs:string+, $project) as element(index)? {&#xd;
                index:index-from-map($key, index:map($project))&#xd; };&#xd; &#xd; declare function
                index:index-from-map($key as xs:string+, $map) as element(index)? {&#xd;
                $map//index[@key=$key]&#xd; };&#xd; &#xd; (:~ gets the mapping for the index and
                creates an xpath (UNION)&#xd; &#xd; This is a rework of the original
                fcs:index-as-xpath()&#xd; it expects second parameter to be just project-pid (for
                now), contrary to fcs, that &#xd; &#xd; FIXME: takes just first @use-param - this
                prevents from creating invalid xpath, but is very unreliable wrt to the returned
                data&#xd; also tried to make a union but problems with values like:
                'xs:string(@value)' (union operand is not a node sequence [source: String])&#xd;
                &#xd; @param $key index-key as known to mappings &#xd; @param $project id of the
                working context project or project-file&#xd; @param $type 'base' (or empty) returns
                the base xpath (without the @use-attribute); 'match' adds the @match-attribute ;
                'label' adds the @label-attribute if present&#xd; (for separate evaluation relative
                to base path: )&#xd; "match-only" delivers only the value of @match-attribute
                (without base-path), or '.' if no @match attribute is present &#xd; "label-only"
                delivers only the value of @label-attribute (without base-path) or '.' if no @label
                attribute is present&#xd; &#xd; @returns xpath-equivalent of given index as defined
                in mappings; multiple xpaths are translated to a UNION, &#xd; value of
                @use-attribute is also attached; &#xd; if no mapping found, returns the input-index
                unchanged &#xd; :)&#xd; declare function index:index-as-xpath($key as xs:string,
                $project, $type as xs:string?) as xs:string {&#xd;
                index:index-as-xpath-from-map($key, index:map($project), $type)&#xd; };&#xd; &#xd;
                (:~ this expects already the index-map of the project as param, as opposed to the
                project file or id &#xd; - this is meant to skip the resolution of the map&#xd;
                :)&#xd; declare function index:index-as-xpath-from-map($key as xs:string, $map,
                $type as xs:string?) as xs:string { &#xd; let $index := index:index-from-map($key,
                $map) &#xd; return if (exists($index)) then&#xd; (: let $match-on := if
                (exists($index-map/@use) ) then &#xd; if (count($index-map/@use) &gt; 1) then &#xd;
                concat('/(', string-join($index-map/@use,'|'),')')&#xd; else concat('/',
                xs:string($index-map/@use)) &#xd; else '' :)&#xd; (: let $match-on := if
                (exists($index/@use) ) then concat('/', xs:string($index[1]/@use)) else '':)&#xd;
                &#xd; let $paths := switch (true()) &#xd; case ($type='label' and
                $index/path/@label) return &#xd; for $x in $index/path[@label] return
                concat($x,'/',$x/@label)&#xd; case ($type='match' and $index/path/@match) return
                &#xd; for $x in $index/path[@match] return concat($x,'/', $x/@match)&#xd; case
                ($type='label-only' and $index/path/@label) return $index/path[@label]/@label&#xd;
                case ($type='label-only' and not($index/path/@label)) return '.'&#xd; case
                ($type='match-only' and $index/path/@match) return $index/path[@match]/@match&#xd;
                case ($type='match-only' and not($index/path/@match)) return '.'&#xd; &#xd; default
                return $index/path&#xd; (: let $paths := $index/path:)&#xd; let $indexes := if
                (count($paths) &gt; 1) &#xd; (:then translate(concat('(', string-join($paths
                ,'|'),')', $match-on),'.','/')&#xd; else translate(concat($paths,
                $match-on),'.','/'):)&#xd; then '('||string-join($paths ,'|')||')'&#xd; else
                $paths&#xd; return $indexes&#xd; (: unknown index - return the key - except for
                match-only or label-only : return just '.' :) &#xd; else if ($type = ('label-only',
                'match-only')) then '.'&#xd; else translate($key,'.','/')&#xd; &#xd; };&#xd; &#xd;
                (:~&#xd; @param $project id of the working context project or project-file&#xd;
                :)&#xd; declare function index:index-as-xpath($key as xs:string, $project) as
                xs:string {&#xd; index:index-as-xpath($key,$project,() )&#xd; };&#xd; &#xd; &#xd;
                (:~ evaluate given index on given piece of data&#xd; &#xd; mainly used when
                formatting record-data (fcs:format-record-data), to put selected pieces of data
                (indexes) into the results record &#xd; &#xd; This is a rework of (and should
                replace) the original fcs:apply-index()&#xd; &#xd; @param $project id of the working
                context project or project-file&#xd; @returns result of evaluating given index's
                path on given data. or empty node if no mapping index was found&#xd; :)&#xd; declare
                function index:apply-index($data as item(), $index as xs:string, $project) as
                item()* {&#xd; (: let $index-map := index:indexfcs:get-mapping($index,$x-context,
                $config),:)&#xd; let $index-xpath := index:index-as-xpath($index,$project)&#xd;
                &#xd; (: $match-on := if (exists($index-map/@use) ) then concat('/',
                xs:string($index-map[1]/@use)) else ''&#xd; , $match-on:)&#xd; let $define-ns:=&#xd;
                let $index-map:= project:map($project),&#xd; $namespaces:=
                $index-map//namespaces/ns&#xd; return &#xd; for $ns in $namespaces&#xd; let
                $prefix:= $ns/@prefix,&#xd; $namespace-uri:=$ns/@uri&#xd; (: let
                $log:=util:log-app("DEBUG", $config:app-name, "declaring namespace
                "||$prefix||"='"||$namespace-uri||"'"):)&#xd; return
                util:declare-namespace(xs:string($prefix), xs:anyURI($namespace-uri))&#xd;
                return&#xd; if (exists($index-xpath)) &#xd; then &#xd; let
                $plain-eval:=util:eval("$data//"||$index-xpath)&#xd; return &#xd; if
                (exists($plain-eval))&#xd; then $plain-eval&#xd; else
                util:eval("util:expand($data)//"||$index-xpath)&#xd; else util:log-app("ERROR",
                $config:app-name, "Could not generate index-path for index "||$index||" in project
                "||$project) &#xd; };&#xd; &#xd; (:~&#xd; @param $project id of the working context
                project or project-file&#xd; :)&#xd; declare function index:default($project) as
                element(index)? {&#xd; index:map($project)//index[@key='cql.serverChoice']&#xd;
                };&#xd; &#xd; &#xd; declare function index:generate-xconf($project-pid as xs:string)
                as element(xconf:collection) {&#xd; let $mappings := index:map($project-pid),&#xd;
                $xsl := doc("mappings2xconf.xsl"),&#xd; $params :=
                &lt;parameters&gt;&lt;/parameters&gt;,&#xd; $xconf :=
                transform:transform($mappings,$xsl,$params)&#xd; return $xconf&#xd; };&#xd; &#xd;
                declare function index:store-xconf($project-pid as xs:string) {&#xd; let
                $xconf:=index:generate-xconf($project-pid)&#xd; let $paths:=(&#xd;
                project:path($project-pid,'workingcopies')&#xd;
                (:project:path($project-pid,'resourcefragments'),&#xd;
                project:path($project-pid,'metadata'),&#xd;
                project:path($project-pid,'lookuptables'):)&#xd; )&#xd; return&#xd; for $p in
                $paths&#xd; return&#xd; let $config-path := "/db/system/config"||$p&#xd; let $mkPath
                := repo-utils:mkcol("/db/system/config",$p)&#xd; let
                $store:=xmldb:store($config-path,"collection.xconf",$xconf)&#xd; return
                xmldb:reindex($config-path)&#xd; (: return $xconf:)&#xd; };&#xd; &#xd; declare
                function index:facets($index-key as xs:string, $project-pid as xs:string) as
                element(index) {&#xd; let $index := index:index($index-key,$project-pid)&#xd;
                return&#xd; &lt;index key="{$index-key}"&gt;{&#xd; for $f in
                $index/@facet/tokenize(.,'\s')&#xd; return index:facets($f,$project-pid)&#xd;
                }&lt;/index&gt;&#xd; };</f>
            <f n="lookuptable.xqm">xquery version "3.0";&#xd; &#xd; module namespace ltb =
                "http://aac.ac.at/content_repository/lookuptable";&#xd; &#xd; import module
                namespace config="http://exist-db.org/xquery/apps/config" at "config.xqm"; &#xd;
                import module namespace resource="http://aac.ac.at/content_repository/resource" at
                "resource.xqm";&#xd; import module namespace
                project="http://aac.ac.at/content_repository/project" at "project.xqm";&#xd; import
                module namespace rf="http://aac.ac.at/content_repository/resourcefragment" at
                "resourcefragment.xqm";&#xd; import module namespace
                repo-utils="http://aac.ac.at/content_repository/utils" at "repo-utils.xqm";&#xd;
                &#xd; declare namespace mets="http://www.loc.gov/METS/";&#xd; declare namespace
                xlink="http://www.w3.org/1999/xlink";&#xd; declare namespace
                cr="http://aac.ac.at/content_repository";&#xd; declare namespace
                fcs="http://clarin.eu/fcs/1.0";&#xd; (:~&#xd; : Getter / setter / storage functions
                for lookuptables.&#xd; ~:)&#xd; &#xd; declare variable $ltb:default-path :=
                $config:default-lookuptable-path;&#xd; declare variable $ltb:filename-prefix :=
                $config:RESOURCE_LOOKUPTABLE_FILENAME_PREFIX; &#xd; &#xd; &#xd; (:~ Creates a lookup
                table from resourcefragments. &#xd; : &#xd; : @param $resource-pid the pid of the
                resource &#xd; : @param $project-pid the id of the project to work in&#xd; : @return
                the path to the lookup table&#xd; ~:)&#xd; declare function
                ltb:generate($resource-pid as xs:string,$project-pid as xs:string) as xs:string?
                {&#xd; let $rf:data:= &#xd; let $rf:dump := rf:dump($resource-pid,
                $project-pid)&#xd; return&#xd; if (exists($rf:dump))&#xd; then $rf:dump&#xd; else
                &#xd; let $rf:path:= rf:generate($resource-pid,$project-pid)&#xd; return
                doc($rf:path)&#xd; let $base-uri := base-uri($rf:data)&#xd; let $rf:filename :=
                tokenize($base-uri,'/')[last()],&#xd; $rf:collection :=
                substring-before($base-uri,'/'||$rf:filename)&#xd; let $ltb:current-filepath :=
                resource:path($resource-pid,$project-pid,"lookuptable")&#xd; let $ltb:filename:= if
                ($ltb:current-filepath != '')&#xd; then
                tokenize($ltb:current-filepath,'/')[last()]&#xd; else
                $ltb:filename-prefix||$resource-pid||".xml"&#xd; let $ltb:path:= &#xd; if
                ($ltb:current-filepath != '')&#xd; then
                substring-before($ltb:current-filepath,"/"||$ltb:filename)&#xd; else
                project:path($project-pid,"lookuptables")&#xd; &#xd; let $ltb:container :=&#xd;
                element
                {QName($config:RESOURCE_LOOKUPTABLE_ELEMENT_NSURI,$config:RESOURCE_LOOKUPTABLE_ELEMENT_NAME)}
                {&#xd; attribute project-pid {$project-pid},&#xd; attribute resource-pid
                {$resource-pid},&#xd; attribute created {current-dateTime()},&#xd; attribute origin
                {base-uri($rf:data)},&#xd; attribute originmodified
                {xmldb:last-modified($rf:collection,$rf:filename)},&#xd; for $fragment in
                $rf:data//*[local-name(.) eq $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME and
                namespace-uri(.) eq $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NSURI]&#xd;
                return&#xd; element
                {QName($config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NSURI,$config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME)}
                {&#xd; attribute project-pid {$project-pid},&#xd; attribute resource-pid
                {$resource-pid},&#xd; attribute resourcefragment-pid
                {$fragment/@resourcefragment-pid},&#xd; for $part-id in $fragment//@cr:id return
                &lt;cr:id&gt;{xs:string($part-id)}&lt;/cr:id&gt;&#xd; }&#xd; }&#xd; let $ltb:store
                :=
                repo-utils:store($ltb:path,$ltb:filename,$ltb:container,true(),config:config($project-pid))&#xd;
                &#xd; let
                $ltb-fileid:=$resource-pid||$config:RESOURCE_LOOKUPTABLE_FILEID_SUFFIX,&#xd;
                $ltb-file:=resource:make-file($ltb-fileid,$ltb:path||'/'||$ltb:filename,"lookuptable"),&#xd;
                $store-file:= resource:add-file($ltb-file,$resource-pid,$project-pid)&#xd; return
                base-uri($ltb:store)&#xd; };&#xd; &#xd; (:~&#xd; : &#xd; : @param $resource-pid the
                pid of the resource &#xd; : @param $project-pid the id of the project to work
                in&#xd; : @return the path to the working copy&#xd; ~:)&#xd; declare function
                ltb:add($resource-pid as xs:string, $project-pid as xs:string) as xs:string? {&#xd;
                ()&#xd; };&#xd; &#xd; (:~&#xd; : gets the mets:file entry for the lookuptable.&#xd;
                : &#xd; : @param $resource-pid the pid of the resource &#xd; : @param $project-pid
                the id of the project to work in&#xd; : @return the mets:file entry for the
                lookuptable.&#xd; ~:)&#xd; declare function ltb:get(){&#xd; ()&#xd; };&#xd; &#xd;
                (:~ Finds the rfs containing an element with given @cr:id&#xd; &#xd; : @param
                $element-id the id of a xml-element expected inside some resourcefragment&#xd; :
                @param $resource-pid the pid of the resource &#xd; : @param $project-pid the pid of
                the project&#xd; @return resourcefragment of the containing resourcefragment &#xd;
                :)&#xd; declare function ltb:lookup($element-id as xs:string, $resource-pid as
                xs:string, $project-pid as xs:string) as xs:string* {&#xd; (: rf:dump($resource-pid,
                $project-pid)/id($element-id)/ancestor::fcs:resourceFragment :)&#xd;
                ltb:dump($resource-pid, $project-pid)//fcs:resourceFragment[cr:id eq
                $element-id]/xs:string(@resourcefragment-pid) &#xd; };&#xd; &#xd; &#xd; (:~&#xd; :
                gets the data for the lookuptable as a document-node()&#xd; : &#xd; : @param
                $resource-pid the pid of the resource &#xd; : @param $project-pid the id of the
                project to work in&#xd; : @return the mets:file entry for the lookuptable.&#xd;
                ~:)&#xd; declare function ltb:dump($resource-pid as xs:string, $project-pid as
                xs:string) as document-node()? {&#xd; let $ltb:location:=
                resource:path($resource-pid, $project-pid, "lookuptable" ),&#xd; $ltb:doc := if
                (doc-available($ltb:location)) then doc($ltb:location) else util:log("INFO","Could
                not locate lookuptable from "||$ltb:location) &#xd; return $ltb:doc&#xd; };&#xd;
                &#xd; &#xd; &#xd; (:~&#xd; : gets the data for the lookuptable as a
                document-node()&#xd; : &#xd; : @param $resource-pid the pid of the resource &#xd; :
                @param $project-pid the id of the project to work in&#xd; : @return the mets:file
                entry for the lookuptable.&#xd; ~:)&#xd; declare function ltb:dump($resource-pid as
                xs:string, $project-pid as xs:string) as document-node()? {&#xd; let $ltb:location:=
                resource:path($resource-pid, $project-pid, "lookuptable" ),&#xd; $ltb:doc := if
                (doc-available($ltb:location)) then doc($ltb:location) else util:log("INFO","Could
                not locate lookuptable from "||$ltb:location) &#xd; return $ltb:doc&#xd; };&#xd;
                &#xd; &#xd; (:~&#xd; : gets the data for the lookuptable as a document-node()&#xd; :
                &#xd; : @param $resource-pid the pid of the resource &#xd; : @param $project-pid the
                id of the project to work in&#xd; : @return the mets:file entry for the
                lookuptable.&#xd; ~:)&#xd; declare function ltb:dump($resourcefragment-pid as
                xs:string, $resource-pid as xs:string, $project-pid as xs:string) {&#xd; let
                $ltb:location:= resource:path($resource-pid, $project-pid, "lookuptable"),&#xd;
                $ltb:doc := if (doc-available($ltb:location)) then doc($ltb:location) else
                util:log("INFO","Could not locate lookuptable from "||$ltb:location) &#xd;
                return&#xd; (:
                "$ltb:doc//fcs:"||$config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME||"[@cr:"||$config:RESOURCEFRAGMENT_PID_NAME||"='"||$resourcefragment-pid||"']":)&#xd;
                util:eval(&#xd;
                "$ltb:doc//fcs:"||$config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME||"[@"||$config:RESOURCEFRAGMENT_PID_NAME||"='"||$resourcefragment-pid||"']"&#xd;
                )&#xd; };&#xd; &#xd; (:~&#xd; : OBSOLETED by resource:path() ??&#xd; &#xd; : gets
                the database-path to the lookuptable &#xd; : &#xd; : @param $resource-pid the pid of
                the resource &#xd; : @param $project-pid the id of the project to work in&#xd; :
                @return the mets:file entry for the lookuptable.&#xd; ~:)&#xd; declare function
                ltb:path($resource-pid as xs:string, $project-pid as xs:string) as xs:string? {&#xd;
                let $rf:fileGrp:=resource:files($resource-pid, $project-pid)&#xd; return
                $rf:fileGrp/mets:file[@USE eq
                $config:RESOURCE_LOOKUPTABLE_FILE_USE]/mets:FLocat/@xlink:href&#xd; };&#xd; &#xd;
                &#xd; (:~&#xd; : removes the lookuptable.&#xd; : &#xd; : @param $resource-pid the
                pid of the resource &#xd; : @param $project-pid the id of the project to work
                in&#xd; : @return empty()&#xd; ~:)&#xd; declare function ltb:remove(){&#xd; ()&#xd;
                };&#xd; &#xd; (:~&#xd; : removes the lookuptable.&#xd; : &#xd; : @param
                $resource-pid the pid of the resource &#xd; : @param $project-pid the id of the
                project to work in&#xd; : @return the path to the working copy&#xd; ~:)&#xd; declare
                function ltb:remove(){&#xd; ()&#xd; };&#xd; &#xd; (:~&#xd; : removes the data of a
                lookuptable.&#xd; : &#xd; : @param $resource-pid the pid of the resource &#xd; :
                @param $project-pid the id of the project to work in&#xd; : @return the path to the
                working copy&#xd; ~:)&#xd; declare function ltb:remove-data(){&#xd; ()&#xd; };</f>
            <f n="master.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                master="http://aac.ac.at/content_repository/master";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm"; &#xd; import module
                namespace resource="http://aac.ac.at/content_repository/resource" at
                "resource.xqm";&#xd; import module namespace
                repo-utils="http://aac.ac.at/content_repository/utils" at "repo-utils.xqm";&#xd;
                &#xd; &#xd; (: declaration of helper namespaces for better code structuring :)&#xd;
                declare namespace param="userinput.parameters";&#xd; declare namespace
                this="current.object";&#xd; &#xd; declare namespace
                mets="http://www.loc.gov/METS/";&#xd; declare namespace
                xlink="http://www.w3.org/1999/xlink";&#xd; declare namespace fcs =
                "http://clarin.eu/fcs/1.0";&#xd; declare namespace
                cr="http://aac.ac.at/content_repository";&#xd; &#xd; &#xd; (:~&#xd; : @return the
                mets:file-Element of the Master File.&#xd; ~:)&#xd; declare function
                master:get($resource-pid as xs:string, $project-pid as xs:string) as
                element(mets:file)? {&#xd; let $mets:record:=config:config($project-pid),&#xd;
                $mets:resource:=resource:get($resource-pid,$project-pid),&#xd;
                $mets:resource-files:=resource:files($resource-pid,$project-pid)&#xd; let
                $mets:master:=$mets:resource-files/mets:file[@USE eq
                $config:RESOURCE_MASTER_FILE_USE]&#xd; return $mets:master&#xd; };&#xd; &#xd;
                (:~&#xd; : The path to a resource's master file. This is based upon the resource's
                mets entry, so &#xd; : the master must be already registered with it. &#xd; :&#xd; :
                @param $resource-pid: the pid of the resource to store&#xd; : @param $project-id:
                the id of the project the resource belongs to&#xd; : @return the db path to the
                file&#xd; ~:)&#xd; declare function master:path($resource-pid as xs:string,
                $project-pid as xs:string) as xs:string? {&#xd; let
                $master:=master:get($resource-pid,$project-pid),&#xd;
                $master:locat:=$master/mets:FLocat/@xlink:href&#xd; return&#xd; if ($master)&#xd;
                then xs:string($master:locat)&#xd; else ()&#xd; };&#xd; &#xd; (:~&#xd; : Gets a
                master file for a resource as a document-node and stores it to the project's data
                directory. It does *not* register it with the resource.&#xd; : &#xd; : @param
                $content: the content of the resource &#xd; : @param $filename: the filename of the
                resource to store.&#xd; : @param $resource-pid: the pid of the resource to
                store&#xd; : @param $project-id: the id of the project the resource belongs to&#xd;
                : @return the db path to the file&#xd; ~:)&#xd; declare function master:store($data
                as document-node(), $resource-pid as xs:string?, $project-pid as xs:string) as
                xs:string? {&#xd; let $this:filename := $resource-pid||".xml"&#xd; let
                $master:targetpath:= resource:path($resource-pid,$project-pid,'master')&#xd; let
                $store:=
                repo-utils:store-in-cache($this:filename,$master:targetpath,$data,config:config($project-pid)),
                &#xd; $this:filepath:=$master:targetpath||"/"||$this:filename&#xd; return &#xd; if
                (doc-available($this:filepath))&#xd; then $this:filepath&#xd; else util:log("INFO",
                "master doc of resource "||$resource-pid||" could not be stored at
                "||$master:targetpath)&#xd; };&#xd; &#xd; (:~&#xd; : Registers a master document
                with the resource by appending a mets:file element to&#xd; : the resources
                mets:fileGrp.&#xd; : If there is already a master registered with this resource, it
                will be replaced.&#xd; : Note that this function does not touch the actual data.
                &#xd; : Storage is handled by master:store().&#xd; : &#xd; : @param $param:path the
                path to the stored working copy&#xd; : @param $param:resource-pid the pid of the
                resource&#xd; : @param $param:project-id: the id of the current project&#xd; :
                @return the added mets:file element &#xd; ~:)&#xd; declare function
                master:add($param:master-filepath as xs:string, $param:resource-pid as
                xs:string,$param:project-id as xs:string) as element(mets:file)? {&#xd; let
                $master:fileid:=$param:resource-pid||$config:RESOURCE_MASTER_FILEID_SUFFIX&#xd; let
                $master:file:=resource:make-file($master:fileid,$param:master-filepath,"master")&#xd;
                let
                $store-file:=resource:add-file($master:file,$param:resource-pid,$param:project-id)&#xd;
                return $store-file&#xd; };</f>
            <f n="prep-data.xql">xquery version "3.0";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd; import module
                namespace fcs = "http://clarin.eu/fcs/1.0" at "../modules/fcs/fcs.xqm";&#xd; import
                module namespace repo-utils = "http://aac.ac.at/content_repository/utils" at
                "repo-utils.xqm";&#xd; import module namespace resource =
                "http://aac.ac.at/content_repository/resource" at "resource.xqm";&#xd; import module
                namespace resourcefragment = "http://aac.ac.at/content_repository/resourcefragment"
                at "resourcefragment.xqm";&#xd; &#xd; declare namespace
                cr="http://aac.ac.at/content_repository";&#xd; &#xd; declare variable
                $local:resourcefragment-pid-name:="resourcefragment-pid";&#xd; &#xd; let
                $flags:=tokenize(request:get-parameter("flags",""),',')&#xd; let
                $path:=request:get-parameter("path","")&#xd; let
                $project:=request:get-parameter("project",""),&#xd;
                $resource-pid:=resource:new($path, $project),&#xd;
                $config:=config:config($project)&#xd; let
                $resource-fragment-index:=config:config($project)//index[@key=$local:resourcefragment-pid-name],&#xd;
                $resource-fragment-path:="("||string-join($resource-fragment-index/path,'|')||")",&#xd;
                $resource-fragment-use:="("||string-join($resource-fragment-index/@use,'|')||")"&#xd;
                &#xd; let $doc := doc($path),&#xd; $filename := tokenize($path,'/')[last()],&#xd;
                $collection := replace($path,$filename,'')&#xd; &#xd; (:let
                $wc-path:=replace($config//param[@key='working-copies.path']/xs:string(.),'/$',''),&#xd;
                $wc-filename := "wc-"||$filename&#xd; &#xd; &#xd; let $working-copy:=&#xd;
                switch(true())&#xd; case $wc-path eq '' &#xd; return util:log("INFO","$wc-path
                empty!")&#xd; case ($flags='keepwc' and
                doc-available($wc-path||"/"||$wc-filename))&#xd; return
                doc($wc-path||"/"||$wc-filename)&#xd; default &#xd; return &#xd; let
                $xsl-path:="/db/apps/cr-xq-dev0913/core/add-cr-ids.xsl",&#xd; $xsl-params:=&#xd;
                &lt;parameters&gt;&#xd; &lt;param name="resource-pid"
                value="{$resource-pid}"/&gt;&#xd; &lt;param name="project-id"
                value="{$project}"/&gt;&#xd; &lt;/parameters&gt;,&#xd;
                $doc-ids-added:=transform:transform($doc,doc($xsl-path),$xsl-params),&#xd; $store-wc
                := repo-utils:store-in-cache($wc-filename,$wc-path,$doc-ids-added,$config)&#xd; let
                $update-mets:= if ($store-wc) then
                resource:add-workingcopy($wc-path||"/"||$wc-filename,$resource-pid,$project) else
                ()&#xd; return $store-wc :)&#xd; &#xd; return&#xd; switch (true())&#xd; case
                not(doc-available($path)) return &lt;error&gt;document at {$path} not
                available.&lt;/error&gt;&#xd; case not(exists($working-copy)) return
                &lt;error&gt;could not store {$wc-path||"/"||$wc-filename}.&lt;/error&gt;&#xd; case
                empty($working-copy) return &lt;error&gt;working copy was not
                generated.&lt;/error&gt;&#xd; default return&#xd; let $define-ns:=&#xd; let
                $mappings:=config:mappings($config),&#xd; $namespaces:=$mappings//namespaces&#xd;
                return &#xd; for $ns in $namespaces/ns&#xd; let $prefix:=$ns/@prefix,&#xd;
                $namespace-uri:=$ns/@uri&#xd; let $log:=util:log("INFO", "declaring namespace
                "||$prefix||"='"||$namespace-uri||"'")&#xd; return
                util:declare-namespace(xs:string($prefix), xs:anyURI($namespace-uri))&#xd; let
                $all-fragments:=util:eval("$working-copy//"||$resource-fragment-path)&#xd; let
                $fragment-element-has-content:=some $x in $all-fragments satisfies exists($x/*)&#xd;
                let $fragments-extracted:=&#xd; for $pb1 at $pos in $all-fragments &#xd; let
                $id:=$resource-pid||"_frag"||format-number($pos, '00000000')&#xd; let
                $fragment:=&#xd; if ($fragment-element-has-content)&#xd; then $pb1&#xd; else &#xd;
                let $pb2:=util:eval("(for $x in $all-fragments where $x &gt;&gt; $pb1 return
                $x)[1]")&#xd; return util:parse(util:get-fragment-between($pb1, $pb2, true(),
                true()))&#xd; let $log:=util:log("INFO","processing resourcefragment w/
                pid="||xs:string($id))&#xd; return&#xd; &lt;fcs:ResourceFragment
                context="{$project}" resource-pid="{$resource-pid}"
                resourcefragment-pid="{$id}"&gt;{$fragment}&lt;/fcs:ResourceFragment&gt;&#xd; let
                $table-path:=replace($config//param[@key='lookup-tables.path'],'/$',''),&#xd;
                $table-filename:="lt-"||$filename,&#xd; $table-doc:=&#xd; &lt;fcs:lookup-table
                context="{$project}" pid="{$resource-pid}" created="{current-dateTime()}"
                filepath="{$path}"
                filemodified="{xmldb:last-modified($collection,$filename)}"&gt;{&#xd; for $fragment
                in $fragments-extracted&#xd; return &#xd; &lt;fcs:ResourceFragment
                context="{$project}" resource-pid="{$resource-pid}"
                resourcefragment-pid="{$fragment/@resourcefragment-pid}"&gt;{&#xd; for $cr:id in
                $fragment//@cr:id &#xd; return &lt;cr:id&gt;{$cr:id}&lt;/cr:id&gt;&#xd;
                }&lt;/fcs:ResourceFragment&gt;&#xd; }&lt;/fcs:lookup-table&gt;,&#xd;
                $store-table:=repo-utils:store-in-cache($table-filename,$table-path,$table-doc,$config)&#xd;
                &#xd; let $fragments-path
                :=replace($config//param[@key='resourcefragments.path'],'/$',''),&#xd;
                $fragments-filename:="frg-"||$filename,&#xd; $fragments-doc:=&lt;fcs:Resource
                context="{$project}" pid="{$resource-pid}" created="{current-dateTime()}"
                filepath="{$path}"
                filemodified="{xmldb:last-modified($collection,$filename)}"&gt;{$fragments-extracted}&lt;/fcs:Resource&gt;&#xd;
                let
                $store-fragments:=repo-utils:store-in-cache($fragments-filename,$fragments-path,$fragments-doc,$config)&#xd;
                (: add extracted fragments to mets fileGrp + structMap :)&#xd; let
                $update-mets:=resourcefragment:new($resource-pid,$fragments-path||"/"||$fragments-filename,$project)
                &#xd; return &#xd; &lt;result&gt;{&#xd; if ($store-table)&#xd; then
                &lt;success&gt;stored {$table-path||"/"||$table-filename}&lt;/success&gt;&#xd; else
                &lt;error&gt;could not store {$table-path||"/"||$table-filename}&lt;/error&gt;,&#xd;
                &#xd; if ($store-fragments)&#xd; then &lt;success&gt;stored
                {$fragments-path||"/"||$fragments-filename}&lt;/success&gt;&#xd; else
                &lt;error&gt;could not store
                {$fragments-path||"/"||$fragments-filename}&lt;/error&gt;&#xd; }&lt;/result&gt;&#xd; </f>
            <f n="prepdata.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                prep="http://aac.ac.at/content_repository/preparedata";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm"; &#xd; import module
                namespace resource="http://aac.ac.at/content_repository/resource" at
                "resource.xqm";&#xd; import module namespace
                resource="http://aac.ac.at/content_repository/workingcopy" at
                "workingcopy.xqm";&#xd; &#xd; (:~&#xd; : Data preparation functions. &#xd; ~:)&#xd; </f>
            <f n="project.xqm">xquery version "3.0"; (:~ : This module provides functions for
                managing cr-xq objects (so called 'projects'), including: : &lt;ul&gt; :
                &lt;li&gt;creation, modification, deletion&lt;/li&gt; : &lt;li&gt;import, export and
                exchange&lt;/li&gt; : &lt;li&gt;validation and sanity checking&lt;/li&gt; :
                &lt;/ul&gt; : : It relies on the cr-project data definion version 1.0, as expressed
                : in the mets profile at
                http://www.github.com/vronk/SADE/docs/crProject-profile.xml. : The profile also
                contains a sample instance which my be used for testing purposes. : : It is designed
                to be used with a version of the cr-xq content : repository from September 2013 or
                later. : : @author Daniel Schopper : @version 0.1 : @see
                http://www.github.com/vronk/SADE/docs/crProject-readme.md ~:) module namespace
                project = "http://aac.ac.at/content_repository/project"; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm"; import module
                namespace repo-utils="http://aac.ac.at/content_repository/utils" at
                "repo-utils.xqm"; import module namespace
                resource="http://aac.ac.at/content_repository/resource" at "resource.xqm"; import
                module namespace index="http://aac.ac.at/content_repository/index" at "index.xqm";
                import module namespace handle = "http://aac.ac.at/content_repository/handle" at
                "../modules/resource/handle.xqm"; declare namespace mets =
                "http://www.loc.gov/METS/"; declare namespace mods="http://www.loc.gov/mods/v3";
                declare namespace metsrights = "http://cosimo.stanford.edu/sdr/metsrights/"; declare
                namespace sm="http://exist-db.org/xquery/securitymanager"; declare namespace
                cmd="http://www.clarin.eu/cmd/"; declare namespace
                xlink="http://www.w3.org/1999/xlink"; declare namespace
                xi="http://www.w3.org/2001/XInclude"; declare namespace fcs =
                "http://clarin.eu/fcs/1.0"; declare namespace sru = "http://www.loc.gov/zing/srw/";
                declare namespace rest="http://exquery.org/ns/restxq"; declare namespace
                output="http://www.w3.org/2010/xslt-xquery-serialization"; declare namespace
                oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/"; (: declaration of helper
                namespaces for better code structuring :) declare namespace
                param="userinput.parameters"; declare namespace this="current.object"; declare
                variable $project:default-template as element(mets:mets) := if
                (doc-available(config:path('mets.template'))) then
                doc(config:path('mets.template'))/mets:mets else
                doc($config:app-root||"/_project.xml")/mets:mets; declare variable
                $project:cmdi-template as element(cmd:CMD) := if
                (doc-available(config:path('cmd.template'))) then
                doc(config:path('cmd.template'))/cmd:CMD else
                doc($config:app-root||"/_cmd.xml")/cmd:CMD; (:~ : generated the id for a new project
                ~:) declare %private function project:generate-id() as xs:string {
                'o'||translate(util:uuid(),' :','_') }; declare %private function
                project:sanitize-id($project-pid as xs:string) as xs:string { let
                $replace:=translate($project-pid,' :','_') return xs:string( if
                (not(matches($replace,'\p{L}'))) then 'o'||$replace else $replace ) }; (:~ : sets up
                two accounts plus personal groups: one with the name of the project, : a read-only
                account for public access, and one admin account with full rights : to all project
                resources. : The initial passwords are set to the project-id. These are to be :
                changed at the first login. : Returns true if the creation was successful, otherwise
                the empty sequence ~:) declare %private function
                project:create-accounts($project-pid as xs:string) as xs:boolean? { let
                $usernames:=(project:usersaccountname($project-pid),project:adminsaccountname($project-pid))
                let $new:= for $username in $usernames return let $password:=$project-pid,
                $groups:=() return if (sm:user-exists($username)) then
                (sm:passwd($username,$password),true()) else
                (sm:create-account($username,$password,$groups),sm:user-exists($username)) return ()
                }; (:~ : deletes the two project accounts. Returns true if the deletion was
                successful. ~:) declare %private function project:remove-accounts($project-pid as
                xs:string) as empty(){ let
                $usernames:=(project:usersaccountname($project-pid),project:adminsaccountname($project-pid))
                return for $username in $usernames return if (sm:user-exists($username)) then let
                $rm-group := sm:remove-group($username), $rm-account:= sm:remove-account($username)
                return () else util:log("INFO", "user "||$username||" does not exist.") }; (:~ :
                Instantiates a new project. : : @return mets:mets ~:) declare function project:new()
                { let $defaultTpl:= $project:default-template return project:new($defaultTpl,()) };
                declare function project:new($project-pid as xs:string) { let
                $defaultTpl:=$project:default-template return project:new($defaultTpl,$project-pid)
                }; (:~ : Instanciates a new project, based on a given template at $template, and
                stores it in the database. : : @param $mets:template the template to create the
                mets-file from : @param $project-pid the name of the project (one Token), if empty
                id will be generated by project:generate-id() : @return the new entry, or, if the
                project with $project-pid already existed, the empty sequence. ~:) declare function
                project:new($data as element(mets:mets),$project-pid as xs:string?) as
                element(mets:mets)? { if (project:get($project-pid)) then
                util:log-app("INFO",$config:app-name,"Project "||$project-pid||" already exists.")
                else let $this:id:= (project:sanitize-id($project-pid),project:generate-id())[1] let
                $this:project:= let $xsl:= doc($config:app-root||'/core/'||'initProject.xsl') let
                $sw_name := $config:app-name-abbreviation||" ("||$config:app-name-full||")" let
                $sw_note := "instance at "||$config:app-root||"; version "||$config:app-version let
                $xslParams:= &lt;parameters&gt; &lt;param name="OBJID" value="{$this:id}"/&gt;
                &lt;param name="CREATEDATE" value="{current-dateTime()}"/&gt; &lt;param
                name="RECORDSTATUS" value="{$config:PROJECT_STATUS_REVISION}"/&gt; &lt;param
                name="CREATOR.SOFTWARE.NOTE" value="{$sw_note}"/&gt; &lt;param
                name="CREATOR.SOFTWARE.NAME" value="{$sw_name}"/&gt; &lt;param
                name="CREATOR.INDIVIDUAL.NAME" value="{xmldb:get-current-user()}"/&gt;
                &lt;/parameters&gt; let $seed-template := transform:transform($data,$xsl,$xslParams)
                return $seed-template let $project-stored as xs:string? :=
                project:store($this:id,$this:project) return if ($project-stored!='') then let
                $project-collection:= project:collection($this:id) let $setup-accounts:=
                project:create-accounts($this:id) let $users-groupname :=
                project:usersaccountname($this:id) let $admin-groupname :=
                project:adminsaccountname($this:id) let $cmdi-path :=
                project:path($this:id,"metadata")||"/CMDI/" let $cmdi := let $xsl:=
                doc($config:app-root||'/core/'||'initCMDI.xsl'), $xs_params := &lt;parameters&gt;
                &lt;param name="project-pid" value="{$this:id}"/&gt; &lt;param name="MdCreationDate"
                value="{fn:format-date(current-date(),'[Y0000]-[M00]-[D00]')}"/&gt; &lt;param
                name="MdCreator" value="{xmldb:get-current-user()}"/&gt; &lt;param
                name="MdCollectionDisplayName"
                value="{config:param-value($this:project,"public-repo-displayname")}"/&gt; &lt;param
                name="project-LandingPage"
                value="{config:param-value($this:project,"public-project-baseurl")}"/&gt; &lt;param
                name="project-Website"
                value="{config:param-value($this:project,"public-project-baseurl")}"/&gt;
                &lt;/parameters&gt; let $cmdi-seed :=
                transform:transform($project:cmdi-template,$xsl,$xs_params) return
                project:dmd($this:id,$cmdi-seed) let $set-permissions:= ((: set permissions on
                project.xml document :) sm:chown(xs:anyURI($project-stored),$admin-groupname),
                sm:chgrp(xs:anyURI($project-stored),$admin-groupname),
                sm:chmod(xs:anyURI($project-stored),'rwxrwxr-x'),
                sm:add-user-ace(xs:anyURI($project-stored), $users-groupname, true(), 'r-x'),
                sm:add-group-ace(xs:anyURI($project-stored), $users-groupname, true(), 'r-x'),
                sm:add-user-ace(xs:anyURI($project-stored), $config:cr-writer-accountname, true(),
                'rwx'), if (sm:user-exists("cr-xq")) then
                sm:add-user-ace(xs:anyURI($project-stored), "cr-xq", true(), 'rwx') else (), (: set
                permissions on {$cr-projects}/project collection :)
                sm:chown(xs:anyURI($project-collection),$admin-groupname),
                sm:chgrp(xs:anyURI($project-collection),$admin-groupname),
                sm:chmod(xs:anyURI($project-collection),'rwxrwxr-x'),
                sm:add-user-ace($project-collection, $users-groupname, true(), 'r-x'),
                sm:add-group-ace($project-collection, $users-groupname, true(), 'r-x'),
                sm:add-user-ace($project-collection, $config:cr-writer-accountname, true(), 'rwx'),
                if (sm:user-exists("cr-xq")) then sm:add-user-ace($project-collection, "cr-xq",
                true(), 'rwx') else (), (: set permissions on CMDI record and collection :)
                sm:chown(xs:anyURI($cmdi-path||$this:id||".xml"),$admin-groupname),
                sm:chgrp(xs:anyURI($cmdi-path||$this:id||".xml"),$admin-groupname),
                sm:chmod(xs:anyURI($cmdi-path||$this:id||".xml"),'rwxrwxr-x'),
                sm:chown(xs:anyURI($cmdi-path),$admin-groupname),
                sm:chgrp(xs:anyURI($cmdi-path),$admin-groupname),
                sm:chmod(xs:anyURI($cmdi-path),'rwxrwxr-x'), sm:add-user-ace($cmdi-path,
                $users-groupname, true(), 'r-x'), sm:add-group-ace($cmdi-path, $users-groupname,
                true(), 'r-x'), sm:add-user-ace($cmdi-path, $config:cr-writer-accountname, true(),
                'rwx'), if (sm:user-exists("cr-xq")) then sm:add-user-ace($cmdi-path, "cr-xq",
                true(), 'rwx') else () ) let $prepare-structure:=
                project:structure($this:id,"prepare") let $content-acl :=
                project:acl($this:id,project:default-acl($this:id)) return project:get($this:id)
                else util:log-app("INFO",$config:app-name, "Project "||$this:id||" could not be
                instantiated.") }; declare function project:label($project-pid as xs:string) as
                xs:string? { let $doc := project:get($project-pid)
                return$doc/@LABEL[.!='']/xs:string(.) }; declare function project:label($data as
                xs:string, $project-pid as xs:string) as empty() { let $current :=
                project:get($project-pid)/@LABEL let $update := update value $current with $data
                return () }; declare function project:available($project-pid as xs:string) as
                xs:boolean { project:status($project-pid) = $config:PROJECT_STATUS_AVAILABLE }; (:~
                : Getter function for projects: Every cr_xq project must have a repository-wide
                unique PID of type xs:string, : which is stored in mets:mets/@OBJID. : The lookup is
                performed first in the path configured as config:path("projects"), : if this lookup
                returns nothing, the lookup context is extended to the database root. : : @param
                $project the PID of the project to look up (or the already looked-up project :
                @return zero or one cr_xq object. ~:) declare function project:get($project) as
                element(mets:mets)? { if ($project instance of element(mets:mets)) then $project
                else let $project_ := collection(config:path("projects"))//mets:mets[@OBJID eq
                $project] return if (count($project) gt 1) then let
                $log:=(util:log-app("WARN",$config:app-name, "project-id corruption: found more than
                1 project with id "||$project||"."),for $p in $project return base-uri($p)) return
                $project_[1] else $project_ }; declare function
                project:usersaccountname($project-pid as xs:string) as xs:string {
                $config:PROJECT_ACCOUNTS_USER_ACCOUNTNAME_PREFIX||$project-pid||$config:PROJECT_ACCOUNTS_USER_ACCOUNTNAME_SUFFIX
                }; declare function project:adminsaccountname($project-pid as xs:string) as
                xs:string {
                $config:PROJECT_ACCOUNTS_ADMIN_ACCOUNTNAME_PREFIX||$project-pid||$config:PROJECT_ACCOUNTS_ADMIN_ACCOUNTNAME_SUFFIX
                }; (:~ : Prepares the structure for a new project or deletes the data of an existing
                one ~:) declare %private function project:structure($project-pid as xs:string,
                $action as xs:string) { let $admin-accountname :=
                project:adminsaccountname($project-pid), $admin-groupname :=
                project:adminsaccountname($project-pid), $users-accountname :=
                project:usersaccountname($project-pid), $users-groupname :=
                project:usersaccountname($project-pid) let $paths:=(
                project:path($project-pid,"data"), project:path($project-pid,"workingcopies"),
                project:path($project-pid,"lookuptables"),
                project:path($project-pid,"resourcefragments"),
                project:path($project-pid,"metadata") ) return switch($action) case 'prepare' return
                for $p in $paths return let $uri := xs:anyURI($p), (:paths returned by
                project:path() are always up to the project's specific collection, so we strip the
                last step here:) $col := replace($p,$project-pid||"/?$","") let $mk :=
                repo-utils:mkcol("/",$col||"/"||$project-pid), $set-owner := sm:chown($uri,
                $admin-accountname), $set-group := sm:chgrp($uri, $admin-groupname), $set-acls:= (
                sm:add-group-ace($uri, $users-groupname, true(), 'rx'), sm:add-group-ace($uri,
                $users-groupname, true(), 'rx'), sm:add-group-ace($uri, $users-groupname, false(),
                'w'), if (sm:user-exists("cr-xq")) then sm:add-user-ace($uri, "cr-xq", true(),
                'rwx') else (), sm:add-user-ace($uri, $config:cr-writer-accountname, true(), 'rwx'))
                return () case 'remove' return let $paths:= (config:path("data")||"/"||$project-pid,
                config:path("workingcopies")||"/"||$project-pid,
                config:path("lookuptables")||"/"||$project-pid,
                config:path("resourcefragments")||"/"||$project-pid,
                config:path("metadata")||"/"||$project-pid) return for $p in $paths return if
                (xmldb:collection-available($p)) then xmldb:remove($p) else () default return () };
                (:~ : returns the paths to various contents of a project by configuration. : This
                function does not check existence of collections, nor does it : check whether the
                paths are registered in the mets object. It can be : used as a constructor function
                for new resources. ~:) declare function project:path($project-pid as xs:string, $key
                as xs:string) as xs:string? { let
                $project-config:=project:parameters($project-pid)//param[@key=$key||".path"]/xs:string(.),
                $global-key := switch($key) case "workingcopy" return "workingcopies" case
                "lookuptable" return "lookuptables" case "master" return "data" case
                "resourcefragment" return "resourcefragments" case "home" return "projects" default
                return $key let $default := config:path($global-key) return switch(true()) case
                exists($project-config) return $project-config case exists($default) return
                $default||"/"||$project-pid default return () }; (:~ : Stores the project's mets
                record in the database and returns the path : to the newly created document. The
                base path is either read from the mets record : param 'project.home' or set by
                config:path('projects') : : @param $mets:record the mets:file : @return database
                path to the new file, or empty sequence if an error occured (logged in app-log)) ~:)
                declare %private function project:store($project-pid as xs:string, $mets:record as
                element(mets:mets)) as xs:string? { let $col :=
                replace($mets:record//param[@key='project.home'],$project-pid||"/?$",'') let $base
                := if ($col!='') then $col else config:path('projects') let $path:= try { let
                $mkdir:= repo-utils:mkcol($base,$project-pid) return
                xmldb:store($base||"/"||$project-pid,"project.xml",$mets:record) } catch * { let
                $log := util:log-app("INFO",$config:app-name, "Could not store project
                "||$project-pid||" to collection "||$base||". "||string-join(($err:code ,
                $err:description, $err:value),' - ') ) return () } return if ($path='') then let
                $rm-col := xmldb:remove($base||"/"||$project-pid) return util:log("INFO","Could not
                store project "||$project-pid||" to collection "||$base||".") else $path }; (:~ :
                Renames the project and its data, setting a new identifier and renaming the :
                collection structure. : : @return the uri of the new project collection containing
                the cr-catalog. ~:) declare function project:rename($project-pid as xs:string,
                $newId as xs:string) as element(mets:mets) { () (:TODO:) }; (:~ : Imports a
                cr-archive (a zip file containing a whole cr-project) into the content repository. :
                : @param $archive the zipped cr-archive to be imported. : @return the project.xml of
                the imported project ~:) declare function project:import($archive as
                xs:base64Binary) as element(mets:mets)? { () (:TODO:) }; (:~ : Exports the whole
                content of a project as a zip file. : This includes: : - the content of
                project-home, including the project.xml METS record : - content of every mets:file
                reference, when it's @xlink:href starts with "/db" : - content of relevant
                xconfig-files in /db/system/config/db... : The files : : @param $project-pid the PID
                of the cr-project to be exported : @return the self-contained cr-archive. ~:)
                declare function project:export($project-pid as xs:string) as xs:base64Binary? { let
                $doc := project:get($project-pid) let $grammar-location :=
                $config:app-root||"/mets.xsd" let $files-project-home := for $f in
                xmldb:xcollection(config:path("project-home")) return base-uri($f) (:TODO validate:)
                return () }; (:~ : Sends ~:) declare function project:publish($project-pid as
                xs:string, $archive as xs:base64Binary, $cr-endpoint as xs:anyURI) as xs:boolean {
                ()(:TODO:) }; declare function project:collection($project-pid as xs:string) as
                xs:string? { util:collection-name(project:get($project-pid)) }; (:~ : Returns the
                path to a project's mets records by retrieving via its @OBJID. : This enables us to
                set the projects own path in its mets:techMD-section. ~:) declare function
                project:filepath($project-pid as xs:string) as xs:string? {
                base-uri(project:get($project-pid)) }; declare function
                project:filepath($project-pid as xs:string) as xs:string? { if
                (exists(collection(config:path("projects"))//mets:mets[@OBJID = $project-pid])) then
                base-uri(collection(config:path("projects"))//mets:mets[@OBJID = $project-pid]) else
                base-uri(collection("/db")//mets:mets[@OBJID = $project-pid]) }; (:~ : removes the
                cr-project from the content repository without removing the project's resources. : :
                @param $config the uri of the cr-catalog to be removed : @return true if projec ~:)
                declare function project:purge($project-pid as xs:string) as empty() {
                project:purge($project-pid,()) }; (:~ : removes the cr-project from the content
                repository, possibly also removing the project's data. : : @param $config the uri of
                the cr-catalog to be removed : @param $delete-data should the project's data be
                removed? (default: 'no') : @return empty() ~:) declare function
                project:purge($project-pid as xs:string, $delete-data as xs:boolean*) as empty() {
                if (exists(project:get($project-pid))) then let $delete-data :=
                ($delete-data,false())[1] return if ($delete-data) then let $base :=
                config:path('projects') let $rm-structure :=
                project:structure($project-pid,'remove'), $rm-indizes := for $x in
                xmldb:get-child-resources(config:path("indexes"))[starts-with(.,"index-"||$project-pid)]
                return ( xmldb:remove(config:path("indexes"),$x),
                util:log-app("INFO",$config:app-name,"removed index file "||$x||".") ) let
                $project-dir := project:collection($project-pid), $rm-project-dir := if
                ($project-dir!='') then xmldb:remove($project-dir) else () let $log :=
                util:log-app("INFO",$config:app-name,"removed project dir "||$project-dir) let
                $rm-accounts := project:remove-accounts($project-pid) let $log :=
                util:log-app("INFO",$config:app-name,"removed project accounts") let $log :=
                util:log-app("INFO",$config:app-name,"finished purging project "||$project-pid)
                return () else let $update-status := project:status($project-pid,'removed') let $log
                := util:log-app("INFO",$config:app-name,"set status of project "||$project-pid||" to
                'removed'") return () else () }; (:~ : sets the status of the project ~:) declare
                function project:status($project-pid as xs:string, $data as xs:string) as xs:string
                { let $project:= project:get($project-pid), $definedStatus := project:statusmap()
                return if (exists($project)) then let $update := update value
                $project/mets:metsHdr/@RECORDSTATUS with $data return $data else
                util:log("INFO","unknown project '"||$project-pid||"'.") }; (:~ : gets the status of
                the project, empty string if project does not exist ~:) declare function
                project:status($project-pid as xs:string) as element(data) { let
                $project:=project:get($project-pid) let
                $status:=$project/mets:metsHdr/xs:string(@RECORDSTATUS) return &lt;data
                request="/cr_xq/{$project-pid}/status"
                datatype="xs:string"&gt;{$status}&lt;/data&gt; }; declare %private function
                project:statusmap() as map() { map:new( for $s at $pos in (
                $config:PROJECT_STATUS_AVAILABLE, $config:PROJECT_STATUS_REVISION,
                $config:PROJECT_STATUS_RESTRICTED, $config:PROJECT_STATUS_REMOVED) return
                map:entry($s, $pos) ) }; (:~ : gets the status of the project as a numerical code
                ~:) declare function project:status-code($project-pid as xs:string) as element(data)
                { let $status:=project:status($project-pid), $code :=
                map:get(project:statusmap(),$status) return &lt;data
                request="/cr_xq/{$project-pid}/status-code"
                datatype="xs:integer"&gt;{$code}&lt;/data&gt; }; (:~ : sets the status of the
                project as a numerical code ~:) declare function project:status-code($project-pid as
                xs:string, $data as xs:integer) as empty() { let $project:=
                project:get($project-pid), $definedStatus := for $k in map:keys(project:statusmap())
                let $val:=map:get(project:statusmap(),$k) return if ($val = $data) then $k else ()
                return if (exists($definedStatus) and exists($project)) then (update value
                $project/mets:metsHdr/@RECORDSTATUS with $definedStatus,true()) else () }; declare
                function project:list-defined-status() as element(status){ &lt;list&gt;{ for $name
                in map:keys(project:statusmap()) let $code := map:get(project:statusmap(),$name)
                order by $code ascending return &lt;status code="{$code}"&gt;{$name}&lt;/status&gt;
                }&lt;/list&gt; }; (:~ : lists all resources of a given project as their mets:divs. :
                : @param $config the mets-config of a project ~:) declare function
                project:resources($project-pid as xs:string) as element(mets:div)* { let
                $doc:=project:get($project-pid) let $structMap:=$doc//mets:structMap[@ID eq
                $config:PROJECT_STRUCTMAP_ID and @TYPE eq $config:PROJECT_STRUCTMAP_TYPE] return
                $structMap//mets:div[@TYPE eq $config:PROJECT_RESOURCE_DIV_TYPE] }; (:~ reads the
                resource sequence from the project-configuration CHECK: need wrapped in
                mets:structMap element or just sequence? @param $project if $project is string, it
                is treated as project-id and the project-config is fetched otherwise treated as
                already resolved project-config document :) declare function
                project:list-resources($project) as element(mets:div)* { let $doc:= if ($project
                instance of xs:string) then project:get($project) else $project let
                $structMap:=$doc//mets:structMap[@ID eq $config:PROJECT_STRUCTMAP_ID and @TYPE eq
                $config:PROJECT_STRUCTMAP_TYPE] (: return
                &lt;mets:structMap&gt;{$structMap//mets:div[@TYPE eq
                $config:PROJECT_RESOURCE_DIV_TYPE]}&lt;/mets:structMap&gt;:) return
                $structMap//mets:div[@TYPE eq $config:PROJECT_RESOURCE_DIV_TYPE] }; declare function
                project:list-resources-resolved($project) as element(sru:searchRetrieveResponse)* {
                let $start-time := util:system-dateTime() let $doc:= if ($project instance of
                xs:string) then project:get($project) else $project let $ress :=
                project:list-resources($doc) let $project-id := $doc/@OBJID let $count :=
                count($ress) let $resources := for $res in $ress let $dmd := resource:dmd($res,
                $project ) let $res-id := $res/data(@ID) let $res-label := $res/data(@LABEL) let
                $res-title := (if (exists($dmd)) then index:apply-index($dmd,'title',$project) else
                $res-label, $res-label)[1] let $indexImage-path := resource:path($res-id,
                $project-id, 'indexImage') order by $res/@ORDER return &lt;fcs:Resource
                pid="{$res-id}" &gt; &lt;fcs:DataView
                type="title"&gt;{$res-title}&lt;/fcs:DataView&gt; &lt;fcs:DataView
                type="metadata"&gt;{$dmd}&lt;/fcs:DataView&gt; &lt;fcs:DataView type="image"
                ref="{$indexImage-path}" /&gt; &lt;/fcs:Resource&gt; let $end-time :=
                util:system-dateTime() (:&lt;sru:baseUrl&gt;{repo-utils:config-value($config,
                "base.url")}&lt;/sru:baseUrl&gt;:) return &lt;sru:searchRetrieveResponse&gt;
                &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                &lt;sru:numberOfRecords&gt;{$count}&lt;/sru:numberOfRecords&gt;
                &lt;sru:echoedSearchRetrieveRequest&gt; &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                &lt;sru:query&gt;*&lt;/sru:query&gt;
                &lt;fcs:x-context&gt;{$project-id}&lt;/fcs:x-context&gt;
                &lt;fcs:x-dataview&gt;metadata&lt;/fcs:x-dataview&gt;
                &lt;sru:startRecord&gt;1&lt;/sru:startRecord&gt;
                &lt;sru:maximumRecords&gt;0&lt;/sru:maximumRecords&gt;
                &lt;/sru:echoedSearchRetrieveRequest&gt; &lt;sru:extraResponseData&gt;
                &lt;fcs:returnedRecords&gt;{$count}&lt;/fcs:returnedRecords&gt;
                &lt;fcs:duration&gt;{$end-time - $start-time }&lt;/fcs:duration&gt;
                &lt;/sru:extraResponseData&gt; &lt;sru:records&gt; {for $res at $pos in $resources
                return &lt;sru:record&gt;
                &lt;sru:recordSchema&gt;http://clarin.eu/fcs/1.0/Resource.xsd&lt;/sru:recordSchema&gt;
                &lt;sru:recordPacking&gt;xml&lt;/sru:recordPacking&gt;
                &lt;sru:recordData&gt;{$res}&lt;/sru:recordData&gt;
                &lt;sru:recordPosition&gt;{$pos}&lt;/sru:recordPosition&gt;
                &lt;sru:recordIdentifier&gt;{xs:string($res/@pid)}&lt;/sru:recordIdentifier&gt;
                &lt;/sru:record&gt; } &lt;/sru:records&gt; &lt;/sru:searchRetrieveResponse&gt; };
                (:~ : lists the ids of all resources in given project. : : @param $config the
                mets-config of a project ~:) declare function project:resource-pids($project-pid as
                xs:string) as xs:string* { let $resources:=project:resources($project-pid) return
                $resources/@ID }; (:~ returns the resource-pids based on the resource sequence from
                the project-configuration, wrapped in mets:structMap element @param $project if
                $project is string, it is treated as project-id and the project-config is fetched
                otherwise treated as already resolved project-config document :) declare function
                project:list-resource-pids($project) as xs:string* { let $doc:=if ($project instance
                of xs:string) then project:get($project) else $project let
                $structMap:=$doc//mets:structMap[@ID eq $config:PROJECT_STRUCTMAP_ID and @TYPE eq
                $config:PROJECT_STRUCTMAP_TYPE] return $structMap//mets:div[@TYPE eq
                $config:PROJECT_RESOURCE_DIV_TYPE]/xs:string(@ID) }; (: getter and setter for mets
                Header :) declare function project:metsHdr($project-pid as xs:string) as
                element(mets:metsHdr){ let $doc:=project:get($project-pid) return $doc/mets:metsHdr
                }; declare function project:metsHdr($project-pid as xs:string, $data as
                element(mets:metsHdr)) as empty() { let $doc:= project:get($project-pid), $current:=
                project:metsHdr($project-pid) let $update := if (exists($current)) then if
                (exists($data)) then update replace $current with $data else update delete $current
                else update insert $data into $doc return () }; (:~ getter and setter for mets
                dmdSec, i.e. the project's CMDI record : @param $project the PID of the project or
                the mets:mets entry :) declare function project:dmd($project) as element(cmd:CMD)? {
                let $project := repo-utils:get-record($project), $dmdSec :=
                $project//mets:dmdSec[@ID = $config:PROJECT_DMDSEC_ID] return if
                (doc-available($dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE =
                'CMDI']/@xlink:href)) then doc($dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE =
                'CMDI']/@xlink:href)/cmd:CMD else () }; declare function project:dmd($project, $data
                as element(cmd:CMD)?) as empty() { let $doc:= repo-utils:get-record($project),
                $project-pid := $doc/xs:string(@OBJID), $current:= project:dmd($project), $dmdSec :=
                $doc//mets:dmdSec[@ID = $config:PROJECT_DMDSEC_ID] return if (exists($current)) then
                if (exists($data)) then update value $current with $data else (update delete
                $dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE =
                'CMDI'],xmldb:remove(util:collection-name($current),util:document-name($current)))
                else let $path := if (exists($dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE =
                'CMDI']/@xlink:href[.!=''])) then $dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE
                = 'CMDI']/@xlink:href else
                replace(project:path($project-pid,'metadata'),'/$','')||"/CMDI/"||$project-pid||".xml"
                let $href-toks := tokenize($path,'/'), $filename := $href-toks[last()],
                $collection:= substring-before($path,"/"||$filename) let $mk-col :=
                repo-utils:mkcol("/",$collection), $store-data :=
                repo-utils:store($collection,$filename,$data,false(),()) return switch(true()) case
                (exists($dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE = 'CMDI']/@xlink:href[. =
                $path])) return () case (exists($dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE =
                'CMDI']/@xlink:href[. != $path])) return update value $dmdSec/mets:mdRef[@MDTYPE =
                'OTHER'][@OTHERMDTYPE = 'CMDI']/@xlink:href with $path case
                (exists($dmdSec/mets:mdRef[@MDTYPE = 'OTHER'][@OTHERMDTYPE = 'CMDI'])) return update
                insert attribute {"xlink:href"} {$path} into $dmdSec/mets:mdRef[@MDTYPE =
                'OTHER'][@OTHERMDTYPE = 'CMDI'] case (exists($dmdSec)) return update insert
                &lt;mets:mdRef MDTYPE="OTHER" OTHERMDTYPE="CMDI" LOCTYPE="URL"
                xlink:href="{$path}"/&gt; into $dmdSec default return update insert &lt;mets:dmdSec
                ID="{$config:PROJECT_DMDSEC_ID}"&gt;&lt;mets:mdRef MDTYPE="OTHER" OTHERMDTYPE="CMDI"
                LOCTYPE="URL" xlink:href="{$path}"/&gt;&lt;/mets:dmdSec&gt; following
                $doc/mets:metsHdr }; (: getter and setter for index-map :) declare function
                project:map($project) as element(map)? { let $doc:=project:get($project) return
                $doc//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID]/mets:mdWrap/mets:xmlData/* };
                declare function project:map($data as element(map), $project-pid as xs:string) as
                empty() { let $doc:= project:get($project-pid), $current:= project:map($project-pid)
                return if (exists($current)) then if (exists($data)) then update replace $current
                with $data else update delete $current else if
                (exists($doc//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID])) then update value
                $doc//mets:techMD[@ID=$config:PROJECT_MAPPINGS_ID] with &lt;mdWrap MDTYPE="OTHER"
                xmlns="http://www.loc.gov/METS/"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;
                else update insert &lt;techMD ID="{$config:PROJECT_MAPPINGS_ID}"
                xmlns="http://www.loc.gov/METS/"&gt;&lt;mdWrap
                MDTYPE="OTHER"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;&lt;/techMD&gt;
                into $doc//mets:amdSec[@ID eq $config:PROJECT_AMDSEC_ID] }; (: getter and setter for
                project parameters :) declare function project:parameters($project-pid as xs:string)
                as element(param)* { let $doc:=project:get($project-pid) return
                $doc//mets:techMD[@ID=$config:PROJECT_PARAMETERS_ID]/mets:mdWrap/mets:xmlData/param
                }; declare function project:parameters($project-pid as xs:string, $data as
                element(param)*) as empty() { let $doc:= project:get($project-pid), $current:=
                project:parameters($project-pid) return if (exists($current)) then if
                (exists($data)) then update replace $current with $data else update delete $current
                else if (exists($doc//mets:techMD[@ID=$config:PROJECT_PARAMETERS_ID])) then update
                value $doc//mets:techMD[@ID=$config:PROJECT_PARAMETERS_ID] with &lt;mdWrap
                MDTYPE="OTHER"
                xmlns="http://www.loc.gov/METS/"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;
                else update insert &lt;techMD ID="{$config:PROJECT_PARAMETERS_ID}"
                xmlns="http://www.loc.gov/METS/" GROUPID="config.xml"&gt;&lt;mdWrap
                MDTYPE="OTHER"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;&lt;/techMD&gt;
                into $doc//mets:amdSec[@ID eq $config:PROJECT_AMDSEC_ID] }; (: getter and setter for
                a project's module configuration :) (: TODO WRITE ACTUAL PATHS AT PROJECT
                INITIALIZATION :) declare function project:moduleconfig($project-pid as xs:string)
                as element(module)* { let $doc:=project:get($project-pid) return
                $doc//mets:techMD[@ID=$config:PROJECT_MODULECONFIG_ID]/mets:mdWrap/mets:xmlData/module
                }; declare function project:moduleconfig($project-pid as xs:string, $data as
                element(module)*) as empty() { let $doc:= project:get($project-pid), $current:=
                project:moduleconfig($project-pid) return if (exists($current)) then if
                (exists($data)) then update replace $current with $data else update delete $current
                else if (exists($doc//mets:techMD[@ID=$config:PROJECT_MODULECONFIG_ID])) then update
                value $doc//mets:techMD[@ID=$config:PROJECT_MODULECONFIG_ID] with &lt;mdWrap
                MDTYPE="OTHER"
                xmlns="http://www.loc.gov/METS/"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;
                else let $wrapped := &lt;techMD ID="{$config:PROJECT_MODULECONFIG_ID}"
                xmlns="http://www.loc.gov/METS/" GROUPID="config.xml"&gt;&lt;mdWrap
                MDTYPE="OTHER"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;&lt;/techMD&gt;
                return update insert $wrapped into $doc//mets:amdSec[@ID eq
                $config:PROJECT_AMDSEC_ID] }; declare %private function
                project:default-acl($project-pid as xs:string) as element(sm:permission) {
                &lt;sm:permission xmlns:sm="http://exist-db.org/xquery/securitymanager"
                owner="{project:adminsaccountname($project-pid)}"
                group="{project:adminsaccountname($project-pid)}" mode="rwx------"&gt; &lt;sm:acl
                entries="3"&gt; &lt;!-- sm:ace/@who='other' _must_ be present --&gt; &lt;sm:ace
                index="0" target="GROUP" who="other" access_type="DENIED" mode="rwx"/&gt; &lt;sm:ace
                index="1" target="GROUP" who="{project:adminsaccountname($project-pid)}"
                access_type="ALLOWED" mode="rwx"/&gt; &lt;sm:ace index="2" target="GROUP"
                who="{project:usersaccountname($project-pid)}" access_type="ALLOWED" mode="r-x"/&gt;
                &lt;/sm:acl&gt; &lt;/sm:permission&gt; }; (: getter and setter for rightsMD :)
                declare function project:license($project) as element(cmd:License)? { let $dmd :=
                project:dmd($project) return $dmd//cmd:License }; declare function
                project:license($project, $data as element(cmd:License)?) as empty() { let $dmd :=
                project:dmd($project), $doc:=repo-utils:get-record($project), $current:=
                project:license($project) return if (exists($current)) then if (exists($data)) then
                let $update-data := update replace $current with $data return switch(true()) case
                (exists($doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID]/*)) return update value
                $doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID] with &lt;mets:mdRef
                MDTYPE="OTHER" OTHERMDTYPE="CMDI" LOCTYPE="URL" xlink:href="{base-uri($dmd)}"
                XPTR="xpointer(/cmd:CMD/cmd:Components/cmd:collection/cmd:License)
                xmlns(cmd=http://www.clarin.eu/cmd/)"/&gt; case
                (exists($doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID])) return update insert
                &lt;mets:mdRef MDTYPE="OTHER" OTHERMDTYPE="CMDI" LOCTYPE="URL"
                xlink:href="{base-uri($dmd)}"
                XPTR="xpointer(/cmd:CMD/cmd:Components/cmd:collection/cmd:License)
                xmlns(cmd=http://www.clarin.eu/cmd/)"/&gt; into
                $doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID] default return update insert
                &lt;mets:techMD ID="{$config:PROJECT_RIGHTSMD_ID}"&gt; &lt;mets:mdRef MDTYPE="OTHER"
                OTHERMDTYPE="CMDI" LOCTYPE="URL" xlink:href="{base-uri($dmd)}"
                XPTR="xpointer(/cmd:CMD/cmd:Components/cmd:collection/cmd:License)
                xmlns(cmd=http://www.clarin.eu/cmd/)"/&gt; &lt;/mets:techMD&gt; into
                $doc//mets:amdSec[@ID eq $config:PROJECT_AMDSEC_ID] else (update delete
                $doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID]/*, update delete
                $current/cmd:*/node()) else let $update-dmd := if (exists($dmd)) then update insert
                $data into $dmd/cmd:CMD/cmd:Components/cmd:collection else () return switch(true())
                case (exists($doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID]/*)) return update
                value $doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID] with &lt;mets:mdRef
                MDTYPE="OTHER" OTHERMDTYPE="CMDI" LOCTYPE="URL" xlink:href="{base-uri($dmd)}"
                XPTR="xpointer(/cmd:CMD/cmd:Components/cmd:collection/cmd:License)
                xmlns(cmd=http://www.clarin.eu/cmd/)"/&gt; case
                (exists($doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID])) return update insert
                &lt;mets:mdRef MDTYPE="OTHER" OTHERMDTYPE="CMDI" LOCTYPE="URL"
                xlink:href="{base-uri($dmd)}"
                XPTR="xpointer(/cmd:CMD/cmd:Components/cmd:collection/cmd:License)
                xmlns(cmd=http://www.clarin.eu/cmd/)"/&gt; into
                $doc//mets:rightsMD[@ID=$config:PROJECT_RIGHTSMD_ID] default return update insert
                &lt;mets:techMD ID="{$config:PROJECT_RIGHTSMD_ID}"&gt; &lt;mets:mdRef MDTYPE="OTHER"
                OTHERMDTYPE="CMDI" LOCTYPE="URL" xlink:href="{base-uri($dmd)}"
                XPTR="xpointer(/cmd:CMD/cmd:Components/cmd:collection/cmd:License)
                xmlns(cmd=http://www.clarin.eu/cmd/)"/&gt; &lt;/mets:techMD&gt; into
                $doc//mets:amdSec[@ID eq $config:PROJECT_AMDSEC_ID] }; (:~ describes the project's
                Access Control List in eXist's ACL format : @param $project-pid the id of the
                project to query : @return the Project's ACL in XML notation. :) (: TODO settle for
                a metadata format, for now we assume eXist's ACL notation :) declare function
                project:acl($project-pid as xs:string) as element(sm:permission)? { let
                $doc:=project:get($project-pid) return $doc//mets:rightsMD[@ID eq
                $config:PROJECT_ACL_ID]/mets:mdWrap/mets:xmlData/sm:permission }; declare function
                project:acl($project-pid as xs:string, $data as element(sm:permission)?) as empty()
                { let $doc:= project:get($project-pid), $current:= project:acl($project-pid) let
                $insert:= if (exists($current)) then if (exists($data)) then update replace $current
                with $data else update replace $current with project:default-acl($project-pid) else
                if (exists($doc//mets:rightsMD[@ID=$config:PROJECT_ACL_ID])) then update value
                $doc//mets:rightsMD[@ID=$config:PROJECT_ACL_ID] with &lt;mdWrap MDTYPE="OTHER"
                OTHERMDTYPE="EXISTACL"
                xmlns="http://www.loc.gov/METS/"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;
                else update insert &lt;techMD ID="{$config:PROJECT_ACL_ID}"
                xmlns="http://www.loc.gov/METS/" GROUPID="config.xml"&gt;&lt;mdWrap MDTYPE="OTHER"
                OTHERMDTYPE="EXISTACL"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;&lt;/techMD&gt;
                into $doc//mets:amdSec[@ID eq $config:PROJECT_AMDSEC_ID] return if
                (project:acl($project-pid)//sm:ace[@target eq 'GROUP' and @who eq 'other']) then ()
                else (: we have to make sure that there is an ACL entry for GROUP 'other' :) let
                $updated:=project:acl($project-pid), $number :=
                $updated/sm:acl/xs:integer(@entries), $newNumber := xs:integer($number) + 1 return
                (update insert &lt;sm:ace index="0" target="GROUP" who="other" access_type="DENIED"
                mode="rwx"/&gt; into $updated/sm:acl, for $i at $pos in $updated/sm:acl/sm:ace
                return update value $i/@index with xs:integer($pos)-1, update value
                $updated/sm:acl/@entries with $newNumber) }; (:~ : Returns the handle to the given
                project. : Handles are stored directly in the CMDI metadata of the resoruce as we
                cannot : assign handles without a CMDI record. : : @param $type: The aspect of the
                resource to get the handle for. Currently only metdata / CMDI records can be
                get/set. : @param $project-pid: The PID of the project :) declare function
                project:get-handle($type as xs:string, $project-pid as xs:string) as xs:string* {
                let $cmdi := project:dmd($project-pid), $config := config:config($project-pid),
                $resourceproxy-id :=
                config:param-value($config,"pid-resourceproxy-prefix")||$project-pid return if
                (exists($cmdi)) then switch($type) (: metadata defaults to the CMDI record :) case
                "metadata" return $cmdi/cmd:Header/cmd:MdSelfLink case "CMDI" return
                $cmdi/cmd:Header/cmd:MdSelfLink default return () else
                util:log-app("ERROR",$config:app-name,"No CMDI record found for project
                '"||$project-pid||"'") }; declare function project:set-handle($type as xs:string,
                $project-pid as xs:string) as empty() { let $cmdi := project:dmd($project-pid),
                $config := config:config($project-pid), $resourceproxy-id :=
                config:param-value($config,"pid-resourceproxy-prefix")||$project-pid return
                switch($type) (: sets handles of all resources of a the project in its
                ResourceProxy, without actually updating their URL :) case "resources" return for $r
                in $cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[cmd:ResourceType =
                "Metadata"] return let $resource-pid := $r/@id let $handle :=
                resource:get-handle("CMDI",$resource-pid,$project-pid) return if ($r != $handle)
                then update value $r/cmd:ResourceRef with $handle else () case "CMDI" return let
                $current := project:get-handle("CMDI",$project-pid) let $target-url := concat(
                replace(config:param-value($config,"public-repo-baseurl"),'/$',''),
                "/get/",$project-pid,"/", switch($type) case "CMDI" return "metadata/CMDI" default
                return "metadata/CMDI" ) let $handle-url := if (exists($current) and $current != '')
                then handle:update($target-url,$current,$project-pid) else
                handle:create($target-url,$project-pid) return switch (true()) case
                exists($cmdi/cmd:Header/cmd:MdSelfLink) return update value
                $cmdi/cmd:Header/cmd:MdSelfLink with $handle-url case exists($cmdi/cmd:Header)
                return update insert &lt;cmd:MdSelfLink&gt;{$handle-url}&lt;/cmd:MdSelfLink&gt; into
                $cmdi/cmd:Header default return () default return
                util:log-app("INFO",$config:app-name,"unknown aspect "||$type||" of project
                "||$project-pid||". Can't set handle.") }; (:generates a basic CMDI record based on
                the data in project.xml:) declare function project:mets2cmdi($project-pid as
                xs:string) as element(cmd:CMD)? { (: make sure all resource's metata has CMDI
                records and handles :) let $resource-md-handles := for $r-pid in
                project:resource-pids($project-pid) let $handle-uri :=
                resource:get-handle("metadata",$r-pid,$project-pid) return if ($handle-uri) then ()
                else () let $project-handle := let $current :=
                project:get-handle("metadata",$project-pid) return if ($current) then $current else
                () return () }; declare function project:dmd2dc($project-pid as xs:string) as
                element(oai_dc:dc){ let $dmd := project:dmd($project-pid), $xsl :=
                doc(config:path("scripts")||"/dc/cmdi2dc.xsl"), $params :=
                &lt;parameters&gt;&lt;param name='fedora-pid-namespace-prefix'
                value="{config:param-value(config:module-config(),'fedora-pid-namespace-prefix')}"/&gt;&lt;/parameters&gt;
                return transform:transform($dmd,$xsl,$params) }; (:~ : returns the full logical
                structure (table of contents if you wish) of a project : as generated into the
                structMap.logical : : @param $resource-pid the pid of the resource : @param
                $project-pid the pid of the project : @return ~:) declare function
                project:get-toc($project-pid as xs:string) as element()* { let $mets:record :=
                project:get($project-pid) return
                $mets:record//mets:structMap[@TYPE=$config:PROJECT_TOC_STRUCTMAP_TYPE
                ]/mets:div/mets:div }; declare function project:get-toc-resolved($project-pid as
                xs:string) as element()? { let $mets:record := project:get($project-pid),
                $toc-struct := $mets:record//mets:structMap[@TYPE=$config:PROJECT_TOC_STRUCTMAP_TYPE
                ]/mets:div, $frgs :=
                $mets:record//mets:structMap[@TYPE=$config:PROJECT_STRUCTMAP_TYPE]//mets:div[@TYPE='resourcefragment'],
                $resources :=
                $mets:record//mets:structMap[@TYPE=$config:PROJECT_STRUCTMAP_TYPE]//mets:div[@TYPE='resource']
                return &lt;mets:structMap&gt;{$toc-struct/@*, for $toc-resource in
                $toc-struct/mets:div let $res-id := substring-after($toc-resource/@CONTENTIDS, '#')
                let $res-order := $resources[@ID=$res-id]/data(@ORDER) let $resolved-toc := for $div
                in $toc-resource/mets:div let $rfid-first :=
                $div/mets:fptr/mets:area/xs:string(@BEGIN), $rfid-last :=
                $div/mets:fptr/mets:area/xs:string(@END), $frg-first := $frgs[@ID=$rfid-first],
                $frg-last := $frgs[@ID=$rfid-last], $chapter-frgs := for $frg in $frgs where $frg
                &gt;&gt; $frg-first and $frg &lt;&lt; $frg-last return $frg return
                &lt;mets:div&gt;{$div/@*,$div/*, $frg-first, $chapter-frgs,
                $frg-last}&lt;/mets:div&gt; order by $res-order return &lt;mets:div
                ORDER="{$res-order}"&gt;{$toc-resource/@*,$resolved-toc}&lt;/mets:div&gt;
                }&lt;/mets:structMap&gt; }; declare function project:do-get-toc-resolved($node as
                node(), $mets-record as element(mets:mets)) as node() {
                project:do-get-toc-resolved($node,(),$mets-record) }; declare function
                project:do-get-toc-resolved($node as node(), $resource-pid as xs:string?,
                $mets-record as element(mets:mets)) as node()* { typeswitch ($node) case attribute()
                return $node case text() return $node case processing-instruction() return $node
                case document-node() return project:do-get-toc-resolved($node/*, $resource-pid,
                $mets-record) case element(mets:fptr) return for $n in $node/* return
                project:do-get-toc-resolved($node/*, $resource-pid, $mets-record) case
                element(mets:area) return let $frgs := $mets-record//mets:div[@ID =
                $resource-pid]//mets:div[@type=$config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE] let
                $rfid-first := $node/xs:string(@BEGIN), $rfid-last := $node/xs:string(@END),
                $frg-first := $mets-record//mets:div[@ID=$rfid-first], $frg-last :=
                $mets-record//mets:div[@ID=$rfid-first], $chapter-frgs := for $frg in $frgs where
                $frg &gt;&gt; $frg-first and $frg &lt;&lt; $frg-last return $frg return
                ($frg-first,$chapter-frgs,$frg-last) case element() return element
                {QName(xs:string(namespace-uri($node)),local-name($node))} { $node/@*, for $n in
                $node/node() return if ($node/self::mets:div and $node/@CONTENTIDS) then
                project:do-get-toc-resolved($n,substring-after($node/@CONTENTIDS,'#'),$mets-record)
                else project:do-get-toc-resolved($n,$resource-pid,$mets-record) } default return
                $node }; </f>
            <f n="repo-utils.xqm">xquery version "3.0";&#xd; module namespace repo-utils =
                "http://aac.ac.at/content_repository/utils";&#xd; declare namespace
                mets="http://www.loc.gov/METS/";&#xd; declare namespace
                xlink="http://www.w3.org/1999/xlink";&#xd; declare namespace fcs =
                "http://clarin.eu/fcs/1.0";&#xd; declare namespace
                cr="http://aac.ac.at/content_repository";&#xd; &#xd; &#xd; &#xd; import module
                namespace xdb="http://exist-db.org/xquery/xmldb";&#xd; import module namespace diag
                = "http://www.loc.gov/zing/srw/diagnostic/" at
                "../modules/diagnostics/diagnostics.xqm";&#xd; import module namespace
                request="http://exist-db.org/xquery/request";&#xd; import module namespace
                project="http://aac.ac.at/content_repository/project" at "project.xqm";&#xd; import
                module namespace resource="http://aac.ac.at/content_repository/resource" at
                "resource.xqm";&#xd; import module namespace
                ltb="http://aac.ac.at/content_repository/lookuptable" at "lookuptable.xqm";&#xd;
                import module namespace rf="http://aac.ac.at/content_repository/resourcefragment" at
                "resourcefragment.xqm";&#xd; import module namespace
                index="http://aac.ac.at/content_repository/index" at
                "/db/apps/cr-xq-dev0913/core/index.xqm";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd; (:~ HELPER
                functions - configuration, caching, data-access&#xd; :)&#xd; &#xd; (:&#xd; : this
                all cannot be defined as global variable, because we want different
                configurations,&#xd; : thus the $config has to be sent sas param everywhere&#xd; :
                declare variable $repo-utils:config := doc("config.xml");&#xd; : declare variable
                $repo-utils:mappings := doc(repo-utils:config-value('mappings'));&#xd; : declare
                variable $repo-utils:data-collection :=
                collection(repo-utils:config-value('data.path'));&#xd; : declare variable
                $repo-utils:md-collection :=
                collection(repo-utils:config-value('metadata.path'));&#xd; : declare variable
                $repo-utils:cachePath as xs:string := repo-utils:config-value('cache.path');&#xd;
                :)&#xd; &#xd; declare variable $repo-utils:xmlExt as xs:string := ".xml";&#xd;
                declare variable $repo-utils:responseFormatXml as xs:string := "xml";&#xd; declare
                variable $repo-utils:responseFormatJSon as xs:string := "json";&#xd; declare
                variable $repo-utils:responseFormatText as xs:string := "text";&#xd; declare
                variable $repo-utils:responseFormatHTML as xs:string := "html";&#xd; declare
                variable $repo-utils:responseFormatHTMLpage as xs:string := "htmlpage";&#xd; &#xd;
                declare variable $repo-utils:sys-config-file := "conf/config-system.xml";&#xd; &#xd;
                (:~ not solved yet - look at cr-xq/core/config.xqm: config:param-value('base-url') !
                :)&#xd; declare function repo-utils:base-url($config as item()*) as xs:string*
                {&#xd; (:let $server-base := if (repo-utils:config-value($config, 'server.base') =
                '') then '' else repo-utils:config-value($config, 'server.base')&#xd; let
                $config-base-url := if (repo-utils:config-value($config, 'base.url') = '') then
                request:get-uri() else repo-utils:config-value($config, 'base.url')&#xd; return
                concat($server-base, $config-base-url):)&#xd; (: let $url :=
                request:get-url():)&#xd; let $url := request:get-uri()&#xd; return $url&#xd; };
                &#xd; &#xd; &#xd; (:~&#xd; : Helper function which programmatically defines
                prefix-namespace-bindings &#xd; : in a project map.&#xd; : &#xd; : @param $config:
                the config of the current project.&#xd; ~:)&#xd; declare function
                repo-utils:declare-namespaces($config as item()*) as empty() {&#xd; let
                $mappings:=config:mappings($config),&#xd; $namespaces:=$mappings//namespaces&#xd;
                return &#xd; for $ns in $namespaces/ns&#xd; let $prefix:=$ns/@prefix,&#xd;
                $namespace-uri:=$ns/@uri&#xd; let $log:=util:log("INFO", "declaring namespace
                "||$prefix||"='"||$namespace-uri||"'")&#xd; return
                util:declare-namespace(xs:string($prefix), xs:anyURI($namespace-uri))&#xd; };&#xd;
                &#xd; declare function repo-utils:config($config-file as xs:string) as node()*
                {&#xd; let $sys-config := if (doc-available($repo-utils:sys-config-file)) then
                doc($repo-utils:sys-config-file) else (),&#xd; $config := if
                (doc-available($config-file)) then (doc($config-file), $sys-config) &#xd; else
                diag:diagnostics("general-error", concat("config not available: ",
                $config-file))&#xd; return $config&#xd; };&#xd; &#xd; declare function
                repo-utils:config-value($config, $key as xs:string) as xs:string? {&#xd; let
                $project-config:=$config/config[not(xs:string(@type)='system' or
                xs:string(@type)='module')]//(param|property)[xs:string(@key)=$key],&#xd;
                $module-config:=$config/config[xs:string(@type)='module']//(param|property)[xs:string(@key)=$key],&#xd;
                $system-config:=$config/config[xs:string(@type)='system']//(param|property)[xs:string(@key)=$key],&#xd;
                $top-level-config:=$config//(param|property)[xs:string(@key)=$key]&#xd; return
                ($project-config,$module-config,$system-config,$top-level-config)[1]&#xd; };&#xd;
                &#xd; declare function repo-utils:config-values($config, $key as xs:string) as
                xs:string* {&#xd; ($config/config[not(xs:string(@type)='system' or
                xs:string(@type)='module')]//(param|property)[xs:string(@key)=$key],&#xd;
                $config/config[xs:string(@type)='module']//(param|property)[xs:string(@key)=$key],&#xd;
                $config/config[xs:string(@type)='system']//(param|property)[xs:string(@key)=$key],&#xd;
                $config//(param|property)[xs:string(@key)=$key] (: accept also top-level
                param|property :)&#xd; )&#xd; };&#xd; &#xd; (:declare function
                repo-utils:config-value($config, $key as xs:string) as xs:string* {&#xd;
                ($config[not(@type='system')]//(param|property)[@key=$key],
                $config[@type='system']//property[@key=$key])[1]&#xd; };&#xd; :)&#xd; (:~ Get value
                of a param based on a key, from config or from request-param (precedence) :)&#xd;
                declare function repo-utils:param-value($config, $key as xs:string, $default as
                xs:string) as xs:string* {&#xd; (: let $param := request:get-parameter($key,
                $default):)&#xd; let $param := $config//(param|property)[@key=$key]&#xd; return
                &#xd; if ($param) &#xd; then $param &#xd; else $default&#xd; };&#xd; &#xd; (:~ This
                function returns a node set consisting of all available documents of the project as
                listed in mets:fileGrp[@USE="Project Data"] &#xd; : &#xd; : @param $project-pid: The
                CR-Context&#xd; : @param $config: The mets-config of the project&#xd; ~:)&#xd;
                declare function repo-utils:context-to-collection($project-pid as xs:string,
                $config) as node()* {&#xd; let $dbcoll-path :=
                repo-utils:context-to-collection-path($project-pid, $config)&#xd; let $docs:= &#xd;
                if ($dbcoll-path = "" ) then ()&#xd; else&#xd; for $p in $dbcoll-path&#xd;
                return&#xd; if (ends-with($p,'.xml'))&#xd; then doc($p) &#xd; else if
                (xmldb:collection-available($p)) then&#xd; collection($p)&#xd; else ()&#xd; return
                ($docs)&#xd; };&#xd; &#xd; &#xd; (:~ This function returns a node set consisting of
                all available documents of the project as listed in mets:fileGrp[@USE="Project
                Data"] &#xd; : &#xd; : @param $project-pid: The CR-Context&#xd; : @param $config:
                The mets-config of the project&#xd; ~:)&#xd; declare function
                repo-utils:context-to-fragments($x-context as xs:string) as item()* {&#xd; let
                $projects:=config:path("projects"),&#xd; $contexts:=tokenize($x-context,",")&#xd;
                return &#xd; for $c in $contexts&#xd; let $id := normalize-space($c),&#xd; $div:=
                collection($projects)//mets:div[@ID eq $id],&#xd; (: $project := if (exists($div))
                then () else collection($projects)//mets:mets[@OBJID eq $id]:)&#xd; $fileid :=
                ($div/mets:fptr/@FILEID,$div/mets:fptr/mets:area/@FILEID),&#xd; $uri :=
                root($div)//mets:file[ancestor::mets:fileGrp[@ID eq $config:PROJECT_DATA_FILEGRP_ID]
                and @ID eq $fileid]/mets:FLocat/@xlink:href&#xd; (: $doc := doc($uri):)&#xd; return
                xs:string($uri) &#xd; (:if ($fileid/parent::mets:area)&#xd; then
                $doc//fcs:resourceFragment[@cr:id=$fileid/parent::mets:area/@BEGIN]&#xd; else
                $doc:)&#xd; };&#xd; &#xd; &#xd; (:~ This function returns paths to all available
                data files of the given project.&#xd; if $x-context is empty the path to the
                project' collection of working copies is returned,&#xd; otherwise the list of all
                data files of the project is returned&#xd; :&#xd; : @param $x-context: The
                CR-Context&#xd; : @param $config: The mets-config of the project&#xd; ~:)&#xd;
                declare function repo-utils:context-to-collection-path($x-context as xs:string*,
                $config) as xs:string* {&#xd; let $context-type :=
                repo-utils:context-to-type($x-context,$config)&#xd; return&#xd; if ($context-type =
                "project")&#xd; then project:path($x-context, 'workingcopies')&#xd; else &#xd; if
                ($context-type='resource')&#xd; then &#xd; let $project-pid :=
                repo-utils:context-to-project-pid($x-context,$config)&#xd; return
                resource:path($x-context,$project-pid,'workingcopy')&#xd; else ()&#xd; (:
                project:path($x-context, 'workingcopies'):)&#xd; (:let $projectData:=
                $config//mets:fileGrp[@USE="Project Data"]//mets:file/mets:FLocat&#xd; return &#xd;
                for $d in $projectData/@xlink:href return&#xd; if (doc-available($d)) &#xd; then
                xs:string($d)&#xd; else ():)&#xd; };&#xd; &#xd; declare function
                repo-utils:context-to-type($x-context as xs:string*, $config) as xs:string* {&#xd;
                let $projects := config:path("projects"),&#xd; $div :=
                collection($projects)//mets:div[@ID = normalize-space($x-context)],&#xd; $mets :=
                collection($projects)//mets:mets[@OBJID = normalize-space($x-context)]&#xd; return
                &#xd; switch(true())&#xd; case exists($mets) return "project"&#xd; case exists($div)
                return $div/xs:string(@TYPE)&#xd; default return
                util:log-app("ERROR",$config:app-name,"Can't resolve $x-context
                '"||normalize-space($x-context)||"'")&#xd; };&#xd; &#xd; declare function
                repo-utils:context-to-project-pid($x-context as xs:string?, $config) as xs:string*
                {&#xd; let $projects := collection(config:path("projects"))&#xd; return &#xd;
                switch(true())&#xd; case exists($projects//mets:mets[@OBJID = $x-context]) return
                $x-context&#xd; case exists($projects//mets:div[@ID = $x-context]) return
                $projects//mets:div[@ID = $x-context]/ancestor::mets:mets/@OBJID/xs:string(.)&#xd;
                default return ()&#xd; };&#xd; &#xd; declare function
                repo-utils:context-to-resource-pid($x-context as xs:string?, $config) as map()*
                {&#xd; let $projects := collection(config:path("projects"))&#xd; let $div :=
                $projects//mets:div[@ID = $x-context]&#xd; let $project-pid :=
                $div/ancestor::mets:mets/@OBJID/xs:string(.),&#xd; $resource-pid := if
                ($div/@TYPE='resource') then $x-context else
                $div/ancestor::mets:div[@TYPE='resource']/xs:string(@ID)&#xd; return&#xd; if
                (exists($div))&#xd; then &#xd; map:new((&#xd;
                map:entry("project-pid",$project-pid),&#xd;
                map:entry("resource-pid",$resource-pid)&#xd; ))&#xd; else ()&#xd; };&#xd; &#xd; (:
                returns 0-n map(s) in the form&#xd; : [&#xd; : ["id" : "abacus2.2_16" ],&#xd; :
                ["operand" : "except" ],&#xd; : ["type" : "resourcefragment" ],&#xd; : ]&#xd;
                :)&#xd; declare function repo-utils:parse-x-context($x-context as xs:string,
                $config) as map()* {&#xd; let $contexts := tokenize($x-context,',')&#xd; let $maps
                := &#xd; for $c at $pos in distinct-values($contexts)&#xd; let $operand := switch
                (true())&#xd; case substring($c,1,1) = "+" return "union"&#xd; case
                substring($c,1,1) = "-" return "except"&#xd; default return "union"&#xd; let $c-id
                := normalize-space(if (substring($c,1,1) = ("+","-")) then substring($c,2) else
                $c)&#xd; let $type := repo-utils:context-to-type($c-id,$config)&#xd; return &#xd; if
                ($type)&#xd; then&#xd; let $log := util:log-app("DEBUG",$config:app-name,"parsing
                x-context '"||$x-context||"' part #"||$pos||" - id: '"||$c-id||"', "||"type:
                '"||$type||"', operand: '"||$operand||"'")&#xd; return &#xd; map:new((&#xd;
                map:entry("operand",$operand),&#xd; map:entry("type",$type),&#xd; switch
                ($type)&#xd; case "resourcefragment" return
                (map:entry("resourcefragment-pid",$c-id),repo-utils:context-to-resource-pid($c-id,$config))&#xd;
                case "resource" return repo-utils:context-to-resource-pid($c-id,$config)&#xd;
                default return map:entry("project-pid",$c-id)&#xd; ))&#xd; else ()&#xd; return
                $maps&#xd; };&#xd; &#xd; (:~&#xd; : returns nodes of the given context, e.g.
                "x-context=abacus2" or "x-context=abacus2.1,abacus2.2".&#xd; : resources or
                fragments *excluded* via x-context ("x-context=abacus2,-abacus2.1") are not filtered
                out&#xd; : here but &#xd; ~:)&#xd; declare function
                repo-utils:context-to-data($x-context as map()*, $config) as item()* {&#xd; let
                $path-expressions := &#xd; for $p at $pos in $x-context &#xd; let $type :=
                map:get($p,'type'),&#xd; $operand := if ($pos=1) then () else "
                "||map:get($p,'operand')||" "&#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$type: '"||$type||"' $operand:
                '"||$operand||"'")&#xd; let $path := &#xd; switch ($type)&#xd; case "project" return
                $operand||"collection('"||project:path($p("project-pid"),"workingcopy")||"')"&#xd;
                case "resource" return
                $operand||"doc('"||resource:path($p("resource-pid"),$p("project-pid"),'workingcopy')||"')"&#xd;
                case "resourcefragment" return " union
                doc('"||resource:path($p("resource-pid"),$p("project-pid"),'workingcopy')||"')"&#xd;
                default return ()&#xd; return $path&#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"constructed data path:
                "||string-join($path-expressions,'')) &#xd; let $data :=
                util:eval(string-join($path-expressions,''))&#xd; return $data &#xd; };&#xd; &#xd;
                &#xd; declare function repo-utils:filter-by-context($data as item()*, $x-context as
                map()+, $config) as item()* { &#xd; if (not(exists($x-context))) &#xd; then
                $data&#xd; else &#xd; let $assertions-by-type := &#xd; map:new(&#xd; for $a in
                $x-context &#xd; group by $assertion-type := map:get($a,'type')&#xd; return
                map:entry($assertion-type,$a)),&#xd; $assertion-types :=
                map:keys($assertions-by-type)&#xd; return&#xd; (: we aggregate the nodes by resource
                and &#xd; apply those assertions that refer to this resource :)&#xd; for $x in
                $data&#xd; group by $r-pid := $x/@cr:resource-pid&#xd; return &#xd; (: get maps that
                directly exclude or include this resource :)&#xd; let $r-map := for $p in
                $assertions-by-type("resource")&#xd; return &#xd; if (map:get($p,'resource-pid') =
                $r-pid)&#xd; then $p &#xd; else ()&#xd; return&#xd; if (not(exists($r-map)) and
                $assertion-types = "resource")&#xd; then ()&#xd; else &#xd; if (some $x in $r-map
                satisfies map:get($x,'operand') = 'except')&#xd; then ()&#xd; else &#xd; (: we
                gather cr:ids of elements in this resource $r-pid &#xd; that are referenced via
                fragment-pids in the x-context,&#xd; and group them as keys in a map.&#xd; [&#xd;
                "exclude": ("cr:id1","cr:id2","cr:id3",...)&#xd; "include":
                ("cr:id4","cr:id5",...)&#xd; ]&#xd; :)&#xd; &#xd; if
                (map:contains($assertions-by-type,"resourcefragment"))&#xd; then &#xd; let
                $rf-assertions-for-current-resource :=
                map:get($assertions-by-type,"resourcefragment")&#xd; let $element-ids-by-operand :=
                &#xd; let $maps := &#xd; for $assertions-by-operand in
                $rf-assertions-for-current-resource&#xd; group by $operand :=
                $assertions-by-operand("operand")&#xd; return&#xd; let $cr-ids:=&#xd; for $a in
                $assertions-by-operand&#xd; return&#xd; if ($a("resource-pid") = $r-pid)&#xd; then
                ltb:dump($a("resourcefragment-pid"),$a("resource-pid"),$a("project-pid"))//data(cr:id)&#xd;
                else ()&#xd; return map:entry($operand,$cr-ids)&#xd; return map:new($maps)&#xd;
                return&#xd; if (exists($element-ids-by-operand("except")))&#xd; then &#xd; if
                (exists($element-ids-by-operand("union")))&#xd; then $x[not(@cr:id =
                $element-ids-by-operand("except"))][@cr:id = $element-ids-by-operand("union")]&#xd;
                else $x[not(@cr:id = $element-ids-by-operand("except"))]&#xd; else &#xd; if
                (exists($element-ids-by-operand("union")))&#xd; then $x[@cr:id =
                $element-ids-by-operand("union")]&#xd; else $x&#xd; else $x&#xd; };&#xd; &#xd; (:
                filters a set of nodes by its project, resource or resourcefragment.&#xd; : the
                'assertion' maps (second parameter) take the following form:&#xd; : map {&#xd; :
                "type" := "resourcefragment",&#xd; : "id" := "abacus2.1_64",&#xd; : "operand" :=
                "exclude"&#xd; : }&#xd; :)&#xd; (:declare function
                repo-utils:filter-by-context($data as item()*, $assertions as map()*, $config) as
                item()* {&#xd; if (count($assertions) eq 0)&#xd; then $data&#xd; else&#xd; let
                $assertions-ordered := for $a in $assertions&#xd; let $type :=
                map:get($a,'type'),&#xd; $order := ("resourcefragment","resource","project")&#xd;
                order by index-of($order,$type)&#xd; return $a&#xd; let $current :=
                $assertions-ordered[1]&#xd; };:)&#xd; &#xd; (:~&#xd; : Retrieves the id of the
                resourcefragment(s) a given element is part of.&#xd; : &#xd; : @param $resource-pid:
                the PID of the resource to be looked into&#xd; : @param $x-elementID: the internal
                cr:id of the element to be looked up&#xd; : @param $project-pid: the
                context/project&#xd; : @param $config: the mets-config of the project &#xd; :
                @return one or more resourcefragment-pids &#xd; ~:)&#xd; declare function
                repo-utils:element-pid-to-resourcefragment-pid($resource-pid as xs:string,
                $x-element-pid as xs:string, $project-pid as xs:string, $config) as xs:string*
                {&#xd; let $tables-path:=$config//param[@key='lookuptable.path']/xs:string(.)&#xd;
                let
                $lookup-table:=repo-utils:get-from-cache($project-pid||"-"||$resource-pid||".xml",$tables-path,$config)&#xd;
                let $fragments:=$lookup-table//fcs:ResourceFragment[cr:id=$x-element-pid]&#xd;
                return $fragments/xs:string(@pid)&#xd; };&#xd; (:&#xd; (\:~ This function returns
                paths to all available resources of the given project by looking at the &#xd; :
                projects struct map.&#xd; : &#xd; : a resource may consist of &#xd; : - a single xml
                instance &#xd; : - multiple fragment instances, which constitute the resource in
                sum&#xd; : &#xd; : Here we only sum up only the the _full_ resources. &#xd; :&#xd; :
                @param $project-pid: The CR-Context&#xd; : @param $config: The mets-config of the
                project&#xd; : @return &#xd; ~:\)&#xd; declare function
                repo-utils:resources-in-project($project-pid as xs:string, $config) {&#xd; let
                $projectResources:=project:resources($config//mets:mets)&#xd; return &#xd; for $d in
                $projectResources return&#xd; if ($d/mets:fptr/@FILEID) &#xd; then &#xd; let
                $resource-pid := xs:string($d/@ID) &#xd; let
                $fileID:=xs:string($d/mets:fptr/@FILEID)&#xd; let $file:=$config//mets:file[@ID eq
                $fileID]&#xd; return &#xd; if (doc-available($file/mets:FLocat/@xlink:href))&#xd;
                then &#xd; map{&#xd; "resource-pid" := $resource-pid,&#xd; "content" :=
                doc($file/mets:FLocat/@xlink:href)&#xd; }&#xd; else util:log("INFO","document
                "||$file||" not available")&#xd; else ()&#xd; };:)&#xd; &#xd; declare function
                repo-utils:fileuri-to-resource-pid($filepath as xs:string, $project-pid as
                xs:string, $config) as xs:string? {&#xd; let
                $fileID:=$config//mets:file[mets:FLocat/@xlink:href eq $filepath]/@ID&#xd; return
                $config//mets:div[@TYPE='resource' and mets:fptr/@FILEID eq $fileID]/xs:string(@ID)
                &#xd; };&#xd; &#xd; (:~ Get the resource by PID/handle/URL or some known
                identifier.&#xd; TODO: NOT ADAPTED YET! (taken from CMD)&#xd; TODO: be clear about
                resource itself and metadata-record!&#xd; :)&#xd; (:declare function
                repo-utils:get-resource-by-id($id as xs:string) as node()* {&#xd; let $collection :=
                collection($cr:dataPath)&#xd; return &#xd; if ($id eq "" or $id eq
                $cr:collectionRoot) then&#xd; $collection//IsPartOf[. =
                $cr:collectionRoot]/ancestor::CMD&#xd; else&#xd;
                util:eval(concat("$collection/ft:query(descendant::MdSelfLink, &lt;term&gt;",
                xdb:decode($id), "&lt;/term&gt;)/ancestor::CMD"))&#xd; (\:
                $collection/descendant::MdSelfLink[. = xdb:decode($id)]/ancestor::CMD :\)&#xd;
                };&#xd; :)&#xd; &#xd; (:~ Checks whether the document is available or not.&#xd;
                generic, currently not used&#xd; :)&#xd; declare function
                repo-utils:is-doc-available($collection as xs:string, $doc-name as xs:string) as
                xs:boolean {&#xd; fn:doc-available(fn:concat($collection, "/", $doc-name))&#xd;
                };&#xd; &#xd; declare function repo-utils:is-in-cache($doc-name as
                xs:string,$config) as xs:boolean {&#xd; repo-utils:is-in-cache($doc-name,$config,
                'indexes') &#xd; };&#xd; &#xd; declare function repo-utils:is-in-cache($doc-name as
                xs:string,$config, $type as xs:string) as xs:boolean {&#xd; let $project-pid :=
                config:param-value($config,'project-pid'),&#xd; $cache-path :=
                project:path($project-pid, $type) &#xd; return
                fn:doc-available($cache-path||"/"||$doc-name)&#xd; };&#xd; &#xd; &#xd; declare
                function repo-utils:get-from-cache($doc-name as xs:string,$config) as item()* {&#xd;
                repo-utils:get-from-cache($doc-name, $config, 'indexes') &#xd; };&#xd; &#xd; declare
                function repo-utils:get-from-cache($doc-name as xs:string,$config, $type) as item()*
                {&#xd; let $project-pid := config:param-value($config,'project-pid'),&#xd;
                $cache-path := project:path($project-pid, $type)&#xd; let $path :=
                fn:concat($cache-path, "/", $doc-name)&#xd; return if
                (util:is-binary-doc($path))&#xd; then util:binary-doc($path)&#xd; else
                fn:doc($path)&#xd; };&#xd; &#xd; (:&#xd; This seems weird - TO BE DEPRECATED&#xd;
                declare function repo-utils:get-from-cache($doc-name as xs:string,$path,$config) as
                item()* {&#xd; if (util:is-binary-doc($path))&#xd; then util:binary-doc($path)&#xd;
                else fn:doc($path)&#xd; };&#xd; :)&#xd; (:~ &#xd; : Store the data in Cache, which
                is set in the parameter "cache.path" in the config. &#xd; : The function uses its
                own writer-account. &#xd; : &#xd; : @param $doc-name: the filename of the resource
                to create/update.&#xd; : @param $data: the data to store&#xd; : @param $config: the
                config for the current project &#xd; &#xd; ~:)&#xd; declare function
                repo-utils:store-in-cache($doc-name as xs:string, $data as node(),$config) as
                item()* { &#xd; repo-utils:store-in-cache($doc-name,$data,$config,'indexes')&#xd;
                };&#xd; &#xd; (:~ &#xd; : Store the data in Cache to the specified collection. &#xd;
                : The function uses its own writer-account. &#xd; : if the file exists, it will be
                overwritten&#xd; &#xd; : instead of sending the cache-collection, the correct path
                is established based on project-context and $type &#xd; : @param $doc-name: the
                filename of the resource to create/update.&#xd; &#xd; : @param $data: the data to
                store&#xd; : @param $config: the config for the current project&#xd; : @param $type:
                type of cache&#xd; &#xd; ~:)&#xd; declare function
                repo-utils:store-in-cache($doc-name as xs:string, $data as node(),$config,$type) as
                item()* {&#xd; let $project-pid := config:param-value($config,'project-pid'),&#xd;
                $cache-path := project:path($project-pid, $type),&#xd; $writer :=
                fn:doc(config:path('writer.file')),&#xd; $writer-name :=
                $writer//write-user/text(),&#xd; $writer-pw := $writer//write-user-cred/text()&#xd;
                let $log := util:log-app("INFO","cr-xq",config:path('writer.file'))&#xd; return
                system:as-user($writer-name, $writer-pw,&#xd; let $mkcol := if
                (xmldb:collection-available($cache-path))&#xd; then ()&#xd; else
                local:mkcol-recursive(tokenize($cache-path,'/')[1],tokenize($cache-path,'/')[position()
                gt 1]),&#xd; &#xd; $rem :=if (util:is-binary-doc(concat($cache-path, $doc-name)))
                then&#xd; xdb:remove($cache-path, $doc-name)&#xd; else if
                (doc-available(concat($cache-path, $doc-name))) &#xd; then xdb:remove($cache-path,
                $doc-name) &#xd; else (),&#xd; &#xd; $store := try { xdb:store($cache-path,
                $doc-name, $data)&#xd; } catch * {&#xd; let $msg := "problem storing "||$doc-name||"
                to "||$cache-path&#xd; let $dummy-log := util:log-app("ERROR", $config:app-name,
                $msg)&#xd; return diag:diagnostics("general-error", $msg )&#xd; }, &#xd; $stored-doc
                := &#xd; if (util:is-binary-doc(concat($cache-path, "/", $doc-name))) &#xd; then
                util:binary-doc(concat($cache-path, "/", $doc-name))&#xd; else
                fn:doc(concat($cache-path, "/", $doc-name))&#xd; return $stored-doc&#xd; )&#xd;
                };&#xd; &#xd; &#xd; (: &#xd; this tries to create sub-collections in index for&#xd;
                individual data-collection - but it makes the retrieval etc. also more complicated
                &#xd; so rather encoding the data-collection also in the name &#xd; &#xd; declare
                function repo-utils:store-in-cache($data-collection as item(), $doc-name as
                xs:string, $data as node()) as item()* {&#xd; let $data-coll-name :=
                collection-name($data-collection) &#xd; let $index-coll-path :=
                concat($repo-utils:cachePath, "/", $data-coll-name )&#xd; let $create-coll := if
                (not(xmldb:collection-available($index-coll-path ))) then &#xd;
                xmldb:create-collection($repo-utils:cachePath, $data-collname) else ()&#xd; let
                $store-result := repo-utils:store($index-coll-path, $doc-name, $data, true())&#xd;
                &#xd; return $store-result&#xd; };&#xd; :)&#xd; &#xd; (:~ Store the data somewhere
                (in $collection)&#xd; checks for logged in user and only tries to use the internal
                writer, if no user logged in.&#xd; :)&#xd; (:&lt;options&gt;&lt;option
                key="update"&gt;yes&lt;/option&gt;&lt;/options&gt;:)&#xd; declare function
                repo-utils:store($collection as xs:string, $doc-name as xs:string, $data as node(),
                $overwrite as xs:boolean, $config) as item()* {&#xd; let $log :=
                util:log-app("INFO",$config:app-name,"repo-util:store($collection:"||$collection||",$doc-name:"||$doc-name||")")&#xd;
                let $writer := fn:doc(config:path('writer.file'))(:,&#xd; $dummy := if
                (request:get-attribute("org.exist.demo.login.user")='') then&#xd;
                xdb:login($collection, $writer//write-user/text(),
                $writer//write-user-cred/text())&#xd; else () :)&#xd; &#xd; (: let $rem := if
                ($overwrite and doc-available(concat($collection, $doc-name))) then
                xdb:remove($collection, $doc-name) else () :)&#xd; &#xd; let $mkcol := if
                (xmldb:collection-available($collection))&#xd; then ()&#xd; else
                repo-utils:mkcol("/", $collection)&#xd; &#xd; let $rem :=if
                (util:is-binary-doc(concat($collection, $doc-name)) and $overwrite) then&#xd;
                xdb:remove($collection, $doc-name)&#xd; else if ($overwrite and
                doc-available(concat($collection, $doc-name))) &#xd; then xdb:remove($collection,
                $doc-name) &#xd; else ()&#xd; &#xd; let $store := (:
                util:catch("org.exist.xquery.XPathException", :) xdb:store($collection, $doc-name,
                $data), &#xd; $stored-doc := if (util:is-binary-doc(concat($collection, "/",
                $doc-name))) then util:binary-doc(concat($collection, "/", $doc-name)) else
                fn:doc(concat($collection, "/", $doc-name))&#xd; return $stored-doc&#xd; &#xd;
                };&#xd; &#xd; &#xd; declare function repo-utils:gen-cache-id($type-name as
                xs:string, $keys as xs:string+, $depth as xs:string) as xs:string { &#xd;
                repo-utils:gen-cache-id($type-name , ($keys, $depth) )&#xd; }; &#xd; (:~ Create
                document name with md5-hash for selected collections (or types) for reuse.&#xd;
                :)&#xd; declare function repo-utils:gen-cache-id($type-name as xs:string, $keys as
                xs:string+) as xs:string { &#xd; let $sanitized-names := for $key in $keys return
                repo-utils:sanitize-name($key)&#xd; return&#xd; (: fn:concat($name-prefix, "-",
                util:hash(string-join($sorted-names, ""), "MD5"), $repo-utils:xmlExt):)&#xd;
                fn:concat($type-name, "-", string-join($sanitized-names, "-"),
                $repo-utils:xmlExt)&#xd; };&#xd; &#xd; (:~ wipes out problematic characters from
                names&#xd; :)&#xd; declare function repo-utils:sanitize-name($name as xs:string) as
                xs:string {&#xd; translate($name, ":/",'_')&#xd; };&#xd; &#xd; declare function
                repo-utils:serialise-as($item as node()?, $format as xs:string, $operation as
                xs:string, $config) as item()? {&#xd; repo-utils:serialise-as($item, $format,
                $operation, $config, ())&#xd; };&#xd; &#xd; (:~ &#xd; : Generic formating function
                which transforms results into the following formats, according to the function's 2nd
                parameter.&#xd; :&#xd; : Currently implemented formats are: &#xd; : &lt;ul&gt;&#xd;
                : &lt;li&gt;JSON&lt;/li&gt;&#xd; : &lt;li&gt;HTML (fragment or full
                page)&lt;/li&gt;&#xd; : &lt;li&gt;XML (default)&lt;/li&gt;&#xd; : &lt;/ul&gt;&#xd; :
                &#xd; : Possible names for each format are defined in the following module
                variables:&#xd; : @see $repo-utils:responseFormatXml&#xd; : @see
                $repo-utils:responseFormatJSon&#xd; : @see $repo-utils:responseFormatText&#xd; :
                @see $repo-utils:responseFormatHTML&#xd; : @see
                $repo-utils:responseFormatHTMLpage&#xd; : &#xd; : @param $item the data to be
                output&#xd; : @param $format the output format &#xd; : @param $parameters optional
                additional parameters to be passed to xsl &#xd; ~:)&#xd; declare function
                repo-utils:serialise-as($item as node()?, $format as xs:string, $operation as
                xs:string, $config, $parameters as node()* ) as item()? {&#xd; (: FIXME: empty
                x-context macht wenig sinn!! :) &#xd; repo-utils:serialise-as($item, $format,
                $operation, $config, '', $parameters)&#xd; };&#xd; declare function
                repo-utils:serialise-as($item as node()?, $format as xs:string, $operation as
                xs:string, $config, $x-context as xs:string, $parameters as node()* ) as item()?
                {&#xd; switch(true())&#xd; case ($format eq $repo-utils:responseFormatJSon) return
                &#xd; let $xslDoc := repo-utils:xsl-doc($operation, $format, $config),&#xd;
                $xslParams:= &lt;parameters&gt;&#xd; &lt;param name="format"
                value="{$format}"/&gt;&#xd; &lt;param name="x-context"
                value="{$x-context}"/&gt;&#xd; &lt;param name="base_url"
                value="{config:param-value($config,'base-url')}"/&gt;&#xd; &lt;param
                name="mappings-file" value="{config:param-value($config, 'mappings')}"/&gt;&#xd;
                &lt;param name="scripts_url" value="{config:param-value($config,
                'scripts.url')}"/&gt;&#xd; &lt;param name="site_name"
                value="{config:param-value($config, 'site.name')}"/&gt;&#xd; &lt;param
                name="site_logo" value="{config:param-value($config, 'site.logo')}"/&gt;&#xd;
                {$parameters/param}&#xd; &lt;/parameters&gt;&#xd; let $res := if ($xslDoc) &#xd;
                then&#xd; let $option := util:declare-option("exist:serialize", "method=text
                media-type=application/json")&#xd; return
                transform:transform($item,$xslDoc,$xslParams)&#xd; else &#xd; let $option :=
                util:declare-option("exist:serialize", "method=json media-type=application/json")
                &#xd; return $item&#xd; return $res&#xd; &#xd; case (contains($format,
                $repo-utils:responseFormatHTML)) return&#xd; let $xslDoc :=
                repo-utils:xsl-doc($operation, $format, $config),&#xd; $xslParams:=
                &lt;parameters&gt;&#xd; &lt;param name="format" value="{$format}"/&gt;&#xd;
                &lt;param name="operation" value="{$operation}"/&gt;&#xd; &lt;param name="x-context"
                value="{$x-context}"/&gt;&#xd; &lt;param name="resource-id"
                value="{config:param-value($config, 'resource-pid')}"/&gt;&#xd; &lt;param
                name="base_url"
                value="{config:param-value($config,'public-repo-baseurl')}"/&gt;&#xd; &lt;param
                name="mappings-file" value="{config:param-value($config, 'mappings')}"/&gt;&#xd;
                &lt;param name="scripts_url" value="{concat(config:param-value($config,
                'base-url'),config:param-value($config, 'scripts-url'))}"/&gt;&#xd; &lt;param
                name="site_name" value="{config:param-value($config, 'site-name')}"/&gt;&#xd;
                &lt;param name="site_logo" value="{concat(config:param-value($config,
                'base-url'),config:param-value($config, 'site-logo'))}"/&gt;&#xd; &lt;param
                name="site_url" value="{config:param-value($config, 'public-baseurl')}"/&gt;&#xd;
                {$parameters/param}&#xd; &lt;/parameters&gt;&#xd; (: &lt;param name="base_url"
                value="{config:param-value($config,'base-url')}"/&gt;:)&#xd; let $res := if
                (exists($xslDoc)) &#xd; then transform:transform($item,$xslDoc, $xslParams)&#xd;
                else &#xd; let $log:=util:log-app("ERROR", $config:app-name,
                "repo-utils:serialise-as() could not find stylesheet '"||$xslDoc||"' for $operation:
                "||$operation||", $format: "||$format||".")&#xd; return
                diag:diagnostics("unsupported-param-value",concat('$operation: ', $operation, ',
                $format: ', $format))&#xd; let $option := util:declare-option("exist:serialize",
                "method=xhtml media-type=text/html")&#xd; return $res&#xd; default return&#xd; let
                $option := util:declare-option("exist:serialize", "method=xml
                media-type=application/xml")&#xd; return $item&#xd; };&#xd; &#xd; &#xd; (:~&#xd; :
                Getter function for output formatting stylesheets: returns an document node() with
                the appropriate stylesheet&#xd; : given the current operation ($operation) and the
                desired output format ($format).&#xd; : &#xd; : It tries to determine the best
                fitting XSL file by looking in any db collection mentioned &#xd; : in any
                &lt;code&gt;param key='scripts.path'&lt;/code&gt; in $config (this includes project
                configs as well as module configs). &#xd; : In there tries to fetch files witch are
                mentioned in any config param named &#xd; : &lt;ul&gt;&#xd; :
                &lt;li&gt;'$operation-$format.xsl' or &lt;/li&gt;&#xd; : &lt;li&gt;'$operation.xsl'
                or &lt;/li&gt;&#xd; : &lt;ul&gt;&#xd; : &#xd; : It returns the
                &lt;b&gt;first&lt;/b&gt; document in the resulting sequence.&#xd; :&#xd; : &#xd; :
                @param $operation the operation which produced the result to be output. (no
                restriction)&#xd; : @param $format the name of the desired output format&#xd; :
                @param $config the global configuration map.&#xd; : @return zero or one XSL
                documents &#xd; ~:)&#xd; declare function repo-utils:xsl-doc($operation as
                xs:string, $format as xs:string, $config) as document-node()? { &#xd; let
                $scripts-paths := config:path('scripts'),&#xd; $xsldoc := for $scripts-path in
                $scripts-paths&#xd; return &#xd; let $operation-format-xsl:=
                $scripts-path||'/'||config:param-value($config,
                $operation||'-'||$format||".xsl"),&#xd; $operation-xsl:=
                $scripts-path||'/'||config:param-value($config, $operation||".xsl")&#xd; return
                &#xd; switch(true())&#xd; case (doc-available($operation-format-xsl)) return
                doc($operation-format-xsl)&#xd; case (doc-available($operation-xsl)) return
                doc($operation-xsl)&#xd; default return ()&#xd; return ($xsldoc)[1]&#xd; };&#xd;
                &#xd; (:~ helper function. Performs multiple replacements, using pairs of replace
                parameters. based on standard xpath2 function replace() &#xd; taken from:
                http://www.xqueryfunctions.com/xq/functx_replace-multi.html&#xd; :)&#xd; declare
                function repo-utils:replace-multi ( $arg as xs:string? , $changeFrom as xs:string* ,
                $changeTo as xs:string* ) as xs:string? {&#xd; &#xd; if (count($changeFrom) &gt;
                0)&#xd; then repo-utils:replace-multi(&#xd; replace($arg, $changeFrom[1],&#xd;
                repo-utils:if-absent($changeTo[1],'')),&#xd; $changeFrom[position() &gt; 1],&#xd;
                $changeTo[position() &gt; 1])&#xd; else $arg&#xd; } ;&#xd; &#xd; (:~ used by
                replace-multi()&#xd; taken from:
                http://www.xqueryfunctions.com/xq/functx_if-absent.html&#xd; :)&#xd; declare
                function repo-utils:if-absent ( $arg as item()* , $value as item()* ) as item()*
                {&#xd; if (exists($arg)) then $arg else $value&#xd; } ;&#xd; &#xd; &#xd; (: Helper
                function to recursively create a collection hierarchy. &#xd; xmldb:create-collection
                actually obviously can do this - no need for recursive call (anymore?) :)&#xd;
                declare function repo-utils:mkcol($collection as xs:string, $path as xs:string)
                {&#xd; try {&#xd; xmldb:create-collection($collection, $path)&#xd; } catch * {&#xd;
                let $log := util:log-app("ERROR",$config:app-name, "Could not create collection
                "||$path||" in collection "||$collection||". "||string-join(($err:code ,
                $err:description, $err:value),' - ') )&#xd; return ()&#xd; }&#xd; &#xd; (:
                local:mkcol-recursive($collection, tokenize($path, "/")):)&#xd; };&#xd; &#xd;
                (:~&#xd; OBSOLETED by xmldb:create-collection()&#xd; :)&#xd; declare function
                local:mkcol-recursive($collection, $components) {&#xd; if (exists($components) and
                exists($collection)) &#xd; then&#xd; let $newColl := concat($collection, "/",
                $components[1])&#xd; return (&#xd; xdb:create-collection($collection,
                $components[1]),&#xd; local:mkcol-recursive($newColl, subsequence($components,
                2))&#xd; )&#xd; else ()&#xd; };&#xd; &#xd; &#xd; (:declare function
                repo-utils:get-record-pid($reference) as xs:string? {&#xd;
                typeswitch($reference)&#xd; case xs:string return $reference&#xd; case text() return
                $reference&#xd; case attribute(OBJID) return
                $reference/parent::mets:mets/xs:string(@OBJID)&#xd; case attribute(ID) return
                $reference/parent::mets:div/xs:string(@ID)&#xd; case element(mets:mets) return
                $reference/xs:string(@OBJID)&#xd; case element(mets:div) return
                $reference/xs:string(@ID)&#xd; case document-node() return
                $reference/mets:mets/xs:string(@OBJID)&#xd; default return ()&#xd; }; &#xd; &#xd;
                &#xd; (\:~ Returns the METS record of a project or resource, regardless of what
                &#xd; : kind of reference (project-pid string, text(), @OBJID, is passed to the
                function.&#xd; : This allows us to pass either a project-pid, resource-pid or their
                resolved records in&#xd; : function definitions.&#xd; : @param $reference any item
                with relation to a resource or a mets record (elements like mets:div, mets:mets,
                PIDs, document-nodes etc.)&#xd; :\)&#xd; declare function
                repo-utils:get-record($reference) as element()? {&#xd; typeswitch($reference)&#xd;
                case xs:string return
                (project:get($reference),collection(config:path("projects"))//mets:div[@ID =
                $reference])[1]&#xd; case text() return
                (project:get($reference),collection(config:path("projects"))//mets:div[@ID =
                $reference])[1]&#xd; case attribute(OBJID) return project:get($reference)&#xd; case
                attribute(ID) return collection(config:path("projects"))//mets:div[@ID =
                $reference]&#xd; case element(mets:mets) return $reference&#xd; case
                element(mets:div) return $reference&#xd; case document-node() return
                $reference/*&#xd; default return ()&#xd; }; &#xd; :)&#xd; &#xd; &#xd; &#xd; declare
                function repo-utils:get-record-pid($reference-param) as xs:string? {&#xd; for
                $reference in $reference-param return &#xd; typeswitch($reference)&#xd; case
                xs:string return &#xd; let $log := util:log-app("DEBUG",$config:app-name,"$reference
                is xs:string '"||$reference||"'.")&#xd; return $reference&#xd; &#xd; case text()
                return &#xd; let $log := util:log-app("DEBUG",$config:app-name,"$reference is text()
                '"||$reference||"'.")&#xd; return $reference&#xd; &#xd; case attribute(OBJID) return
                &#xd; let $log := util:log-app("DEBUG",$config:app-name,"$reference is @OBJID
                '"||$reference||"'.")&#xd; return
                $reference/parent::mets:mets/xs:string(@OBJID)&#xd; &#xd; case attribute(ID) return
                &#xd; let $log := util:log-app("DEBUG",$config:app-name,"$reference is @ID
                '"||$reference||"'.")&#xd; return $reference/parent::mets:div/xs:string(@ID)&#xd;
                &#xd; case element(mets:mets) return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is &lt;mets:mets
                OBJID='"||$reference/@OBJID||"'/&gt;.")&#xd; return
                $reference/xs:string(@OBJID)&#xd; &#xd; case element(mets:div) return&#xd; let $log
                := util:log-app("DEBUG",$config:app-name,"$reference is &lt;mets:div
                ID='"||$reference/@ ID||"'/&gt;.")&#xd; return $reference/xs:string(@ID)&#xd; &#xd;
                case document-node() return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is
                document-node()/"||$reference/local-name(*)||".")&#xd; return
                ($reference/mets:mets/xs:string(@OBJID),$reference/mets:div/xs:string(@ID))[1]&#xd;
                &#xd; default return ()&#xd; }; &#xd; &#xd; &#xd; (:~ Returns the METS record of a
                project or resource, regardless of what &#xd; : kind of reference (project-pid
                string, text(), @OBJID, is passed to the function.&#xd; : This allows us to pass
                either a project-pid, resource-pid or their resolved records in&#xd; : function
                definitions.&#xd; : @param $reference any item with relation to a resource or a mets
                record (elements like mets:div, mets:mets, PIDs, document-nodes etc.)&#xd; :)&#xd;
                declare function repo-utils:get-record($reference-param) as element()? {&#xd; let
                $references-resolved := &#xd; for $reference in $reference-param return &#xd;
                typeswitch($reference)&#xd; case xs:string return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is xs:string
                '"||$reference||"'.")&#xd; return
                (project:get($reference),collection(config:path("projects"))//mets:div[@ID =
                $reference])[1]&#xd; &#xd; case text() return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is text()
                '"||$reference||"'.")&#xd; return
                (project:get($reference),collection(config:path("projects"))//mets:div[@ID =
                $reference])[1]&#xd; &#xd; case attribute(OBJID) return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is @OBJID
                '"||$reference||"'.")&#xd; return project:get($reference)&#xd; &#xd; case
                attribute(ID) return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is @ID '"||$reference||"'.")&#xd;
                return collection(config:path("projects"))//mets:div[@ID = $reference]&#xd; &#xd;
                case element(mets:mets) return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is &lt;mets:mets
                OBJID='"||$reference/@OBJID||"'/&gt;.")&#xd; return $reference&#xd; &#xd; case
                element(mets:div) return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is &lt;mets:div
                ID='"||$reference/@ ID||"'/&gt;.")&#xd; return $reference&#xd; &#xd; case
                document-node() return &#xd; let $log :=
                util:log-app("DEBUG",$config:app-name,"$reference is
                document-node()/"||$reference/local-name(*)||".")&#xd; return
                ($reference/mets:mets,$reference/mets:div)[1]&#xd; &#xd; default return ()&#xd;
                return $references-resolved&#xd; }; </f>
            <f n="resource.xqm">xquery version "3.0"; module namespace
                resource="http://aac.ac.at/content_repository/resource"; import module namespace
                repo-utils = "http://aac.ac.at/content_repository/utils" at "repo-utils.xqm"; import
                module namespace config="http://exist-db.org/xquery/apps/config" at "config.xqm";
                (:import module namespace master = "http://aac.ac.at/content_repository/master" at
                "master.xqm";:) import module namespace project =
                "http://aac.ac.at/content_repository/project" at "project.xqm"; import module
                namespace handle = "http://aac.ac.at/content_repository/handle" at
                "../modules/resource/handle.xqm"; import module namespace toc =
                "http://aac.ac.at/content_repository/toc" at "toc.xqm"; import module namespace rf =
                "http://aac.ac.at/content_repository/resourcefragment" at "resourcefragment.xqm";
                import module namespace wc="http://aac.ac.at/content_repository/workingcopy" at
                "wc.xqm"; import module namespace lt =
                "http://aac.ac.at/content_repository/lookuptable" at "lookuptable.xqm"; import
                module namespace facs = "http://aac.ac.at/content_repository/facs" at "facs.xqm";
                declare namespace mets="http://www.loc.gov/METS/"; declare namespace
                xlink="http://www.w3.org/1999/xlink"; declare namespace fcs =
                "http://clarin.eu/fcs/1.0"; declare namespace
                cr="http://aac.ac.at/content_repository"; declare namespace
                cmd="http://www.clarin.eu/cmd/"; declare namespace
                oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/"; (: declaration of helper
                namespaces for better code structuring :) declare namespace
                param="userinput.parameters"; declare namespace this="current.object"; declare
                variable $resource:mdtypes :=
                ("MARC","MODS","EAD","DC","NISOIMG","LC-AV","VRA","TEIHDR","DDI","FGDC","LOM","PREMIS","PREMIS:OBJECT","PREMIS:AGENT","PREMIS:RIGHTS","PREMIS:EVENT","TEXTMD","METSRIGHTS","ISO
                19115:2003 NAP","OTHER"); declare variable $resource:othermdtypes := ("CMDI");
                declare function resource:make-file($fileid as xs:string, $filepath as xs:string,
                $type as xs:string) as element(mets:file) { let $USE:= switch($type) case
                "workingcopy" return $config:RESOURCE_WORKINGCOPY_FILE_USE case "wc" return
                $config:RESOURCE_WORKINGCOPY_FILE_USE case "resourcefragments" return
                $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE case "fragments" return
                $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE case "lookuptable" return
                $config:RESOURCE_LOOKUPTABLE_FILE_USE case "orig" return
                $config:RESOURCE_MASTER_FILE_USE case "master" return
                $config:RESOURCE_MASTER_FILE_USE default return () return if ($USE!='') then
                &lt;mets:file ID="{$fileid}" MIMETYPE="application/xml" USE="{$USE}"&gt;
                &lt;mets:FLocat LOCTYPE="URL" xlink:href="{$filepath}"/&gt; &lt;/mets:file&gt; else
                () }; (:~We might want to transform a resource's master document before indexing,
                extracting fragments etc. : This can be done by overing the transform templates of
                the working stylesheet. This function sets the : path of a XSL file with those
                templates. ~:) declare function resource:set-preprocess-xsl-path($path as xs:string,
                $resource-pid as xs:string, $project-pid as xs:string) as empty() { let $project:=
                project:get($project-pid), $current-path :=
                resource:get-preprocess-xsl-path($resource-pid,$project-pid),
                $behavior-by-current-path := $project//mets:behavior[mets:mechanism/@xlink:href =
                $current-path][@BTYPE = $wc:behavior-btype], $behavior-by-new-path :=
                $project//mets:behavior[mets:mechanism/@xlink:href = $path][@BTYPE =
                $wc:behavior-btype], $behaviorSec := $project//mets:behaviorSec return if
                ($current-path = "") then (:check whether there exists a new behavior element with
                the path to be set :) if (exists($behavior-by-new-path)) (: if yes, then just add
                the $resource-pid to the parent::behavior's @STRUCTID attribute :) then let
                $structID := $behavior-by-new-path/@STRUCTID return update value $structID with
                $structID||" "||$resource-pid (: otherwise check if there's a behaviorSec in the
                mets record :) else let $behaviorSec := $project//mets:behaviorSec, $new-behaviour
                := &lt;mets:behavior BTYPE="{$wc:behavior-btype}" STRUCTID="{$resource-pid}"&gt;
                &lt;mets:mechanism LOCTYPE="URL" xlink:href="{$path}"/&gt; &lt;/mets:behavior&gt;
                return if (exists($behaviorSec)) then update insert $new-behaviour into $behaviorSec
                else update insert &lt;mets:behaviorSec&gt;{$new-behaviour}&lt;/mets:behaviorSec&gt;
                into $project else if ($current-path eq $path) then () else (:check whether there
                exists a new behavior element with the path to be set :) if
                (exists($behavior-by-new-path)) then (: if yes, then just add the $resource-pid to
                the parent::behavior's @STRUCTID attribute ... :) let $structID :=
                $behavior-by-new-path/@STRUCTID let $rm-current :=
                resource:remove-preprocess-xsl-path($resource-pid,$project-pid) return update value
                $structID with $structID||" "||$resource-pid else (: check whether the current
                behavior element is shared with other resources :) if
                ($behavior-by-current-path/@STRUCTID eq $resource-pid) then update value
                $behavior-by-current-path/mets:mechanism/@xlink:href with $path else let
                $rm-current-behavior :=
                resource:remove-preprocess-xsl-path($resource-pid,$project-pid) let $new-behavior :=
                &lt;mets:behavior BTYPE="{$wc:behavior-btype}" STRUCTID="{$resource-pid}"&gt;
                &lt;mets:mechanism LOCTYPE="URL" xlink:href="{$path}"/&gt; &lt;/mets:behavior&gt;
                return if (exists($behaviorSec)) then update insert $new-behavior into $behaviorSec
                else update insert &lt;mets:behaviorSec&gt;{$new-behavior}&lt;/mets:behaviorSec&gt;
                into $project }; (: removes the resource's PID from the list of PIDs to be
                pre-processed by the preprocess XSL stylesheet. :) declare function
                resource:remove-preprocess-xsl-path($resource-pid as xs:string, $project-pid as
                xs:string) as empty() { let $project:= project:get($project-pid), $current-path :=
                resource:get-preprocess-xsl-path($resource-pid,$project-pid),
                $behavior-by-current-path := $project//mets:behavior[mets:mechanism/@xlink:href =
                $current-path][@BTYPE = $wc:behavior-btype] return if
                ($behavior-by-current-path/@STRUCTID eq $resource-pid) then if
                (count($behavior-by-current-path/parent::*/*) eq 1) then update delete
                $behavior-by-current-path/parent::* else update delete $behavior-by-current-path
                else update value $behavior-by-current-path/@STRUCTID with
                string-join(tokenize($behavior-by-current-path/@STRUCTID,'\s+')[. ne
                $resource-pid],' ') }; declare function
                resource:get-preprocess-xsl-path($resource-pid as xs:string, $project-pid as
                xs:string) as xs:string? { let $project:= project:get($project-pid) let
                $xsl-behavior := $project//mets:behavior[@BTYPE = $wc:behavior-btype][some $x in
                tokenize(@STRUCTID,'\s') satisfies $x eq $resource-pid] return
                $xsl-behavior/mets:mechanism/xs:string(@xlink:href) }; declare function
                resource:purge($resource-pid as xs:string, $project-pid as xs:string) as empty() {
                resource:purge($resource-pid,$project-pid,()) }; declare function
                resource:purge($resource-pid as xs:string, $project-pid as xs:string, $delete-data
                as xs:boolean*) as empty() { let $log :=
                util:log-app("INFO",$config:app-name,"Purging resource "||$resource-pid||" (project
                "||$project-pid||")") let $files := resource:files($resource-pid,$project-pid) let
                $remove-data := if ($delete-data) then for $f in
                $files//mets:file/mets:FLocat/xs:string(@xlink:href) return let $filename:=
                tokenize($f,"/")[last()], $path := substring-before($f,"/"||$filename) return try {
                (xmldb:remove($path,$filename),util:log-app("INFO",$config:app-name,"removing
                "||$filename||" at "||$path)) } catch * { () } else () let $remove-prep-xsl-path :=
                resource:remove-preprocess-xsl-path($resource-pid,$project-pid) let $remove-files :=
                update delete $files let $remove-div := update delete
                resource:get($resource-pid,$project-pid) let $log :=
                util:log-app("INFO",$config:app-name,"deleting mets:files and mets:div for
                "||$resource-pid||" (project "||$project-pid||")") return () }; declare function
                resource:generate-pid($project-pid as xs:string) as xs:string{
                resource:generate-pid($project-pid,'') }; declare function
                resource:generate-pid($project-pid as xs:string, $random-seed as xs:string?) as
                xs:string { let $project:= project:get($project-pid), $r-pids:=
                $project//mets:div[@TYPE eq $config:PROJECT_RESOURCE_DIV_TYPE]/@ID, $try-newpid :=
                count($r-pids) + 1., $this:pid := $project-pid||"."||$try-newpid||$random-seed
                return if ($this:pid = $r-pids) then
                resource:generate-pid($project-pid,substring(util:uuid($random-seed),1,4)) else
                $this:pid }; declare function resource:new-with-label($data as document-node(),
                $project-pid as xs:string, $resource-label as xs:string*) { let $log :=
                util:log-app("INFO",$config:app-name, "*** UPLOADED DATA ***") (: let $log :=
                util:log-app("INFO",$config:app-name,$data/*):) let $log :=
                util:log-app("INFO",$config:app-name,"$resource-label: "||$resource-label) let $log
                := util:log-app("INFO",$config:app-name,"$user: "||xmldb:get-current-user()) let
                $resource-pid := resource:new($data,$project-pid, ()), $set-label :=
                resource:label(document
                {&lt;cr:data&gt;{$resource-label}&lt;/cr:data&gt;},$resource-pid,$project-pid)
                return $resource-pid }; declare function resource:new($data as document-node(),
                $project-pid as xs:string){ resource:new($data,$project-pid,()) }; (:~ : Stores the
                Registers the master of a stored resource permanently with a given project and
                returns : its generated resource-pid. Returns the ID and issues a log entry, if :
                the resource is already registered in the METS record; returns the empty sequence, :
                if the resource is not available or a binary file. : : This does not generate a
                working copy, resource-fragment-extracts : or lookup-tables. : : @param $data: the
                content of the new resource : @param $project-pid: the id of the cr-project :
                @return the resource-pid of the created resource ~:) declare function
                resource:new($data as document-node(), $project-pid as xs:string, $make-fragments as
                xs:boolean*) as xs:string? { let $mets:record := project:get($project-pid),
                $mets:projectData :=
                $mets:record//mets:fileGrp[@ID=$config:PROJECT_DATA_FILEGRP_ID], $mets:structMap :=
                $mets:record//mets:structMap[@TYPE=$config:PROJECT_STRUCTMAP_TYPE and
                @ID=$config:PROJECT_STRUCTMAP_ID], $this:resource-pid :=
                resource:generate-pid($project-pid) return switch (true()) case
                (not(exists($mets:record))) return util:log-app("INFO",$config:app-name,"no
                METS-Record found in config") case (not(exists($mets:projectData))) return
                util:log-app("INFO",$config:app-name,"project data not found in mets-record for
                project "||$project-pid) default return let $master_filepath :=
                resource:master($data, $this:resource-pid, $project-pid) return if ($master_filepath
                ne '') then let $this:fileGrp:= &lt;mets:fileGrp
                ID="{$this:resource-pid||$config:PROJECT_RESOURCE_FILEGRP_SUFFIX}"
                USE="{$config:PROJECT_RESOURCE_FILEGRP_USE}"/&gt;, $this:resource:= &lt;mets:div
                TYPE="{$config:PROJECT_RESOURCE_DIV_TYPE}" ID="{$this:resource-pid}" LABEL=""/&gt;
                let $update-data:= (update insert $this:fileGrp into $mets:projectData, update
                insert $this:resource into $mets:structMap/mets:div) let $master_register :=
                resource:add-master($master_filepath, $this:resource-pid, $project-pid) let $log :=
                util:log-app("INFO",$config:app-name,"registered new resource
                "||$this:resource-pid||" in cr-project "||$project-pid||".") return if
                ($make-fragments eq true()) then rf:generate($this:resource-pid,$project-pid) else
                $this:resource-pid else util:log-app("INFO",$config:app-name,"New resource
                "||$this:resource-pid||" could not be created.") }; (:~ Returns the structMap entry
                for the resource :) declare function resource:get($resource-pid as
                xs:string,$project-pid as xs:string) as element(mets:div)? { let
                $mets:record:=project:get($project-pid) return $mets:record//mets:div[@ID eq
                $resource-pid][@TYPE eq $config:PROJECT_RESOURCE_DIV_TYPE] }; (:~ : Returns the
                mets:fileGrp which contains all files of the given resource. ~:) declare function
                resource:files($resource-pid as xs:string,$project-pid as xs:string) as
                element(mets:fileGrp)? { let $mets:record:=project:get($project-pid),
                $mets:fileGrp-by-id:=$mets:record//mets:fileGrp[@USE=$config:PROJECT_RESOURCE_FILEGRP_USE][@ID
                eq $resource-pid||$config:PROJECT_RESOURCE_FILEGRP_SUFFIX] return if
                (exists($mets:fileGrp-by-id)) then $mets:fileGrp-by-id else (: fallback solution: we
                just fetch one fptr in the resource data and look for the &lt;fileGrp&gt; which it
                refers to :) let $mets:FILEID:=$mets:record//mets:div[@TYPE eq
                $config:PROJECT_RESOURCE_DIV_TYPE and @ID eq
                $resource-pid]//mets:fptr[1]/xs:string(@FILEID) return
                $mets:record//mets:fileGrp[@USE=$config:PROJECT_RESOURCE_FILEGRP_USE and
                mets:file/@ID = $mets:FILEID] }; (:~ : insert or replace mets:files of resources :
                watch out: facsimile files are handled by the facs.xqm module! ~:) declare function
                resource:add-file($file as element(mets:file),$resource-pid as
                xs:string,$project-pid as xs:string) { let
                $mets:resourceFiles:=resource:files($resource-pid,$project-pid) let
                $this:fileID:=$file/@ID, $mets:file:= (: we try to locate files via their @USE
                attribute, as the composition of @IDs might change :) switch (true()) case
                ($file/@USE = $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE) return
                $mets:resourceFiles//mets:file[@USE eq $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE]
                case ($file/@USE = $config:RESOURCE_WORKINGCOPY_FILE_USE) return
                $mets:resourceFiles//mets:file[@USE eq $config:RESOURCE_WORKINGCOPY_FILE_USE] case
                ($file/@USE = $config:RESOURCE_LOOKUPTABLE_FILE_USE) return
                $mets:resourceFiles//mets:file[@USE eq $config:RESOURCE_LOOKUPTABLE_FILE_USE] case
                ($file/@USE = $config:RESOURCE_MASTER_FILE_USE) return
                $mets:resourceFiles//mets:file[@USE eq $config:RESOURCE_MASTER_FILE_USE] default
                return $mets:resourceFiles//mets:file[@ID eq $this:fileID] return if
                (exists($mets:file)) then (update delete $mets:file,update insert $file into
                $mets:resourceFiles) else update insert $file into $mets:resourceFiles }; declare
                function resource:add-fragment($div as element(mets:div),$resource-pid as
                xs:string,$project-pid as xs:string) { let
                $mets:resource:=resource:get($resource-pid,$project-pid) let
                $this:fragmentID:=$div/@ID, $mets:div:=$mets:resource//mets:div[@ID eq
                $this:fragmentID], $facs := root($mets:div)//mets:fileGrp[@ID =
                $config:PROJECT_FACS_FILEGRP_ID]//mets:file[@ID = $mets:div/mets:fptr/@FILEID]
                return if (exists($mets:div)) then if (exists($facs)) then let $log :=
                util:log-app("INFO",$config:app-name, "mets:div @ID "||$mets:div/@ID||" contains
                refence to facs "||string-join($facs/@ID,', ')||" - inserting fptrs into generated
                fragment.") let $replace := update replace $mets:div with $div return for $f in
                $facs return if (exists($mets:resource//mets:div[@ID eq
                $this:fragmentID]/mets:fptr[@FILEID eq $f/@ID])) then () else update insert
                &lt;mets:fptr FILEID="{$f/@ID}"/&gt; into $mets:resource//mets:div[@ID eq
                $this:fragmentID] else let $log := util:log-app("INFO",$config:app-name,'replacing
                existing resource fragment mets:div ID '||$this:fragmentID) return update replace
                $mets:div with $div else if (exists($mets:resource)) then ( update insert $div into
                $mets:resource, util:log-app("INFO",$config:app-name,"registered resourcefragment
                "||$this:fragmentID||" with resource "||$resource-pid) ) else
                util:log-app("ERROR",$config:app-name,"could not locate resource w/ ID
                "||$resource-pid||" in "||$project-pid||".") }; declare function
                resource:remove-file($fileid as xs:string,$resource-pid as xs:string,$project-pid as
                xs:string){ let $mets:resourceFiles:=resource:files($resource-pid,$project-pid)
                return update delete $mets:resourceFiles//mets:file[@ID eq $fileid] }; (:~ : Gets
                the path to the resources data specified as the third argument. : The data is read
                from resource's fileGrp in the project's mets record. : This currently may be one of
                the following: : - master : - workingcopy : - lookuptable : - resourcefragments : :
                @param $resource-pid: the PID of the resource : @param $project-pid: the ID of the
                current project : @param $key: the key of the data to get ~:) declare function
                resource:path($resource-pid as xs:string, $project-pid as xs:string, $key as
                xs:string) as xs:string? { let $file := resource:file($resource-pid, $project-pid,
                $key) return $file/mets:FLocat/@xlink:href }; declare function
                resource:file($resource-pid as xs:string, $project-pid as xs:string, $key as
                xs:string) as element(mets:file)? { let $config:= project:get($project-pid), $file:=
                resource:files($resource-pid,$project-pid), $use:= switch($key) case "master" return
                $config:RESOURCE_MASTER_FILE_USE case "wc" return
                $config:RESOURCE_WORKINGCOPY_FILE_USE case "working copy" return
                $config:RESOURCE_WORKINGCOPY_FILE_USE case "workingcopy" return
                $config:RESOURCE_WORKINGCOPY_FILE_USE case "workingcopies" return
                $config:RESOURCE_WORKINGCOPY_FILE_USE case "lookuptable" return
                $config:RESOURCE_LOOKUPTABLE_FILE_USE case "resourcefragments"return
                $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE default return $key return
                $file/mets:file[@USE=$use] }; (:~ : @return the mets:file-Element of the Master
                File. ~:) declare function resource:get-master($resource-pid as xs:string,
                $project-pid as xs:string) as element(mets:file)? { let
                $mets:resource:=resource:get($resource-pid,$project-pid),
                $mets:resource-files:=resource:files($resource-pid,$project-pid) let
                $mets:master:=$mets:resource-files/mets:file[@USE eq
                $config:RESOURCE_MASTER_FILE_USE] return $mets:master }; declare function
                resource:master($resource-pid as xs:string, $project-pid as xs:string) as
                document-node()? { let $doc :=
                doc(resource:path($resource-pid,$project-pid,'master')) return $doc }; declare
                function resource:get-data($resource-pid as xs:string, $project-pid as xs:string,
                $type as xs:string) as document-node()? { let $doc :=
                doc(resource:path($resource-pid,$project-pid,$type)) return $doc }; (:~ : Gets a
                master file for a resource as a document-node and stores it to the project's data
                directory. It does *not* register it with the resource. : : @param $content: the
                content of the resource : @param $filename: the filename of the resource to store. :
                @param $resource-pid: the pid of the resource to store : @param $project-id: the id
                of the project the resource belongs to : @return the db path to the file ~:) declare
                %private function resource:master($data as document-node(), $resource-pid as
                xs:string, $project-pid as xs:string) as xs:string? { let $current :=
                resource:master($resource-pid,$project-pid) return if (exists($current)) then update
                replace $current with $data else let $this:filename := $resource-pid||".xml" let
                $master_targetpath:= project:path($project-pid,'master') let $store:= try
                {repo-utils:store($master_targetpath,$this:filename,$data,true(),project:get($project-pid))
                } catch * { util:log-app("ERROR", $config:app-name,"master doc of resource
                "||$resource-pid||" could not be stored at "||$master_targetpath) },
                $this:filepath:=$master_targetpath||"/"||$this:filename let $chown :=
                sm:chown(xs:anyURI($this:filepath),project:adminsaccountname($project-pid)), $chgrp
                := sm:chgrp(xs:anyURI($this:filepath),project:adminsaccountname($project-pid)),
                $chmod := sm:chmod(xs:anyURI($this:filepath), 'rwxrwxr--') return if
                (doc-available($this:filepath)) then $this:filepath else () }; (:~ : Stores
                descriptive metadata of a resource in the appropriate collection. It does *not*
                register it with the resource. : : @param $data: the content of the resource :
                @param $resource-pid: the pid of the resource to store : @param $project-id: the id
                of the project the resource belongs to : @return the db path to the file ~:) declare
                function resource:store-dmd($data as document-node(), $mdtype as
                xs:string,$resource-pid as xs:string?, $project-pid as xs:string) as xs:string? {
                let $this:filename := $config:RESOURCE_DMD_FILENAME_PREFIX||$resource-pid||".xml"
                let $targetpath:=
                replace(project:path($project-pid,'metadata'),'/$','')||"/"||$mdtype let $store:=
                try
                {repo-utils:store($targetpath,$this:filename,$data,true(),project:get($project-pid))
                } catch * { util:log-app("INFO", $config:app-name,"metadata for resource
                "||$resource-pid||" could not be stored at "||$targetpath) },
                $this:filepath:=$targetpath||"/"||$this:filename return if
                (doc-available($this:filepath)) then $this:filepath else () }; (:~ : Registers a
                master document with the resource by appending a mets:file element to : the
                resources mets:fileGrp plus a fptr in the structMap. : If there is already a master
                registered with this resource, it will be replaced. : Note that this function does
                not touch the actual data. : Storage is handled by master:store(). : : @param
                $param:path the path to the stored working copy : @param $param:resource-pid the pid
                of the resource : @param $param:project-id: the id of the current project : @return
                the added mets:file element ~:) declare function
                resource:add-master($master-filepath as xs:string, $resource-pid as xs:string,
                $project-pid as xs:string) as empty() { let $resource :=
                resource:get($resource-pid,$project-pid) let
                $master_fileid:=$resource-pid||$config:RESOURCE_MASTER_FILEID_SUFFIX let
                $master_file:= resource:make-file($master_fileid,$master-filepath,"master") let
                $store-file:= resource:add-file($master_file,$resource-pid,$project-pid), $add-fptr
                := if (exists($resource/mets:fptr[@FILEID eq $master_fileid])) then () else update
                insert &lt;mets:fptr FILEID="{$master_fileid}"/&gt; into $resource return
                $store-file }; (:~ getter and setter for dmdSec, i.e. the resources's descriptive
                metadata :) declare function resource:dmd-from-id($resource-pid as
                xs:string,$project-pid as xs:string) as element()* { resource:dmd((),
                resource:get($resource-pid, $project-pid), doc(project:filepath($project-pid))) };
                declare function resource:dmd-from-id($type as xs:string, $resource-pid as
                xs:string,$project-pid as xs:string) as element()? {
                resource:dmd($type,resource:get($resource-pid, $project-pid),
                doc(project:filepath($project-pid))) }; declare function resource:dmd($resource,
                $project) as element()? { resource:dmd((),$resource,$project) }; (:~ if reference to
                $resource and $project-config already available, skip the id-based resolution :) (:~
                : @param $type the type of metadata to retrieve ("TEIHDR", "CMDI" etc) : @param
                $resource the :) declare function resource:dmd($type as xs:string?, $resource,
                $project) as element()? { (:let $resource-pid := typeswitch($resource) case
                element(mets:div) return $resource/@ID case xs:string return $resource case text()
                return $resource default return (), $project-pid := typeswitch($project) case
                element(mets:mets) return $project/@OBJID case xs:string return $project case text()
                return $project case attribute(OBJID) return data($project) default return (),
                $project := if ($project instance of element(mets:mets)) then $project else
                project:get($project-pid), $resource := if ($resource instance of element(mets:div))
                then $resource else resource:get($resource-pid,$project-pid),:) let $resource-pid :=
                repo-utils:get-record-pid($resource), $resource := repo-utils:get-record($resource),
                $project-pid := repo-utils:get-record-pid($project), $project :=
                repo-utils:get-record($project) let $dmdID := $resource/tokenize(@DMDID,'\s+'), (:
                workaround via attribute, as the id()-function did not work - ? $dmdSec :=
                doc(project:filepath($project-pid))//id($dmdID) :) $dmdSecs := $project//*[some $id
                in $dmdID satisfies @ID = $id], $dmdSec := if (exists($type) and $type!='') then
                $dmdSecs[*/@MDTYPE = $type and */@MDTYPE != 'OTHER' or */@MDTYPE='OTHER' and
                */@OTHERMDTYPE = $type] else ($dmdSecs[@STATUS='default'],$dmdSecs[1])[1] return if
                (exists($dmdSec)) then typeswitch($dmdSec/*) case element(mets:mdWrap) return
                $dmdSec//mets:xmlData/* case element(mets:mdRef) return let $location :=
                $dmdSec/mets:mdRef/@xlink:href return (:if (util:is-binary-doc($location)) then ()
                else:) if (doc-available($location)) then doc($location)/* else
                util:log-app("INFO",$config:app-name,"The Metadata for resource "||$resource-pid||"
                could not be retrieved from "||$location) default return
                util:log-app("INFO",$config:app-name,"Invalid content in Metadata Section for
                resource "||$resource-pid||".") else util:log-app("INFO",$config:app-name,"No
                Metadata is registered for resource "||$resource-pid||".") }; declare function
                resource:dmd($resource-pid as xs:string, $project-pid as xs:string, $data as item(),
                $mdtype as xs:string*) as empty() {
                resource:dmd($resource-pid,$project-pid,$data,$mdtype[1],()) }; (:~ : Registers a
                metdata file for a resource and optionally stores it to the db. : : @param
                $resource-pid the PID of the resource : @param $project-pid the PID of the project :
                @param $data either a string with an db-path leading to an (existing) file, or the
                content of the metadata as a element or document-node. : @param $store-to-db if set
                to true(), the metdata resource is stored as an independend resource to the database
                () and only referenced in the mets record (default behaviour), if set to false(),
                the metadata is inlined in the the project's mets record. : @return empty() ~:)
                declare function resource:dmd($resource-pid as xs:string, $project-pid as xs:string,
                $data as item(), $mdtype as xs:string, $store-to-db as xs:boolean?) as empty() { let
                $doc:= project:get($project-pid), $current :=
                resource:dmd($resource-pid,$project-pid), $data-location:=base-uri($current), $dmdid
                := $resource-pid||$mdtype||$config:RESOURCE_DMDID_SUFFIX, $dmdSec :=
                $doc//mets:dmdSec[@ID = $dmdid] return switch (true()) (: wrong declaration of
                Metadata Format :) case not($mdtype=($resource:mdtypes,$resource:othermdtypes))
                return util:log-app("INFO",$config:app-name,"invalid value for parameter $mdtype for
                resource "||$resource-pid) (: $data is not a document, element node or string :)
                case (not($data instance of document-node()) and not($data instance of element())
                and not($data instance of xs:string)) return
                util:log-app("INFO",$config:app-name,"parameter $data has invalid type (resource
                "||$resource-pid||") allowed are: document-node() or element() for content, or
                xs:string for db-path.") (: $data is empty &gt; remove current content of dmd,
                external files and references to this dmd :) case (not(exists($data)) and
                exists($current)) return let $rm-data := if ($data-location eq base-uri($doc)) then
                update delete $current else
                xmldb:remove(util:collection-name($data),util:document-name($data)),
                $rm-dmdSec:=update delete $doc//mets:dmdSec[@ID = $dmdid], $rm-ref-attrs:= for
                $mdref in $doc//@DMDREF[matches(.,'\s*'||$dmdid||'\s*')] return if ($mdref = $dmdid)
                then update delete $mdref else update value $mdref with replace(.,$dmdid,'') return
                () (: update current content or insert new :) case (exists($data)) return (: add
                dmdid attribute to the resource's mets:div container :) let $dmdidref := if
                (exists($doc//mets:div[matches(@DMDID,'\s*'||$dmdid||'\s*')])) then () else let
                $res-div := resource:get($resource-pid,$project-pid) let $existing-dmdid :=
                $res-div/@DMDID return if (exists($existing-dmdid)) then update value
                $existing-dmdid with $existing-dmdid||' '||$dmdid else update insert attribute DMDID
                {$dmdid} into $res-div return (: store metadata to database and add a reference in
                the mets record:) if (exists($store-to-db) and $store-to-db) then (: the content of
                the metdata is already in an external file, so we just set the mdRef (again) :) if
                ($data instance of xs:string) then if (doc-available(normalize-space($data))) then
                let $mdRef:= if ($mdtype = $resource:mdtypes) then &lt;mdRef MDTYPE="{$mdtype}"
                LOCTYPE="URL" xmlns="http://www.loc.gov/METS/"
                xlink:href="{normalize-space($data)}"/&gt; else &lt;mdRef MDTYPE="OTHER"
                OTHERMDTYPE="{$mdtype}" LOCTYPE="URL" xmlns="http://www.loc.gov/METS/"
                xlink:href="{normalize-space($data)}"/&gt; return switch(true()) case
                (exists($dmdSec/node())) return (update delete $dmdSec/node(), update insert $mdRef
                into $dmdSec) case (exists($dmdSec)) return update insert $mdRef into $dmdSec
                default return update insert &lt;dmdSec ID="{$dmdid}"
                xmlns="http://www.loc.gov/METS/"&gt;{$mdRef}&lt;/dmdSec&gt; following
                $doc//mets:dmdSec[last()] else util:log-app("INFO",$config:app-name,"The metdata
                resource referenced in "||$data||"is not available. dmdSec-Update aborted for
                resource "||$resource-pid) else (: $data contains metadata content, so we store it
                to the db and create a new mdRef :) let $mdpath := resource:store-dmd(if ($data
                instance of document-node()) then $data else
                document{$data},$mdtype,$resource-pid,$project-pid), $mdRef:= if ($mdtype =
                $resource:mdtypes) then &lt;mdRef MDTYPE="{$mdtype}" LOCTYPE="URL"
                xmlns="http://www.loc.gov/METS/" xlink:href="{normalize-space($mdpath)}"/&gt; else
                &lt;mdRef MDTYPE="OTHER" OTHERMDTYPE="{$mdtype}" LOCTYPE="URL"
                xmlns="http://www.loc.gov/METS/" xlink:href="{normalize-space($mdpath)}"/&gt; return
                if ($mdpath!='') then switch(true()) case (exists($dmdSec/node())) return (update
                delete $dmdSec/node(), update insert $mdRef into $dmdSec) case (exists($dmdSec))
                return update insert $mdRef into $dmdSec default return update insert &lt;dmdSec
                ID="{$dmdid}" xmlns="http://www.loc.gov/METS/"&gt;{$mdRef}&lt;/dmdSec&gt; following
                $doc//mets:dmdSec[last()] else util:log-app("INFO",$config:app-name,"could not store
                metadata resource at "||$dmdSec) (: move metadata into mets container :) else if
                ($data instance of xs:string) then let $doc := if
                (doc-available(normalize-space($data))) then doc(normalize-space($data)) else ()
                return if (exists($doc)) then (: store content of the external file into the mets
                container ... :) let $mdWrap := &lt;mdWrap MDTYPE="{$mdtype}"
                xmlns="http://www.loc.gov/METS/"&gt;&lt;xmlData&gt;{$doc}&lt;/xmlData&gt;&lt;/mdWrap&gt;
                let $update-mets:= switch(true()) case (exists($dmdSec/node())) return (update
                delete $dmdSec/node(), update insert $mdWrap into $dmdSec) case (exists($dmdSec))
                return update insert $mdWrap into $dmdSec default return update insert &lt;dmdSec
                ID="{$dmdid}" xmlns="http://www.loc.gov/METS/"&gt;{$mdWrap}&lt;/dmdSec&gt; following
                $doc//mets:dmdSec[last()] (: ... and delete the external file :) return
                xmldb:remove(util:collection-name($doc),util:document-name($doc)) else
                util:log-app("INFO",$config:app-name, "The metdata resource referenced in
                "||$data||"is not available. dmdSec-Update aborted for resource "||$resource-pid) (:
                $data is metadata content :) else let $mdWrap := &lt;mdWrap MDTYPE="{$mdtype}"
                xmlns="http://www.loc.gov/METS/"&gt;&lt;xmlData&gt;{$data}&lt;/xmlData&gt;&lt;/mdWrap&gt;
                return (: metadata content already exists :) if (exists($current)) then (: current
                data lives inside the mets record, so we update it :) if ($data-location eq
                base-uri($data)) then update replace $current with $data (: data is in an external
                file, we store the :) else (: ... otherwise fetch the content of the external file,
                store it into the mets record and delete the file afterwards. :) let $update-mets:=
                switch(true()) case exists($dmdSec/node()) return (update delete $dmdSec/node(),
                update insert $mdWrap into $dmdSec) case exists($dmdSec) return update insert
                $mdWrap into $dmdSec default return update insert &lt;dmdSec ID="{$dmdid}"
                xmlns="http://www.loc.gov/METS/"&gt;{$mdWrap}&lt;/dmdSec&gt; following
                $doc//mets:dmdSec[last()] (: ... and delete the external file :) return
                xmldb:remove(util:collection-name($doc),util:document-name($doc)) (: metadata
                content does not exist, so we just insert it :) else if (exists($dmdSec)) then
                update insert $mdWrap into $dmdSec else update insert &lt;dmdSec ID="{$dmdid}"
                xmlns="http://www.loc.gov/METS/"&gt;{$mdWrap}&lt;/dmdSec&gt; following
                $doc//mets:dmdSec[last()] default return () }; declare function
                resource:label($resource-pid as xs:string, $project-pid as xs:string) as xs:string?
                { let $resource := resource:get($resource-pid, $project-pid) return
                $resource/xs:string(@LABEL)[.!=""] }; declare function resource:label($data as
                document-node(), $resource-pid as xs:string, $project-pid as xs:string) as
                element(cr:response)? { let $resource := resource:get($resource-pid, $project-pid)
                let $update := if ($data/* instance of element(cr:data)) then (update value
                $resource/@LABEL with xs:string($data), true()) else false() return if ($update)
                then &lt;cr:response path="/cr_xq/{$project-pid}/{$resource-pid}/label"
                datatype="xs:string"&gt;{$resource/xs:string(@LABEL)}&lt;/cr:response&gt; else () };
                (:~ : returns the logical structure of a resource : as generated in the
                structMap.logical : : @param $resource-pid the pid of the resource : @param
                $project-pid the pid of the project : @return ~:) declare function
                resource:get-toc($resource-pid as xs:string, $project-pid as xs:string) as
                element()? { let $toc := project:get-toc($project-pid), $mets:record :=
                project:get($project-pid), $resource-ref := '#'||$resource-pid (:$frgs :=
                resource:get($resource-pid, $project-pid)//mets:div[@TYPE='resourcefragment']:) let
                $toc-resource := $toc[@CONTENTIDS=$resource-ref] return
                resource:do-get-toc-resolved($toc-resource,$resource-pid,$mets:record) }; declare
                function resource:do-get-toc-resolved($node as node(), $resource-pid as xs:string?,
                $mets-record as element(mets:mets)) as node()* { typeswitch ($node) case attribute()
                return $node case text() return $node case processing-instruction() return $node
                case document-node() return resource:do-get-toc-resolved($node/*, $resource-pid,
                $mets-record) case element(mets:fptr) return for $n in $node/* return
                resource:do-get-toc-resolved($node/*, $resource-pid, $mets-record) case
                element(mets:area) return let $frgs := $mets-record//mets:div[@ID =
                $resource-pid]//mets:div[@type=$config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE] let
                $rfid-first := $node/xs:string(@BEGIN), $rfid-last := $node/xs:string(@END),
                $frg-first := $mets-record//mets:div[@ID=$rfid-first], $frg-last :=
                $mets-record//mets:div[@ID=$rfid-last], $frgs-between := $frgs[. &gt;&gt; $frg-first
                and . &lt;&lt; $frg-last] return ($frg-first,$frgs-between,$frg-last)/. (: the
                location step after the sequence eliminates duplicates, e.g. when $frg-first and
                $frg-last are the same element :) case element(mets:div) return switch(true()) case
                (exists($node/mets:div[@TYPE=$config:PROJECT_RESOURCE_DIV_TYPE])) return
                &lt;mets:structMap&gt;{ for $n in
                $node/mets:div[@TYPE=$config:PROJECT_RESOURCE_DIV_TYPE] return
                project:do-get-toc-resolved($n,$resource-pid,$mets-record) }&lt;/mets:structMap&gt;
                case ($node/@TYPE=$config:PROJECT_RESOURCE_DIV_TYPE) return (: we are shadowing the
                $resource-pid downwards :) let $resource-pid :=
                substring-after($node/@CONTENTIDS,'#'), $resource := $mets-record//mets:div[@ID =
                $resource-pid] return element
                {QName(xs:string(namespace-uri($resource)),local-name($resource))} { $resource/@*
                except $resource/(@DMDID,@CONTENTIDS,@ID), $node/@ID, for $n in $node/node() return
                resource:do-get-toc-resolved($n,$resource-pid,$mets-record) } case
                ($node/@TYPE='resourcefragment') return for $n in $node/mets:* return
                resource:do-get-toc-resolved($n,$resource-pid,$mets-record) default return element
                {QName(xs:string(namespace-uri($node)),local-name($node))} { $node/@*, for $n in
                $node/node() return resource:do-get-toc-resolved($n,$resource-pid,$mets-record) }
                case element() return element
                {QName(xs:string(namespace-uri($node)),local-name($node))} { $node/@*, for $n in
                $node/node() return resource:do-get-toc-resolved($n,$resource-pid,$mets-record) }
                default return $node }; (:~ : Generates additional structural components (like
                chapters), i.e. ToC for a given resource, : identifying their position relative to
                the base resourcefragments (based on lookuptable) : and registers it with the
                resource's structMap.logical entry. : : REQUIRES the workingcopy and lookuptable
                files for given resource to be in place : OBSOLETED BY toc:generate() : @param
                $struct-xpath the xpath for the elements to be treated as structures : @param
                $struct-type the name of the structure (e.g. 'chapter') : @param $resource-pid the
                pid of the resource : @param $project-pid the id of the project : @return the
                database path to the resourcefragments cache ~:) declare function
                resource:generate-toc($struct-xpath as xs:string, $struct-type as xs:string,
                $resource-pid as xs:string, $project-pid as xs:string) as item()* { let $rf-id :=
                $resource-pid||$config:RESOURCE_RESOURCEFRAGMENT_FILEID_SUFFIX(:$config:RESOURCE_RESOURCEFRAGMENT_ID_SUFFIX:)
                let $wc := wc:get-data ($resource-pid,$project-pid) let $resource-ref :=
                '#'||$resource-pid let $resource-label := resource:label($resource-pid,
                $project-pid) let $divs := for $div in util:eval("$wc"||$struct-xpath) let $div-id
                := $div/data(@cr:id) (: FIXME: this needs to be configurable :) let $div-label:=
                $div/data(@n) let $frags := lt:lookup($div-id,$resource-pid,$project-pid) return
                &lt;mets:div TYPE="{$struct-type}" ID="{$div-id}" LABEL="{$div-label}"&gt;
                &lt;mets:fptr&gt; &lt;mets:area FILEID="{$rf-id}" BEGIN="{$frags[1]}"
                END="{$frags[last()]}" BETYPE="IDREF"/&gt; &lt;/mets:fptr&gt; &lt;/mets:div&gt; let
                $struct-div := &lt;mets:div TYPE="resource" CONTENTIDS="{$resource-ref}"
                LABEL="{$resource-label/text()}" &gt;{$divs}&lt;/mets:div&gt; (:return $struct-div:)
                let $mets:record := project:get($project-pid), $mets:structMap-exists :=
                $mets:record//mets:structMap[@TYPE=$config:PROJECT_TOC_STRUCTMAP_TYPE] return (if
                (not(exists($mets:record))) then util:log-app("INFO",$config:app-name,"no
                METS-Record found in config for "||$project-pid ) else
                if(exists($mets:structMap-exists)) then if
                (exists($mets:structMap-exists/mets:div/mets:div[@CONTENTIDS=$resource-ref])) then
                update replace $mets:structMap-exists/mets:div/mets:div[@CONTENTIDS=$resource-ref]
                with $struct-div else update insert $struct-div into $mets:structMap-exists/mets:div
                else update insert &lt;mets:structMap TYPE="{$config:PROJECT_TOC_STRUCTMAP_TYPE}"
                &gt; &lt;mets:div&gt;{$struct-div}&lt;/mets:div&gt; &lt;/mets:structMap&gt; into
                $mets:record, util:log-app("INFO",$config:app-name,"generated new structure
                "||$struct-type||" for resource "||$resource-pid||" in cr-project
                "||$project-pid||"." ) ) }; (:~ recreates working copy, resourcefragments and
                lookup-tables : @param $resource-pid the pid of the resource : @param $project-pid
                the id of the project ~:) declare function resource:refresh-aux-files($resource-pid
                as xs:string, $project-pid as xs:string){
                resource:refresh-aux-files((),$resource-pid,$project-pid) }; (:~ recreates auxilary
                files working copy, resourcefragments, lookup-tables and table of content : : @param
                $struct-xpath the xpath for the elements to be treated as structures : @param
                $struct-type the name of the structure (e.g. 'chapter') : @param $resource-pid the
                pid of the resource : @param $project-pid the id of the project ~:) declare function
                resource:refresh-aux-files($toc-indexes as xs:string*, $resource-pid as xs:string,
                $project-pid as xs:string){ let $start-time := current-dateTime() let $log :=
                util:log-app("INFO",$config:app-name,"rebuilding auxiliary files for resource
                "||$resource-pid||" (project "||$project-pid||")") let $log :=
                util:log-app("INFO",$config:app-name,"please bear with me, this might take a while
                ... ") let $wc := wc:generate($resource-pid,$project-pid), $rf :=
                rf:generate($resource-pid, $project-pid), $lt :=
                lt:generate($resource-pid,$project-pid) let $toc := if ($toc-indexes = '') then ()
                else toc:generate($toc-indexes,$resource-pid,$project-pid) let $stop-time :=
                current-dateTime() let $duration := xs:dateTime($start-time)-xs:dateTime($stop-time)
                let $log := util:log-app("INFO",$config:app-name,"finished rebuiling auxiliary files
                for resource "||$resource-pid||" (project "||$project-pid||" in
                "||minutes-from-duration($duration)||"min.)") return () }; declare function
                resource:cmd($resource-pid as xs:string, $project-pid as xs:string) as
                element(cmd:CMD)?{ resource:dmd("CMDI",$resource-pid,$project-pid) }; declare
                function resource:cmd($resource-pid as xs:string, $project-pid as xs:string, $data
                as element(cmd:CMD)?) as empty() { let $doc:= project:get($project-pid), $resource
                := resource:get($resource-pid,$project-pid), $dmdSecs := $project//*[some $id in
                $dmdID satisfies @ID = $id], $dmdSec := $dmdSecs[*/@MDTYPE='OTHER' and
                */@OTHERMDTYPE = "CMDI"], $dmdSecID := $dmdSec/@ID, $current:=
                resource:cmd($resource-pid,$project-pid) let $location :=
                replace(project:path($project-pid,'metadata'),'/$','')||"/CMDI/"||$resource-pid||".xml"
                let $update := if (exists($current)) then if (exists($data)) then update replace
                $current with $data else (update delete $doc//mets:dmdSec[@ID=$dmdSecID],
                xmldb:remove(util:collection-name($current),util:document-name($current))) else let
                $update-mets:= if (exists($doc//mets:dmdSec[@ID =
                $dmdSecID]/mets:mdRef[@MDTYPE='OTHER' and @OTHERMDTYPE='CMDI'])) then update value
                $doc//mets:dmdSec[@ID = $dmdSecID]/mets:mdRef[@MDTYPE='OTHER' and
                @OTHERMDTYPE='CMDI']/@xlink:href with $location else update insert &lt;dmdSec
                ID="{$config:PROJECT_DMDSEC_ID}_CMDI" xmlns="http://www.loc.gov/METS/"&gt; &lt;mdRef
                MDTYPE="OTHER" OTHERMDTYPE="CMDI" xlink:href="{$location}" LOCTYPE="URL"/&gt;
                &lt;/dmdSec&gt; following $doc//mets:metsHdr return
                xmldb:store(replace(project:path($project-pid,'metadata'),'/$','')||"/CMDI",$resource-pid||".xml",$data)
                return () }; (:~ : Returns the handle for the given resource : Handles are stored
                directly in the CMDI metadata of the resoruce as we cannot : assign handles without
                a CMDI record. : : @param $type: The aspect of the resource to get the handle for
                (Metadata, Data etc.) : @param $resource-pid: The PID of the resource to attatch the
                handle to : @param $project-pid: The PID of the project :) declare function
                resource:get-handle($type as xs:string, $resource-pid as xs:string, $project-pid as
                xs:string) as xs:string* { let $cmdi := resource:cmd($resource-pid,$project-pid),
                $resourceproxy-id :=
                config:param-value((),"pid-resourceproxy-prefix")||$resource-pid let $handle :=
                switch($type) (: metadata defaults to the CMDI record :) case "metadata" return
                $cmdi/cmd:Header/cmd:MdSelfLink case "CMDI" return $cmdi/cmd:Header/cmd:MdSelfLink
                case "data" return $cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[@id
                eq $resourceproxy-id][cmd:ResourceType = "Resource" ]/cmd:ResourceRef case "project"
                return $cmdi/cmd:Resources/cmd:IsPartOfList/cmd:IsPartOf default return () return if
                (exists($cmdi)) then $handle[.!=""] else util:log-app("ERROR",$config:app-name,"No
                CMDI record found for resource '"||$resource-pid||"' in project
                '"||$project-pid||"'") }; (:~ : Updates or creates handle-uris for a resource. The
                resource's CMDI Record has to be in place for this. : The target url gets
                constructed automatically. : @param $type The aspect of the resource the handle
                should point to. Possible values are limited to: : - "data" (the raw data of the
                resource) : - "CMDI" (the CMDI record of the resource), : - "teiHdr" (the teiHeader
                of the resource) : - "metadata" (default metadata entry, defaults to "CMDI") : -
                "project" (declares the resource to be part of a collection or corpus: i.e. sets the
                "isPartOf" element AND updates the CMDI record of the collection.) : @param
                $resoruce-pid the PID of the resource : @param $project-pid the PID of the project
                ~:) declare function resource:set-handle($type as xs:string, $resource-pid as
                xs:string, $project-pid as xs:string) as item()* { let $cmdi :=
                resource:cmd($resource-pid,$project-pid), $current :=
                resource:get-handle($type,$resource-pid,$project-pid), $config :=
                config:config($project-pid), $resourceproxy-id :=
                config:param-value($config,"pid-resourceproxy-prefix")||$resource-pid, (:
                constructing the URL :) $target-url := if ($type = "project") then let
                $project-handle := project:get-handle("CMDI",$project-pid) return if
                ($project-handle!='') then $project-handle else let $set-handle :=
                project:set-handle("CMDI",$project-pid) return
                project:get-handle("CMDI",$project-pid) else concat(
                replace(config:param-value($config,"public-repo-baseurl"),'/$',''), (:
                replace(config:param-value(config:module-config(),"public-repo-baseurl"),'/$',''),:)
                (:"/",$project-pid,:) "/get/",$resource-pid,"/", switch($type) case "metadata"
                return $type case "CMDI" return "metadata/CMDI" case "teiHdr" return
                "metadata/TEIHDR" default return "data" ) return if (exists($current)) then let
                $update-handle := handle:update($target-url,$current,$project-pid) return if ($type
                != "CMDI") then () else let $project-cmdi := project:dmd($project-pid) let
                $project-handle := project:get-handle("CMDI",$project-pid) let
                $set-proxy-in-project-cmdi := if
                (exists($project-cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[@id =
                $resource-pid][cmd:ResourceType = "Metadata"][. = $current])) then () else if
                (exists($project-cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[@id =
                $resource-pid][cmd:ResourceType = "Metadata"])) then update value
                $project-cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[@id =
                $resource-pid][cmd:ResourceType = "Metadata"]/cmd:ResourceRef with $current else if
                (exists($project-cmdi/cmd:Resources/cmd:ResourceProxyList)) then update insert
                &lt;cmd:ResourceProxy id="{$resource-pid}"&gt; &lt;cmd:ResourceType
                mimetype="application/xml"&gt;Metadata&lt;/cmd:ResourceType&gt;
                &lt;cmd:ResourceRef&gt;{$current}&lt;/cmd:ResourceRef&gt; &lt;/cmd:ResourceProxy&gt;
                into $project-cmdi/cmd:Resources/cmd:ResourceProxyList else util:log-app("ERROR",
                $config:app-name, "No cmd:ResourceProxyList found in CMD-record
                "||base-uri($project-cmdi)) let $set-is-part-of := if
                ($cmdi/cmd:Resources/cmd:IsPrtOfList/cmd:IsPartOf = $project-pid) then () else if
                (exists($cmdi/cmd:Resources/cmd:IsPartOfList)) then update insert
                &lt;cmd:IsPartOf&gt;{$project-handle}&lt;/cmd:IsPartOf&gt; into
                $cmdi/cmd:Resources/cmd:IsPartOfList else update insert
                &lt;cmd:IsPartOfList&gt;&lt;cmd:IsPartOf&gt;{$project-handle}&lt;/cmd:IsPartOf&gt;&lt;/cmd:IsPartOfList&gt;
                into $cmdi/cmd:Resources return () else if (exists($cmdi)) then let $handle-url :=
                handle:create($target-url,$project-pid) return switch($type) (: type metadata
                defaults to the CMDI record :) case "metadata" return
                resource:set-handle("CMDI",$resource-pid,$project-pid) case "CMDI" return let
                $set-self-link := if (exists($cmdi/cmd:Header/cmd:MdSelfLink)) then update value
                $cmdi/cmd:Header/cmd:MdSelfLink with $handle-url else if (exists($cmdi/cmd:Header))
                then update insert &lt;cmd:MdSelfLink&gt;{$handle-url}&lt;/cmd:MdSelfLink&gt; into
                $cmdi/cmd:Header else update insert
                &lt;cmd:Header&gt;&lt;cmd:MdSelfLink&gt;{$handle-url}&lt;/cmd:MdSelfLink&gt;&lt;/cmd:Header&gt;
                into $cmdi let $set-proxy-in-project-cmdi := let $project-cmdi :=
                project:dmd($project-pid) return if
                (exists($project-cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[@id =
                $resource-pid][cmd:ResourceType = "Metadata"][. = $handle-url])) then () else if
                (exists($project-cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[@id =
                $resource-pid][cmd:ResourceType = "Metadata"])) then update value
                $project-cmdi/cmd:Resources/cmd:ResourceProxyList/cmd:ResourceProxy[@id =
                $resource-pid][cmd:ResourceType = "Metadata"] with $handle-url else if
                (exists($project-cmdi/cmd:Resources/cmd:ResourceProxyList)) then update insert
                &lt;cmd:ResourceProxy id="{$resource-pid}"&gt; &lt;cmd:ResourceType
                mimetype="application/xml"&gt;Metadata&lt;/cmd:ResourceType&gt;
                &lt;cmd:ResourceRef&gt;{$handle-url}&lt;/cmd:ResourceRef&gt;
                &lt;/cmd:ResourceProxy&gt; into $project-cmdi/cmd:Resources/cmd:ResourceProxyList
                else util:log-app("ERROR", $config:app-name, "No cmd:ResourceProxyList found in
                CMD-record "||base-uri($project-cmdi)) let $project-handle :=
                project:get-handle("CMDI",$project-pid) return if
                (exists($cmdi/cmd:Resources/cmd:IsPrtOfList/cmd:IsPartOf[. = $project-pid])) then ()
                else if (exists($cmdi/cmd:Resources/cmd:IsPartOfList)) then update insert
                &lt;cmd:IsPartOf&gt;{$project-handle}&lt;/cmd:IsPartOf&gt; into
                $cmdi/cmd:Resources/cmd:IsPartOfList else update insert
                &lt;cmd:IsPartOfList&gt;&lt;cmd:IsPartOf&gt;{$project-handle}&lt;/cmd:IsPartOf&gt;&lt;/cmd:IsPartOfList&gt;
                into $cmdi/cmd:Resources case "data" return let $resources :=
                $cmdi/cmd:Resources/cmd:ResourceProxyList return if
                (exists($resources/cmd:ResourceProxy[@id eq $resourceproxy-id][cmd:ResourceType =
                "Resource" ]/cmd:ResourceRef)) then update value $resources/cmd:ResourceProxy[@id eq
                $resourceproxy-id][cmd:ResourceType = "Resource" ]/cmd:ResourceRef with $handle-url
                else if (exists($resources/cmd:ResourceProxy[@id eq
                $resourceproxy-id][cmd:ResourceType = "Resource"])) then update insert
                &lt;cmd:ResourceRef&gt;{$handle-url}&lt;/cmd:ResourceRef&gt; following
                $resources/cmd:ResourceProxy[@id eq $resourceproxy-id]/cmd:ResourceType else if
                (exists($resources)) then update insert &lt;cmd:ResourceProxy
                id="{$resourceproxy-id}"&gt;
                &lt;cmd:ResourceType&gt;Resource&lt;/cmd:ResourceType&gt;
                &lt;cmd:ResourceRef&gt;{$handle-url}&lt;/cmd:ResourceRef&gt;
                &lt;/cmd:ResourceProxy&gt; into $resources else update insert &lt;cmd:Resources&gt;
                &lt;cmd:ResourceProxy id="{$resourceproxy-id}"&gt;
                &lt;cmd:ResourceType&gt;Resource&lt;/cmd:ResourceType&gt;
                &lt;cmd:ResourceRef&gt;{$handle-url}&lt;/cmd:ResourceRef&gt;
                &lt;/cmd:ResourceProxy&gt; &lt;/cmd:Resources&gt; into $cmdi case "project" return
                let $set-is-part-of := (: WATCHME possibly we want one resource to be part of more
                than one project :) if (exists($cmdi/cmd:Resources/cmd:IsPartOfList/cmd:IsPartOf))
                then update value $cmdi/cmd:Resources/cmd:IsPartOfList/cmd:IsPartOf with $handle-url
                else if (exists($cmdi/cmd:Resources/cmd:IsPartOfList)) then update insert
                &lt;cmd:IsPartOf&gt;{$handle-url}&lt;/cmd:IsPartOf&gt; into
                $cmdi/cmd:Resources/cmd:IsPartOfList else if (exists($cmdi/cmd:Resources)) then
                update insert
                &lt;cmd:IsPartOfList&gt;&lt;cmd:IsPartOf&gt;{$handle-url}&lt;/cmd:IsPartOf&gt;&lt;/cmd:IsPartOfList&gt;
                into $cmdi/cmd:Resources else update insert
                &lt;cmd:Resources&gt;&lt;cmd:IsPartOfList&gt;&lt;cmd:IsPartOf&gt;{$handle-url}&lt;/cmd:IsPartOf&gt;&lt;/cmd:IsPartOfList&gt;&lt;/cmd:Resources&gt;
                into $cmdi let $update-collection-cmdi := let $project-cmdi :=
                project:dmd($project-pid), $resource-in-project :=
                $project-cmdi//cmd:ResourceProxy[@id = $resource-pid][cmd:ResourceType="Metadata"]
                return switch (true()) case (exists($resource-in-project/cmd:ResourceRef)) return
                update value $resource-in-project/cmd:ResourceRef with $handle-url case
                (exists($resource-in-project)) return update insert
                &lt;cmd:ResourceRef&gt;{$handle-url}&lt;/cmd:ResourceRef&gt; following
                $resource-in-project/cmd:ResourceType case
                (exists($cmdi/cmd:Resources/cmd:ResourceProxyList)) return update insert
                &lt;cmd:ResourceProxy id="{$resource-pid}"&gt; &lt;cmd:ResourceType
                mimetype="application/xml"&gt;Metadata&lt;/cmd:ResourceType&gt;
                &lt;cmd:ResourceRef&gt;{$handle-url}&lt;/cmd:ResourceRef&gt;
                &lt;/cmd:ResourceProxy&gt; into $cmdi//cmd:ResourceProxyList default return
                util:log-app("ERROR",$config:app-name,"No element cmd:ResourceProxyList found in
                CMDI Record at "||base-uri($cmdi)) return () default return
                util:log-app("INFO",$config:app-name,"Unknown resource aspect '"||$type||"' in
                resource:set-handle() for resource '"||$resource-pid||"' in project
                '"||$project-pid||"'.") else util:log-app("ERROR",$config:app-name,"Can't store
                handle-uri for resource "||$resource-pid||" because of missing CMDI record.") };
                declare function resource:remove-handle($type as xs:string, $resource-pid as
                xs:string, $project-pid as xs:string) as empty() { let $handle-url :=
                resource:get-handle($type,$resource-pid,$project-pid) return
                handle:remove($handle-url,$project-pid) }; declare function
                resource:dmd2dc($resource-pid as xs:string, $project-pid as xs:string) as
                element(oai_dc:dc){ let $dmd := resource:dmd-from-id($resource-pid,$project-pid),
                $xsl := doc(config:path("scripts")||"/dc/cmdi2dc.xsl"), $params :=
                &lt;parameters&gt;&lt;param name='fedora-pid-namespace-prefix'
                value="{config:param-value(config:module-config(),'fedora-pid-namespace-prefix')}"/&gt;&lt;/parameters&gt;
                return transform:transform($dmd,$xsl,$params) };</f>
            <f n="resourcefragment.xqm">xquery version "3.0"; module namespace
                rf="http://aac.ac.at/content_repository/resourcefragment"; import module namespace
                repo-utils = "http://aac.ac.at/content_repository/utils" at "repo-utils.xqm"; import
                module namespace config="http://exist-db.org/xquery/apps/config" at "config.xqm";
                import module namespace resource="http://aac.ac.at/content_repository/resource" at
                "resource.xqm"; import module namespace
                wc="http://aac.ac.at/content_repository/workingcopy" at "wc.xqm"; import module
                namespace lt = "http://aac.ac.at/content_repository/lookuptable" at
                "lookuptable.xqm"; import module namespace
                project="http://aac.ac.at/content_repository/project" at "project.xqm"; import
                module namespace index="http://aac.ac.at/content_repository/index" at "index.xqm";
                import module namespace fcs = "http://clarin.eu/fcs/1.0" at
                "../modules/fcs/fcs.xqm"; declare namespace mets="http://www.loc.gov/METS/"; declare
                namespace xlink="http://www.w3.org/1999/xlink"; declare namespace
                cr="http://aac.ac.at/content_repository"; (: declaration of helper namespaces for
                better code structuring :) declare namespace param="userinput.parameters"; declare
                namespace this="current.object"; declare variable $rf:element-ns:=
                $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NSURI; declare variable $rf:element-name:=
                $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME; declare variable $rf:default-path:=
                $config:default-resourcefragments-path; declare %private function
                rf:make-div($resourcefragment-pid, $fileid as xs:string, $label as xs:string?) as
                element(mets:div) { &lt;mets:div TYPE="{$config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE}"
                ID="{$resourcefragment-pid}" LABEL="{$label}"&gt; &lt;mets:fptr&gt; &lt;mets:area
                FILEID="{$fileid}" BEGIN="{$resourcefragment-pid}" END="{$resourcefragment-pid}"
                BETYPE="IDREF"/&gt; &lt;/mets:fptr&gt; &lt;/mets:div&gt; }; (:~ : Registers the
                resourcefragments of a resource, stored in a fcs:Resource wrapper, : with the mets
                record of the resource. : : @param $resource-pid the pid of the resource : @param
                $filepath the db-path to the xml file w/ extracted resourcefragments. we expect a
                structure like &lt;fcs:Resource&gt;&lt;fcs:ResourceFragment
                resourcefragment-pid=""&gt;... : @param $project-pid the ID of the project to
                operate in ~:) declare function rf:new($resource-pid as xs:string, $filepath as
                xs:string,$project-pid as xs:string) as xs:string* { let
                $fragments:=doc($filepath)//*[local-name(.) eq $rf:element-name and namespace-uri(.)
                eq $rf:element-ns] let
                $fragmentfile-id:=$resource-pid||$config:RESOURCE_RESOURCEFRAGMENT_FILEID_SUFFIX let
                $this:fragmentfile:=resource:make-file($fragmentfile-id,$filepath,'fragments') let
                $register-fragmentfile:=
                resource:add-file($this:fragmentfile,$resource-pid,$project-pid) return if
                (doc-available($filepath)) then for $f in $fragments let
                $this:pid:=xs:string($f/@*[name(.) eq $config:RESOURCEFRAGMENT_PID_NAME]) let
                $this:label:=xs:string($f/@*[name(.) eq $config:RESOURCEFRAGMENT_LABEL_NAME]) let
                $this:div:=rf:make-div($this:pid,$fragmentfile-id, $this:label) let
                $update:=resource:add-fragment($this:div,$resource-pid,$project-pid) return
                $this:pid else util:log-app("INFO",$config:app-name,"extracted resourcefragments
                file not found at "||$filepath) }; (:~ : This function removes a resourcefragment
                from the resources' structMap-entry (mets:div). : It does *not* remove the mets:file
                which is referenced by the fragment, as other resourcefragments : are likely to need
                it, unless it was the only, whose @FILEID pointed to this. In that case : also the
                mets:file element in the resource's mets:fileGrp is deleted. : : @param
                $resourcefragment-pid the pid of the resourcefragment to work on : @param
                $resource-pid the pid of the resoruce to delete : @return empty sequence ~:) declare
                function rf:remove($resourcefragment-pid as xs:string,$resource-pid as
                xs:string,$project-pid as xs:string) as empty() { let
                $mets:resource:=resource:get($resource-pid,$project-pid),
                $mets:fragment:=$mets:resource//mets:div[@TYPE eq
                $config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE and @ID eq $resourcefragment-pid],
                $mets:fileID:=$mets:fragment/mets:fptr//@FILEID let $delete:=update delete
                $mets:fragment return if (exists($mets:resource/root()//mets:fptr[.//@FILEID =
                $mets:fileID])) then () else
                resource:remove-file($mets:fileID,$resource-pid,$project-pid) }; (:~ : The two
                argument version of this function removes all resourcefragments from the resource's
                structMap entry. : : @param $resource-pid the pid of the resoruce to delete : @param
                $project-pid the id of the project : @return empty sequence ~:) declare function
                rf:remove($resource-pid as xs:string,$project-pid as xs:string) as empty() { let
                $mets:resource:=resource:get($resource-pid,$project-pid),
                $mets:fragments:=$mets:resource//mets:div[@TYPE eq
                $config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE], $mets:fileids:=$mets:fragments//@FILEID
                return ( update delete $mets:resource//mets:div[@TYPE eq
                $config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE], for $fileid in $mets:fileids return
                resource:remove-file($file-id,$resource-pid,$project-pid) ) }; (:~ : This function
                removes the data of a resourcefragment container and unregisters it in the
                resource's mets entry. : : @param $resourcefragment-pid the pid of the
                resourcefragment to work on : @param $resource-pid the pid of the resoruce to delete
                : @param $project-pid the pid of the project : @return empty sequence ~:) declare
                function rf:remove-data($resource-pid as xs:string,$project-pid as xs:string) as
                empty() { let $rf:filepath:= rf:path($resource-pid,$project-pid), $rf:filename:=
                tokenize($rf:filepath,'/')[last()],
                $rf:collection:=substring-before($rf:filepath,$rf:filename) return
                (xmldb:remove($rf:collection,$rf:filename),rf:remove($resource-pid,$project-pid)) };
                (:~ : This function returns the mets:div entry of the resource fragment. : : @param
                $resourcefragment-pid the pid of the resourcefragment : @param $resource-pid the pid
                of the resource : @param $project-pid the id of the project : @return the mets:div
                entry of the resourcefragment. ~:) declare function rf:record($resourcefragment-pid
                as xs:string, $resource-pid as xs:string, $project-pid as xs:string) as
                element(mets:div)? { let $resource:= resource:get($resource-pid, $project-pid)
                return $resource//mets:div[@TYPE eq $config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE and
                @ID eq $resourcefragment-pid] }; (:~ : The two parameter version of this function
                gets the mets:file entry of the resource fragments file. : : @param $resource-pid
                the pid of the resource : @param $project-pid the id of the project : @return the
                mets:file element of the resourcefragments file. ~:) declare function
                rf:file($resource-pid as xs:string, $project-pid as xs:string) as
                element(mets:file)? { let $rf:fileGrp:=resource:files($resource-pid,$project-pid)
                return $rf:fileGrp/mets:file[@USE eq $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE] };
                (:~ : Gets the database path to the resourcefragments cache of a resource. : :
                @param $resource-pid the pid of the resource : @param $project-pid the id of the
                project : @return ~:) declare function rf:path($resource-pid as xs:string,
                $project-pid as xs:string) as xs:string* { let
                $rf:fileGrp:=resource:files($resource-pid, $project-pid) return
                $rf:fileGrp/mets:file[@USE eq
                $config:RESOURCE_RESOURCEFRAGMENTS_FILE_USE]/mets:FLocat/@xlink:href }; (:~ : The
                three argument version of this function fetches content of the requested
                resourcefragment. : : @param $resourcefragment-pid the pid of the resourcefragment :
                @param $resource-pid the pid of the resource : @param $project-pid the pid of the
                project : @return ~:) declare function rf:get($resourcefragment-pid as xs:string,
                $resource-pid as xs:string, $project-pid as xs:string) as element()? { let
                $rf:location:= rf:path($resource-pid, $project-pid), $rf:doc := if
                (doc-available($rf:location)) then doc($rf:location) else
                util:log-app("INFO",$config:app-name,"Could not locate resourcefragments from
                "||$rf:location) return
                util:eval('$rf:doc//*[@'||$config:RESOURCEFRAGMENT_PID_NAME||'="'||$resourcefragment-pid||'"]')
                }; (:~ Finds the resourcefragmentS(!) containing an element with given @cr:id :
                @param $element-id the id of a xml-element expected inside some resourcefragment :
                @param $resource-pid the pid of the resource : @param $project-pid the pid of the
                project : @return resourcefragment of the containing resourcefragment :) declare
                function rf:lookup($element-id as xs:string, $resource-pid as xs:string,
                $project-pid as xs:string) as element()* { (: rf:dump($resource-pid,
                $project-pid)/id($element-id)/ancestor::fcs:resourceFragment :) (:
                rf:dump($resource-pid, $project-pid)//*[@cr:id eq
                $element-id]/ancestor::fcs:resourceFragment :) let $ids :=
                lt:lookup($element-id,$resource-pid,$project-pid) return for $i in $ids return
                rf:get($i,$resource-pid,$project-pid) }; (:~ Finds the resourcefragmentS(!)
                containing an element with given @cr:id, returning its IDs : @param $element-id the
                id of a xml-element expected inside some resourcefragment : @param $resource-pid the
                pid of the resource : @param $project-pid the pid of the project : @return pid of
                the containing resourcefragment :) declare function rf:lookup-id($element-id as
                xs:string, $resource-pid as xs:string, $project-pid as xs:string) as xs:string* {
                (:let $rf := rf:lookup($element-id, $resource-pid, $project-pid) return
                util:eval('$rf/xs:string(@'||$config:RESOURCEFRAGMENT_PID_NAME||')'):)
                lt:lookup($element-id,$resource-pid,$project-pid) }; (:~ : Dumps the full content of
                the resourcefragments cache of a resource. : : @param $resource-pid the pid of the
                resource : @param $project-pid the pid of the project : @return the content of the
                resourcefragments chache ~:) declare function rf:dump($resource-pid as xs:string,
                $project-pid as xs:string) as document-node() { let $rf:location:=
                rf:path($resource-pid, $project-pid) return if (doc-available($rf:location)) then
                doc($rf:location) else util:log-app("INFO",$config:app-name, "resourcefragments
                cache document not available at "||$rf:location) }; (:~ : Generates the
                resourcefragments cache for a given resource, stores it to the database and :
                registers it with the resource's structMap egentry. Gives back the database path to
                the cache file. : : @param $resource-pid the pid of the resource : @param
                $project-pid the id of the project : @return the database path to the
                resourcefragments cache ~:) declare function rf:generate($resource-pid as xs:string,
                $project-pid as xs:string) as xs:string? { let $master:=
                resource:master($resource-pid,$project-pid), $master_filename :=
                util:document-name($master), $master_collection := util:collection-name($master),
                $path-to-master := base-uri($master), $config:= config:config($project-pid),
                $stored-wc := wc:get-data($resource-pid,$project-pid), $working-copy:= if
                (exists($stored-wc)) then $stored-wc else let $wc:new:=
                wc:generate($resource-pid,$project-pid) return
                wc:get-data($resource-pid,$project-pid), $index-name :=
                $config:INDEX_RESOURCEFRAGMENT_DELIMITER, $rf:xpathexpr :=
                index:index-as-xpath($index-name, $project-pid), $rf:xpathexpr-label :=
                index:index-as-xpath($index-name, $project-pid,'label-only') return if
                ($rf:xpathexpr = $index-name) then util:log-app("INFO",$config:app-name, "Could not
                resolve index name "||$index-name||" in mappings for project "||$project-pid) else
                let $define-ns:= let $mappings:= config:mappings($config), $namespaces:=
                $mappings//namespaces return for $ns in $namespaces/ns let $prefix:= $ns/@prefix,
                $namespace-uri:=$ns/@uri let $log:=util:log-app("INFO",$config:app-name, "declaring
                namespace "||$prefix||"='"||$namespace-uri||"'") return
                util:declare-namespace(xs:string($prefix), xs:anyURI($namespace-uri)) (: extract
                fragments and create wrapper elements for each :) let
                $all-fragments:=util:eval("$working-copy//"||$rf:xpathexpr) (: CHECK: shouldn't this
                be checked for every $fragment separately :) let $fragment-element-has-content:=some
                $x in $all-fragments satisfies exists($x/node()) let $fragments-extracted:= for $pb1
                at $pos in $all-fragments (: let
                $id:=$resource-pid||$config:RESOURCE_RESOURCEFRAGMENT_FILEID_SUFFIX||format-number($pos,
                '00000000'):) let
                $id:=$resource-pid||$config:RESOURCE_RESOURCEFRAGMENT_ID_SUFFIX||$pos let $label :=
                util:eval("$pb1/"||$rf:xpathexpr-label) let $fragment:= (: CHECK: shouldn't this be
                checked for every $fragment separately :) if ($fragment-element-has-content) then
                $pb1 else let $log:=util:log-app("INFO",$config:app-name,"processing
                resourcefragment w/ pid="||xs:string($id)) let $pb2:=util:eval("(for $x in
                $all-fragments where $x &gt;&gt; $pb1 return $x)[1]") (: if no subsequent element,
                dont trying to generate fragment will fail :) return if (empty($pb2)) then $pb1 (:
                else util:parse(replace(util:get-fragment-between($pb1, $pb2, true(),
                true()),'&amp;amp;','&amp;amp;amp;')) :) else
                util:parse-html(util:get-fragment-between($pb1, $pb2, true(), true()))/HTML/BODY/*
                return element { QName( $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NSURI,
                $config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME ) }{ attribute
                {$config:PROJECT_PID_NAME} {$project-pid}, attribute {$config:RESOURCE_PID_NAME}
                {$resource-pid}, attribute {$config:RESOURCEFRAGMENT_PID_NAME} {$id}, attribute
                {$config:RESOURCEFRAGMENT_LABEL_NAME} {$label}, $fragment } (: pack extracted
                fragments into container and add metadata :) let $rf:container:= element { QName(
                $config:RESOURCE_RESOURCE_ELEMENT_NSURI, $config:RESOURCE_RESOURCE_ELEMENT_NAME ) }{
                attribute {$config:PROJECT_PID_NAME} {$project-pid}, attribute
                {$config:RESOURCE_PID_NAME} {$resource-pid}, attribute timestamp
                {current-dateTime()}, attribute masterFileLastmodified
                {xmldb:last-modified($master_collection,$master_filename)}, attribute masterFilePath
                {$path-to-master}, $fragments-extracted } (: store the fragments container in the
                database :) (: first returns full path down to file, second one only the collection
                - complicated to handle in case, the file already exists let $rf:path-param :=
                (rf:path($resource-pid,$project-pid),
                project:path($project-pid,"resourcefragments"))[1],:) let $rf:path-param :=
                project:path($project-pid,"resourcefragments"), $rf:path:=
                replace($rf:path-param,'/$',''), $rf:filename:=
                $config:RESOURCE_RESOURCEFRAGMENT_FILENAME_PREFIX||$master_filename, $rf:filepath:=
                $rf:path||"/"||$rf:filename (: let
                $rf:store:=repo-utils:store-in-cache($rf:filename,$rf:path,$rf:container,$config)
                allows to overwrite :) let
                $rf:store:=repo-utils:store($rf:path,$rf:filename,$rf:container,true(),$config) (:
                register resourcefragments with the METS record :) let
                $update-mets:=rf:new($resource-pid,$rf:filepath,$project-pid) return $rf:filepath }; </f>
            <f n="templates.xql">xquery version "3.0";&#xd; &#xd; module namespace
                templates="http://exist-db.org/xquery/templates";&#xd; &#xd; (:~ &#xd; : HTML
                templating module&#xd; : &#xd; : @version 2.0&#xd; : @author Wolfgang Meier&#xd;
                :)&#xd; import module namespace config="http://exist-db.org/xquery/apps/config" at
                "config.xqm";&#xd; &#xd; declare variable $templates:CONFIG_STOP_ON_ERROR :=
                "stop-on-error";&#xd; &#xd; declare variable $templates:CONFIGURATION :=
                QName("http://exist-db.org/xquery/templates", "configuration");&#xd; declare
                variable $templates:CONFIGURATION_ERROR :=
                QName("http://exist-db.org/xquery/templates", "ConfigurationError");&#xd; declare
                variable $templates:NOT_FOUND := QName("http://exist-db.org/xquery/templates",
                "NotFound");&#xd; declare variable $templates:TOO_MANY_ARGS :=
                QName("http://exist-db.org/xquery/templates", "TooManyArguments");&#xd; declare
                variable $templates:TYPE_ERROR := QName("http://exist-db.org/xquery/templates",
                "TypeError");&#xd; &#xd; (:~ &#xd; : Start processing the provided content. Template
                functions are looked up by calling the&#xd; : provided function $resolver. The
                function should take a name as a string&#xd; : and return the corresponding function
                item. The simplest implementation of this function could&#xd; : look like this:&#xd;
                : &#xd; : &lt;pre&gt;function($functionName as xs:string, $arity as xs:int) {
                function-lookup(xs:QName($functionName), $arity) }&lt;/pre&gt;&#xd; :&#xd; : @param
                $content the sequence of nodes which will be processed&#xd; : @param $resolver a
                function which takes a name and returns a function with that name&#xd; : @param
                $model a sequence of items which will be passed to all called template functions.
                Use this to pass&#xd; : information between templating instructions.&#xd; :)&#xd;
                declare function templates:apply($content as node()+, $resolver as
                function(xs:string) as item()?, $model as map(*)?,&#xd; $configuration as map(*)?)
                {&#xd; let $model := if (exists($model)) then $model else map:new()&#xd; let
                $configuration := &#xd; if (exists($configuration)) then &#xd;
                map:new(($configuration, map { "resolve" := $resolver }))&#xd; else&#xd; map {
                "resolve" := $resolver }&#xd; let $model := map:new(($model,
                map:entry($templates:CONFIGURATION, $configuration)))&#xd; for $root in
                $content&#xd; return&#xd; templates:process($root, $model)&#xd; };&#xd; &#xd;
                declare function templates:apply($content as node()+, $resolver as
                function(xs:string) as item()?, $model as map(*)?) {&#xd; templates:apply($content,
                $resolver, $model, ())&#xd; };&#xd; &#xd; (:~&#xd; : Continue template processing on
                the given set of nodes. Call this function from&#xd; : within other template
                functions to enable recursive processing of templates.&#xd; :&#xd; : @param $nodes
                the nodes to process&#xd; : @param $model a sequence of items which will be passed
                to all called template functions. Use this to pass&#xd; : information between
                templating instructions.&#xd; :)&#xd; declare function templates:process($nodes as
                node()*, $model as map(*)) {&#xd; for $node in $nodes&#xd; return&#xd; typeswitch
                ($node)&#xd; case document-node() return&#xd; for $child in $node/node() return
                templates:process($child, $model)&#xd; case element() return&#xd; let $instructions
                := templates:get-instructions($node/@class)&#xd; return&#xd; if ($instructions)
                then&#xd; for $instruction in $instructions&#xd; return&#xd;
                templates:call($instruction, $node, $model)&#xd; else&#xd; element {
                node-name($node) } {&#xd; $node/@*, for $child in $node/node() return
                templates:process($child, $model)&#xd; }&#xd; default return&#xd; $node&#xd; };&#xd;
                &#xd; declare %private function templates:get-instructions($class as xs:string?) as
                xs:string* {&#xd; for $name in tokenize($class, "\s+")&#xd; where
                templates:is-qname($name)&#xd; return&#xd; $name&#xd; };&#xd; &#xd; declare %private
                function templates:call($class as xs:string, $node as element(), $model as map(*))
                {&#xd; let $paramStr := substring-after($class, "?")&#xd; let $parameters :=
                templates:parse-parameters($paramStr)&#xd; let $func := if ($paramStr) then
                substring-before($class, "?") else $class&#xd; let $call := templates:resolve(10,
                $func, $model($templates:CONFIGURATION)("resolve"))&#xd; return&#xd; if
                (exists($call)) then&#xd; templates:call-by-introspection($node, $parameters,
                $model, $call)&#xd; else if ($model($templates:CONFIGURATION)("stop-on-error"))
                then&#xd; error($templates:NOT_FOUND, "No template function found for call " ||
                $func)&#xd; else&#xd; (: Templating function not found: just copy the element
                :)&#xd; element { node-name($node) } {&#xd; $node/@*, for $child in $node/node()
                return templates:process($child, $model)&#xd; }&#xd; };&#xd; &#xd; declare %private
                function templates:call-by-introspection($node as element(), $parameters as
                element(parameters), $model as map(*), &#xd; $fn as function(*)) {&#xd; let $inspect
                := util:inspect-function($fn)&#xd; let $args := templates:map-arguments($inspect,
                $parameters)&#xd; return&#xd; templates:process-output(&#xd; $node,&#xd;
                $model,&#xd; templates:call-with-args($fn, $args, $node, $model),&#xd; $inspect&#xd;
                )&#xd; };&#xd; &#xd; declare %private function templates:call-with-args($fn as
                function(*), $args as (function() as item()*)*, &#xd; $node as element(), $model as
                map(*)) {&#xd; switch (count($args))&#xd; case 0 return&#xd; $fn($node, $model)&#xd;
                case 1 return&#xd; $fn($node, $model, $args[1]())&#xd; case 2 return&#xd; $fn($node,
                $model, $args[1](), $args[2]())&#xd; case 3 return&#xd; $fn($node, $model,
                $args[1](), $args[2](), $args[3]())&#xd; case 4 return&#xd; $fn($node, $model,
                $args[1](), $args[2](), $args[3](), $args[4]())&#xd; case 5 return&#xd; $fn($node,
                $model, $args[1](), $args[2](), $args[3](), $args[4](), $args[5]())&#xd; case 6
                return&#xd; $fn($node, $model, $args[1](), $args[2](), $args[3](), $args[4](),
                $args[5](), $args[6]())&#xd; case 7 return&#xd; $fn($node, $model, $args[1](),
                $args[2](), $args[3](), $args[4](), $args[5](), $args[6](), $args[7]())&#xd; case 8
                return&#xd; $fn($node, $model, $args[1](), $args[2](), $args[3](), $args[4](),
                $args[5](), $args[6](), $args[7](), $args[8]())&#xd; default return&#xd;
                error($templates:TOO_MANY_ARGS, "Too many arguments to function " ||
                function-name($fn))&#xd; };&#xd; &#xd; declare %private function
                templates:process-output($node as element(), $model as map(*), $output as item()*,
                &#xd; $inspect as element(function)) {&#xd; let $wrap := &#xd;
                $inspect/annotation[ends-with(@name, ":wrap")]&#xd; [@namespace =
                "http://exist-db.org/xquery/templates"]&#xd; return&#xd; if ($wrap) then&#xd;
                element { node-name($node) } {&#xd; $node/@*,&#xd; templates:process-output($node,
                $model, $output)&#xd; }&#xd; else&#xd; templates:process-output($node, $model,
                $output)&#xd; };&#xd; &#xd; declare %private function templates:process-output($node
                as element(), $model as map(*), $output as item()*) {&#xd; typeswitch($output)&#xd;
                case map(*) return&#xd; templates:process($node/node(), map:new(($model,
                $output)))&#xd; default return&#xd; $output&#xd; };&#xd; &#xd; declare %private
                function templates:map-arguments($inspect as element(function), $parameters as
                element(parameters)) {&#xd; let $args := $inspect/argument&#xd; return&#xd; if
                (count($args) &gt; 2) then&#xd; for $arg in subsequence($inspect/argument, 3)&#xd;
                return&#xd; templates:map-argument($arg, $parameters)&#xd; else&#xd; ()&#xd; };&#xd;
                &#xd; declare %private function templates:map-argument($arg as element(argument),
                $parameters as element(parameters)) &#xd; as function() as item()* {&#xd; let $var
                := $arg/@var&#xd; let $type := $arg/@type/string()&#xd; let $param := &#xd; (&#xd;
                request:get-parameter($var, ()), &#xd; $parameters/param[@name = $var]/@value,&#xd;
                templates:arg-from-annotation($var, $arg)&#xd; )[1]&#xd; let $data :=&#xd; try
                {&#xd; templates:cast($param, $type)&#xd; } catch * {&#xd;
                error($templates:TYPE_ERROR, "Failed to cast parameter value '" || $param || "' to
                the required target type for " ||&#xd; "template function parameter $" || $var || "
                of function " || ($arg/../@name) || ". Required type was: " ||&#xd; $type || ". " ||
                $err:description)&#xd; }&#xd; return&#xd; function() {&#xd; $data&#xd; }&#xd;
                };&#xd; &#xd; declare %private function templates:arg-from-annotation($var as
                xs:string, $arg as element(argument)) {&#xd; let $anno := &#xd;
                $arg/../annotation[ends-with(@name, ":default")]&#xd; [@namespace =
                "http://exist-db.org/xquery/templates"]&#xd; [value[1] = $var]&#xd; for $value in
                subsequence($anno/value, 2)&#xd; return&#xd; string($value)&#xd; };&#xd; &#xd;
                declare %private function templates:resolve($arity as xs:int, $func as xs:string,
                &#xd; $resolver as function(xs:string, xs:int) as function(*)) {&#xd; if ($arity
                &lt; 2) then&#xd; ()&#xd; else&#xd; let $fn := $resolver($func, $arity)&#xd;
                return&#xd; if (exists($fn)) then&#xd; $fn&#xd; else&#xd; templates:resolve($arity -
                1, $func, $resolver)&#xd; };&#xd; &#xd; declare %private function
                templates:parse-parameters($paramStr as xs:string?) as element(parameters) {&#xd;
                &lt;parameters&gt;&#xd; {&#xd; for $param in tokenize($paramStr, "&amp;amp;")&#xd;
                let $key := substring-before($param, "=")&#xd; let $value := substring-after($param,
                "=")&#xd; where $key&#xd; return&#xd; &lt;param name="{$key}"
                value="{$value}"/&gt;&#xd; }&#xd; &lt;/parameters&gt;&#xd; };&#xd; &#xd; declare
                %private function templates:is-qname($class as xs:string) as xs:boolean {&#xd;
                matches($class, "^[^:]+:[^:]+")&#xd; };&#xd; &#xd; declare %private function
                templates:cast($values as item()*, $targetType as xs:string) {&#xd; for $value in
                $values&#xd; return&#xd; if ($targetType != "xs:string" and string-length($value) =
                0) then&#xd; (: treat "" as empty sequence :)&#xd; ()&#xd; else&#xd; switch
                ($targetType)&#xd; case "xs:string" return&#xd; string($value)&#xd; case
                "xs:integer" case "xs:int" case "xs:long" return&#xd; xs:integer($value)&#xd; case
                "xs:decimal" return&#xd; xs:decimal($value)&#xd; case "xs:float" case "xs:double"
                return&#xd; xs:double($value)&#xd; case "xs:date" return&#xd; xs:date($value)&#xd;
                case "xs:dateTime" return&#xd; xs:dateTime($value)&#xd; case "xs:time" return&#xd;
                xs:time($value)&#xd; case "element()" return&#xd; util:parse($value)/*&#xd; case
                "text()" return&#xd; text { string($value) }&#xd; default return&#xd; $value&#xd;
                };&#xd; &#xd;
                (:-----------------------------------------------------------------------------------&#xd;
                : Standard templates&#xd;
                :-----------------------------------------------------------------------------------:)&#xd;
                &#xd; &#xd; (:~&#xd; : This is the initializing function, that every template should
                call (very soon, i.e. at some of the top elements)&#xd; : it provides context
                information to the other modules, currently it fetches the project-config file&#xd;
                : &#xd; : @param $node the HTML node with the class attribute which triggered this
                call&#xd; : @param $model a map containing arbitrary data - used to pass information
                between template calls&#xd; : @param $project project-identifier&#xd; :)&#xd;
                declare function templates:init($node as node(), $model as map(*), $project as
                xs:string?) {&#xd; map { &#xd; "config" := config:config($project) &#xd; }&#xd;
                };&#xd; &#xd; &#xd; (:declare function templates:include($node as node(), $model as
                map(*), $path as xs:string) {&#xd; templates:process(config:resolve($model, $path),
                $model)&#xd; };&#xd; &#xd; :)&#xd; declare %templates:default("filter", "") &#xd;
                function templates:include($node as node(), $model as map(*), $path as xs:string,
                $filter as xs:string) {&#xd; let $content := config:resolve($model, $path)&#xd; let
                $restricted-content := if ($filter != '') then &#xd; (: try to handle namespaces
                dynamically &#xd; by switching to source namespace :)&#xd; let $ns-uri :=
                namespace-uri($content[1]/*) &#xd; let $ns :=
                util:declare-namespace("",xs:anyURI($ns-uri))&#xd; return
                util:eval(concat("$content//", $filter)) else $content &#xd; return
                templates:process($restricted-content , $model)&#xd; };&#xd; &#xd; (:~ extra
                function for detail-include, to be able to pass a path-param &#xd; (otherwise it
                would overwrite also other includes )&#xd; :)&#xd; declare&#xd; %templates:wrap&#xd;
                %templates:default("filter", "") &#xd; function templates:include-detail($node as
                node(), $model as map(*), $path-detail as xs:string, $filter as xs:string) {&#xd;
                let $content := config:resolve($model, $path-detail)&#xd; let $restricted-content :=
                if ($filter != '' and exists($content)) then &#xd; (: try to handle namespaces
                dynamically &#xd; by switching to source namespace :)&#xd; let $ns-uri :=
                namespace-uri($content[1]/*) &#xd; let $ns :=
                util:declare-namespace("",xs:anyURI($ns-uri))&#xd; return
                util:eval(concat("$content//", $filter)) else $content &#xd; return
                templates:process($restricted-content , $model)&#xd; };&#xd; &#xd; &#xd; declare
                function templates:surround($node as node(), $model as map(*), $with as xs:string,
                $at as xs:string?, $using as xs:string?) {&#xd; let $path :=
                concat($config:app-root, "/", $with)&#xd; let $content :=&#xd; if ($using) then&#xd;
                config:resolve($model, $with)//*[@id = $using]&#xd; else&#xd; config:resolve($model,
                $with)&#xd; let $merged := templates:process-surround($content, $node, $at)&#xd;
                return&#xd; templates:process($merged, $model)&#xd; };&#xd; &#xd; declare function
                templates:process-surround($node as node(), $content as node(), $at as xs:string)
                {&#xd; typeswitch ($node)&#xd; case document-node() return&#xd; for $child in
                $node/node() return templates:process-surround($child, $content, $at)&#xd; case
                element() return&#xd; if ($node/@id eq $at) then&#xd; element { node-name($node) }
                {&#xd; $node/@*, $content/node()&#xd; }&#xd; else&#xd; element { node-name($node) }
                {&#xd; $node/@*, for $child in $node/node() return
                templates:process-surround($child, $content, $at)&#xd; }&#xd; default return&#xd;
                $node&#xd; };&#xd; &#xd; declare function templates:if-parameter-set($node as
                node(), $model as map(*), $param as xs:string) as node()* {&#xd; let $param :=
                request:get-parameter($param, ())&#xd; return&#xd; if ($param and
                string-length($param) gt 0) then&#xd; templates:process($node/node(), $model)&#xd;
                else&#xd; ()&#xd; };&#xd; &#xd; declare function templates:if-parameter-unset($node
                as node(), $model as item()*, $param as xs:string) as node()* {&#xd; let $param :=
                request:get-parameter($param, ())&#xd; return&#xd; if (not($param) or
                string-length($param) eq 0) then&#xd; (: $node:)&#xd;
                templates:process($node/node(), $model)&#xd; else&#xd; ()&#xd; };&#xd; &#xd; declare
                function templates:if-module-missing($node as node(), $model as map(*), $uri as
                xs:string, $at as xs:string) {&#xd; try {&#xd; util:import-module($uri, "testmod",
                $at)&#xd; } catch * {&#xd; (: Module was not found: process content :)&#xd;
                templates:process($node/node(), $model)&#xd; }&#xd; };&#xd; &#xd; declare function
                templates:display-source($node as node(), $model as map(*), $lang as xs:string?)
                {&#xd; let $source := replace($node/string(), "^\s*(.*)\s*$", "$1")&#xd; let
                $context := request:get-context-path()&#xd; let $eXidePath := if
                (doc-available("/db/eXide/index.html")) then "apps/eXide" else "eXide"&#xd;
                return&#xd; &lt;div class="code"&gt;&#xd; &lt;pre class="brush: {if ($lang) then
                $lang else 'xquery'}"&gt;&#xd; { $source }&#xd; &lt;/pre&gt;&#xd; &lt;a class="btn"
                href="{$context}/{$eXidePath}/index.html?snip={encode-for-uri($source)}"
                target="eXide"&#xd; title="Opens the code in eXide in new tab or existing tab if it
                is already open."&gt;Try it&lt;/a&gt;&#xd; &lt;/div&gt;&#xd; };&#xd; &#xd; declare
                function templates:load-source($node as node(), $model as map(*)) as node()* {&#xd;
                let $href := $node/@href/string()&#xd; let $context :=
                request:get-context-path()&#xd; let $eXidePath := if
                (doc-available("/db/eXide/index.html")) then "apps/eXide" else "eXide"&#xd;
                return&#xd; &lt;a
                href="{$context}/{$eXidePath}/index.html?open={$config:app-root}/{$href}"
                target="eXide"&gt;{$node/node()}&lt;/a&gt;&#xd; };&#xd; &#xd; (:~&#xd; Processes
                input and select form controls, setting their value/selection to&#xd; values found
                in the request - if present.&#xd; :)&#xd; declare function
                templates:form-control($node as node(), $model as map(*)) as node()* {&#xd;
                typeswitch ($node)&#xd; case element(input) return&#xd; let $name :=
                $node/@name&#xd; let $value := request:get-parameter($name, ())&#xd; return&#xd; if
                ($value) then&#xd; element { node-name($node) } {&#xd; $node/@* except
                $node/@value,&#xd; attribute value { $value },&#xd; $node/node()&#xd; }&#xd;
                else&#xd; $node&#xd; case element(select) return&#xd; let $value :=
                request:get-parameter($node/@name/string(), ())&#xd; return&#xd; element {
                node-name($node) } {&#xd; $node/@* except $node/@class,&#xd; for $option in
                $node/option&#xd; return&#xd; &lt;option&gt;&#xd; {&#xd; $option/@*,&#xd; if
                ($option/@value = $value) then&#xd; attribute selected { "selected" }&#xd; else&#xd;
                (),&#xd; $option/node()&#xd; }&#xd; &lt;/option&gt;&#xd; }&#xd; default return&#xd;
                $node&#xd; };&#xd; &#xd; declare function templates:error-description($node as
                node(), $model as map(*)) {&#xd; let $input :=
                request:get-attribute("org.exist.forward.error")&#xd; return&#xd; element {
                node-name($node) } {&#xd; $node/@*,&#xd; util:parse($input)//message/string()&#xd;
                }&#xd; };&#xd; &#xd; declare function templates:fix-links($node as node(), $model as
                map(*), $root as xs:string) {&#xd; let $prefix :=&#xd; if ($root eq "context")
                then&#xd; request:get-context-path()&#xd; else&#xd;
                concat(request:get-context-path(), request:get-attribute("$exist:prefix"),
                request:get-attribute("$exist:controller"))&#xd; let $temp := &#xd; element {
                node-name($node) } {&#xd; $node/@* except $node/@class,&#xd; attribute class {
                replace($node/@class, "\s*templates:fix-links[^\s]*", "")},&#xd; for $child in
                $node/node() return templates:fix-links($child, $prefix)&#xd; }&#xd; return&#xd;
                templates:process($temp, $model)&#xd; };&#xd; &#xd; declare function
                templates:fix-links($node as node(), $prefix as xs:string) {&#xd; typeswitch
                ($node)&#xd; case element(a) return&#xd; let $href := $node/@href&#xd; return&#xd;
                if (starts-with($href, "/")) then&#xd; &lt;a href="{$prefix}{$href}"&gt;&#xd; {
                $node/@* except $href, $node/node() }&#xd; &lt;/a&gt;&#xd; else&#xd; $node&#xd; case
                element() return&#xd; element { node-name($node) } {&#xd; $node/@*, for $child in
                $node/node() return templates:fix-links($child, $prefix)&#xd; }&#xd; default
                return&#xd; $node&#xd; };</f>
            <f n="toc.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                toc="http://aac.ac.at/content_repository/toc";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd; import module
                namespace project="http://aac.ac.at/content_repository/project" at
                "project.xqm";&#xd; import module namespace
                resource="http://aac.ac.at/content_repository/resource" at "resource.xqm";&#xd;
                import module namespace ltb="http://aac.ac.at/content_repository/lookuptable" at
                "lookuptable.xqm";&#xd; import module namespace fcs = "http://clarin.eu/fcs/1.0" at
                "../modules/fcs/fcs.xqm";&#xd; import module namespace
                wc="http://aac.ac.at/content_repository/workingcopy" at "wc.xqm";&#xd; &#xd; declare
                namespace mets="http://www.loc.gov/METS/";&#xd; declare namespace
                cr="http://aac.ac.at/content_repository";&#xd; (:~&#xd; : Getter and Setter for
                tables of contents of resources. &#xd; :)&#xd; &#xd; &#xd; (:~&#xd; : generates the
                table of contents of a resource. The structure of the resource is defined&#xd; : by
                one or more index definitions in the project's mappings. The functions scans the
                &#xd; : resource's working copy for matching elements recursively and writes the toc
                to a &#xd; : special mets:structMap TYPE="toc" ID="{$resource-pid}_toc"&#xd; :)&#xd;
                declare function toc:generate($mapping-keys as xs:string+, $resource-pid as
                xs:string, $project-pid as xs:string) as item()* {&#xd; let
                $mappings:=project:map($project-pid),&#xd; $indexes := for $m in $mapping-keys
                return $mappings//index[@key eq $m],&#xd; $paths := for $i in $indexes return
                fcs:index-as-xpath($i,$project-pid,()),&#xd; $ltb-exists := if
                (not(resource:path($resource-pid,$project-pid,"lookuptable")=''))&#xd; then
                ltb:generate($resource-pid,$project-pid)&#xd; else (),&#xd; $ltb-path :=
                "xmldb:exist://"||resource:path($resource-pid,$project-pid,"lookuptable"),&#xd;
                $project-path := "xmldb:exist://"||project:filepath($project-pid)&#xd; &#xd; let
                $resource-label := resource:label($resource-pid, $project-pid)&#xd; let
                $resource-ref := '#'||$resource-pid&#xd; let $xslTemplates:= &#xd; for $p at $pos in
                $paths&#xd; let $index := $indexes[position() eq $pos]&#xd; return&#xd;
                &lt;xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:mets="http://www.loc.gov/METS/" match="{$p}"&gt;&#xd; &lt;xsl:variable
                name="cr:id" select="@cr:id"/&gt;&#xd; &lt;xsl:variable name="content"
                as="item()*"&gt;&#xd; &lt;xsl:apply-templates/&gt;&#xd; &lt;/xsl:variable&gt;&#xd;
                &#xd; &lt;mets:div TYPE="{$index/@key}" ID="&amp;#x007b;$cr:id&amp;#x007d;"&gt;&#xd;
                {if (exists($index/path/@label))&#xd; then &#xd; &lt;xsl:attribute name="LABEL"
                select="({string-join($index/path/@label,'|')})[1]"/&gt;&#xd; else &#xd;
                &lt;xsl:attribute name="LABEL" select="concat('{$index/@key}
                ',count(preceding::{$p})+1)"/&gt;&#xd; }&#xd; &lt;xsl:choose&gt;&#xd; &lt;xsl:when
                test="empty($content)"&gt;&#xd; &lt;xsl:for-each
                select="key('rf',$cr:id,$ltb)"&gt;&#xd; &lt;xsl:sequence
                select="key('rf-div',@resourcefragment-pid,$project)/mets:fptr[mets:area]"/&gt;&#xd;
                &lt;/xsl:for-each&gt;&#xd; &lt;/xsl:when&gt;&#xd; &lt;xsl:otherwise&gt;&#xd;
                &lt;xsl:sequence select="$content"/&gt;&#xd; &lt;/xsl:otherwise&gt;&#xd;
                &lt;/xsl:choose&gt;&#xd; &#xd; &#xd; &lt;/mets:div&gt;&#xd;
                &lt;/xsl:template&gt;&#xd; let $xsl := &#xd; &lt;xsl:stylesheet
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&#xd;
                xmlns:xs="http://www.w3.org/2001/XMLSchema"&#xd;
                xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"&#xd;
                xmlns:mets="http://www.loc.gov/METS/"&#xd;
                xmlns:xlink="http://www.w3.org/1999/xlink"&#xd;
                xmlns:fcs="http://clarin.eu/fcs/1.0"&#xd;
                xmlns:cr="http://aac.ac.at/content_repository"&#xd;
                xmlns:tei="http://www.tei-c.org/ns/1.0"&#xd; exclude-result-prefixes="#all"&#xd;
                version="2.0"&gt;&#xd; &#xd; &lt;xsl:output method="xml" indent="yes"/&gt;&#xd;
                &#xd; &#xd; &lt;xsl:variable name="ltb" select="doc('{$ltb-path}')"/&gt;&#xd;
                &lt;xsl:variable name="project" select="doc('{$project-path}')"/&gt;&#xd;
                &lt;xsl:key name="rf" match="fcs:{$config:RESOURCE_RESOURCEFRAGMENT_ELEMENT_NAME}"
                use="cr:id"/&gt;&#xd; &lt;xsl:key name="rf-div" match="mets:div" use="@ID"/&gt;&#xd;
                &#xd; &#xd; &lt;xsl:template match="text()"/&gt;&#xd; &#xd; &lt;xsl:template
                match="*"&gt;&#xd; &lt;xsl:apply-templates/&gt;&#xd; &lt;/xsl:template&gt;&#xd;
                &#xd; &#xd; &lt;xsl:template match="/" priority="1"&gt;&#xd; &lt;mets:div
                TYPE="resource" CONTENTIDS="#{$resource-pid}" LABEL="{xs:string($resource-label)}"
                ID="{$resource-pid}_toc"&gt;&#xd; &lt;xsl:apply-templates/&gt;&#xd;
                &lt;/mets:div&gt;&#xd; &lt;/xsl:template&gt;&#xd; &#xd; {$xslTemplates}&#xd; &#xd;
                &lt;/xsl:stylesheet&gt;&#xd; &#xd; &#xd; let $resource :=
                wc:get-data($resource-pid,$project-pid),&#xd; $toc := if ($resource) then
                transform:transform($resource,$xsl,()) else ()&#xd; &#xd; let $mets:record :=
                project:get($project-pid),&#xd; $mets:structMap-exists :=
                $mets:record//mets:structMap[@TYPE=$config:PROJECT_TOC_STRUCTMAP_TYPE]&#xd; &#xd;
                return&#xd; switch (true())&#xd; case (not(exists($mets:record))) return
                util:log-app("ERROR",$config:app-name,"no METS-Record found in config for
                "||$project-pid )&#xd; case (not($resource)) return util:log-app("ERROR",
                $config:app-name,"no working copy data found for resource
                "||$resource-pid||".")&#xd; case (exists($mets:structMap-exists)) return &#xd; if
                (exists($mets:structMap-exists/mets:div/mets:div[@CONTENTIDS=$resource-ref])) then
                &#xd; (update replace
                $mets:structMap-exists/mets:div/mets:div[@CONTENTIDS=$resource-ref] with $toc,&#xd;
                util:log-app("INFO",$config:app-name,"updated ToC for "||$resource-pid||" from
                indexes "||string-join($mapping-keys,',')||" (project "||$project-pid||")")&#xd;
                )&#xd; else &#xd; (update insert $toc into $mets:structMap-exists/mets:div,&#xd;
                util:log-app("INFO",$config:app-name,"inserting ToC for "||$resource-pid||" from
                indexes "||string-join($mapping-keys,',')||" into logical structMap (project
                "||$project-pid||")")&#xd; )&#xd; default return &#xd; (update insert
                &lt;mets:structMap TYPE="{$config:PROJECT_TOC_STRUCTMAP_TYPE}" &gt;&#xd;
                &lt;mets:div&gt;{$toc}&lt;/mets:div&gt;&#xd; &lt;/mets:structMap&gt;&#xd; into
                $mets:record,&#xd; util:log-app("INFO",$config:app-name,"created logical structMap
                and inserted ToC from indexes "||string-join($mapping-keys,',')||" for resource
                "||$resource-pid||" in cr-project "||$project-pid||"." )&#xd; )&#xd; };&#xd; &#xd;
                declare %private function toc:expand-cr-ids($item as item()) as item() {&#xd;
                typeswitch($item)&#xd; case document-node() return toc:expand-cr-ids($item)&#xd;
                case element(mets:area) return &#xd; let
                $rf-pids:=ltb:lookup(xs:string(.),$resource-pid, $project-pid)&#xd; return element
                {name($item)} {&#xd; $item/@*,&#xd; attribute BEGIN {$rf-pids[1]},&#xd; attribute
                END {$rf-pids[last()]},&#xd; attribute BETYPE {"IDREF"}&#xd; }&#xd; case element()
                return &#xd; element {name($item)} {&#xd; $item/@*,&#xd; for $i in $item/node()
                return toc:expand-cr-ids($i)&#xd; }&#xd; default return $item &#xd; };&#xd; &#xd;
                (:~&#xd; : Sets the (logical) TOC of a given resource. &#xd; ~:)&#xd; declare
                function toc:set($data as element(mets:div), $resource-pid as xs:string,
                $project-pid as xs:string) {&#xd; let $toc :=
                toc:get($resource-pid,$project-pid)&#xd; return &#xd; if (exists($toc))&#xd; then
                update replace $toc with $data&#xd; else &#xd; let $tocStructMap :=
                toc:get($resource-pid,$project-pid)&#xd; return &#xd; if
                (exists($tocStructMap))&#xd; then update insert $data into $tocStructMap&#xd;
                else&#xd; let $newStructMap := &#xd; &lt;mets:structMap
                TYPE="{$config:PROJECT_TOC_STRUCTMAP_TYPE}" ID="{$project-pid}_toc"&gt;&#xd; &lt;div
                TYPE="{$config:PROJECT_TOC_STRUCTMAP_ROOT_TYPE}"&gt;{$data}&lt;/div&gt;&#xd;
                &lt;/mets:structMap&gt;&#xd; let $doc := project:get($project-pid)&#xd; return
                update insert $newStructMap into $doc &#xd; };&#xd; &#xd; (:~&#xd; : Returns the
                (logical) TOC of a given resource. &#xd; ~:)&#xd; declare function
                toc:get($resource-pid as xs:string, $project-pid as xs:string) as element(mets:div)?
                {&#xd; toc:get($project-pid)/mets:div[@CONTENTIDS='#'||$resource-pid]&#xd; };&#xd;
                &#xd; (:~&#xd; : Returns the (logical) TOC of a given project. &#xd; ~:)&#xd;
                declare function toc:get($project-pid as xs:string) as element(mets:div)? {&#xd;
                project:get($project-pid)//mets:structMap[@TYPE=$config:PROJECT_TOC_STRUCTMAP_TYPE]/mets:div&#xd;
                };&#xd; &#xd; </f>
            <f n="view.xql">(:~&#xd; : This is the main XQuery which will (by default) be called by
                controller.xql&#xd; : to process any URI ending with ".html". It receives the HTML
                from&#xd; : the controller and passes it to the templating system.&#xd; :&#xd; : It
                also passes the dynamic resolver to the templating system, &#xd; : that allows it to
                resolve the module functions&#xd; :)&#xd; xquery version "3.0";&#xd; &#xd; (:import
                module namespace resolver="http://exist-db.org/xquery/resolver" at
                "resolver.xql";:)&#xd; import module namespace
                templates="http://exist-db.org/xquery/templates" at "templates.xql";&#xd; import
                module namespace config="http://exist-db.org/xquery/apps/config" at
                "config.xqm";&#xd; import module namespace app="http://sade/app" at "app.xql"; &#xd;
                import module namespace fcs="http://sade/fcs" at "../modules/fcs/fcs-sade.xqm";&#xd;
                import module namespace
                projectAdmin="http://aac.ac.at/content_repository/projectAdmin" at
                "../modules/projectAdmin/projectAdmin.xqm";&#xd; &#xd; declare option
                exist:serialize "method=html5 media-type=text/html";&#xd; &#xd; let $lookup
                :=function($functionName as xs:string, $arity as xs:int) {&#xd; try {&#xd;
                function-lookup(xs:QName($functionName), $arity)&#xd; } catch * {&#xd; () &#xd;
                }&#xd; } &#xd; (: &#xd; : The HTML is passed in the request from the controller.
                &#xd; : (the controller cares for fetching the correct template-file based on
                project context)&#xd; : Run it through the templating system and return the
                result.&#xd; :)&#xd; &#xd; let $template := request:get-data(),&#xd; $project :=
                session:set-attribute("project-pid", request:get-parameter("project", ""))&#xd;
                &#xd; return templates:apply($template, $lookup, ())</f>
            <f n="wc.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                wc="http://aac.ac.at/content_repository/workingcopy";&#xd; import module namespace
                config="http://exist-db.org/xquery/apps/config" at "config.xqm"; &#xd; import module
                namespace resource="http://aac.ac.at/content_repository/resource" at
                "resource.xqm";&#xd; import module namespace
                project="http://aac.ac.at/content_repository/project" at "project.xqm";&#xd; import
                module namespace repo-utils="http://aac.ac.at/content_repository/utils" at
                "repo-utils.xqm";&#xd; &#xd; (:~&#xd; : Getter / setter / storage functions for the
                entity "working copy".&#xd; :&#xd; : Creating a working copy is the first step of
                ingesting data into the content repository.&#xd; : Essentially it is an identity
                transformation of the data with the following information bits&#xd; : added to each
                element():&#xd; : &#xd; : - a locally unique xml:id (@cr:id)&#xd; : - the project
                wide unique pid of the cr resource which it represents (@cr:resource-pid)&#xd; : -
                the content repository wide unique id of the project the resource is part of
                (@cr:project-id)&#xd; :&#xd; : All queries which are performed on a project's
                dataset, are performed on working copies, while &#xd; : the master of the data is
                just kept as reference. This is crucial as it facilitates &#xd; : mapping the
                arbitrary search result on the FCS data structure (i.e. 'resources' and &#xd; :
                'resource fragments'), as well as consistent match higlighting between structural
                searches (i.e. &#xd; : standard xpath) and fulltext or ngram searches which do not
                offer match highlighting for attribute &#xd; : values.&#xd; :&#xd; : Stored working
                copies have to be registered with a resource in the project's mets:record by adding
                a&#xd; : mets:file element to the resource's mets:fileGrp with an appropriate value
                in its @USE attribute. &#xd; : This value is globally set in the variable
                $config:RESOURCE_WORKINGCOPY_FILE_USE, by default it is 'WORKING COPY'.&#xd; :&#xd;
                : The storage path of a working copy may be defined in the project's config, in a
                parameter &#xd; : with the key 'working-copies.path'. The default path is set
                globally in the &#xd; : variable $config:default-working-copy-path.&#xd; :&#xd; :
                @author daniel.schopper@oeaw.ac.at&#xd; : @since 2013-11-08&#xd; ~:)&#xd; &#xd;
                &#xd; &#xd; (: declaration of helper namespaces for better code structuring :)&#xd;
                declare namespace param="userinput.parameters";&#xd; declare namespace
                this="current.object";&#xd; &#xd; declare namespace
                mets="http://www.loc.gov/METS/";&#xd; declare namespace
                xlink="http://www.w3.org/1999/xlink";&#xd; declare namespace fcs =
                "http://clarin.eu/fcs/1.0";&#xd; declare namespace
                cr="http://aac.ac.at/content_repository";&#xd; &#xd; &#xd; (:~&#xd; : Path to the
                stylesheet which creates the working copy.&#xd; ~:)&#xd; declare variable
                $wc:path-to-xsl:= $config:app-root||"/core/wc.xsl";&#xd; declare variable
                $wc:default-path:= $config:default-workingcopy-path;&#xd; declare variable
                $wc:filename-prefix:= $config:RESOURCE_WORKINGCOPY_FILENAME_PREFIX;&#xd; &#xd;
                declare variable $wc:behavior-btype := "wc_generation";&#xd; &#xd; (:~&#xd; :
                Generates a working copy from the $resource-pid, stores it in the database and &#xd;
                : registers it with the resources entry.&#xd; : &#xd; : @param $resource-pid the pid
                of the resource &#xd; : @param $project-id the id of the project to work in&#xd; :
                @return the path to the working copy&#xd; ~:)&#xd; declare function
                wc:generate($resource-pid as xs:string, $project-pid as xs:string) as xs:string?
                {&#xd; let $config:= config:config($project-pid),&#xd; (: look for the wc:path:
                either it is already registered and can be retrieved with resource:path() &#xd; or
                we have to construct it anew with project:path() :)&#xd; $wc:path:=
                (util:collection-name(resource:path($resource-pid,$project-pid,'workingcopy')),&#xd;
                project:path($project-pid,'workingcopies'))[1],&#xd; $wc:path-create := if
                (doc-available(resource:path($resource-pid,$project-pid,'workingcopy')) or
                xmldb:collection-available($wc:path))&#xd; then ()&#xd; else &#xd; let
                $fstStep:=tokenize($wc:path,'/')[1],&#xd; $rest :=
                substring-after($wc:path,$fstStep)&#xd; return (&#xd;
                repo-utils:mkcol($fstStep,$rest),&#xd;
                sm:chown($wc:path,project:adminsaccountname($project-pid)),&#xd;
                sm:chgrp($wc:path,project:adminsaccountname($project-pid)),&#xd;
                sm:add-user-ace($wc:path,$config:cr-writer-accountname,true(),'rwx'),&#xd;
                sm:add-group-ace($wc:path,$config:cr-writer-accountname,true(),'rwx')&#xd; ),&#xd;
                $master:= resource:master($resource-pid,$project-pid),&#xd; $master_filename:=
                util:document-name($master),&#xd; $wc:filename :=
                $wc:filename-prefix||$master_filename&#xd; let $preprocess-xsl :=
                resource:get-preprocess-xsl-path($resource-pid,$project-pid)&#xd; return &#xd;
                switch(true())&#xd; case $wc:path eq '' &#xd; return util:log("INFO","$wc-path
                empty!")&#xd; default &#xd; return &#xd; let $xsl-params:=&#xd;
                &lt;parameters&gt;&#xd; &lt;param name="resource-pid"
                value="{$resource-pid}"/&gt;&#xd; &lt;param name="project-id"
                value="{$project-pid}"/&gt;&#xd; &lt;/parameters&gt;&#xd; let $preprocess := &#xd;
                if ($preprocess-xsl = '' or not(doc-available($preprocess-xsl))) &#xd; then $master
                &#xd; else (transform:transform($master,doc($preprocess-xsl),()),&#xd;
                util:log-app("INFO",$config:app-name,"resource "||$resource-pid||"(project
                "||$project-pid||") has been preprocessed by "||$preprocess-xsl))&#xd; let
                $wc:generated :=
                transform:transform($preprocess,doc($wc:path-to-xsl),$xsl-params),&#xd; $store-wc :=
                repo-utils:store($wc:path,$wc:filename,$wc:generated,true(),$config),&#xd;
                $wc:filepath := base-uri($store-wc),&#xd; $log :=
                util:log-app("INFO",$config:app-name,"working copy for "||$resource-pid||" has been
                stored to "||$wc:filepath),&#xd; $wc:chown :=
                (sm:chown($wc:filepath,project:adminsaccountname($project-pid)),&#xd;
                sm:chgrp($wc:filepath,project:adminsaccountname($project-pid)),&#xd;
                sm:add-user-ace($wc:filepath,$config:cr-writer-accountname,true(),'rwx'),&#xd;
                sm:add-group-ace($wc:filepath,$config:cr-writer-accountname,true(),'rwx')) &#xd; (:
                register working copy with :)&#xd; let $update-mets:= &#xd; if ($wc:filepath!='')
                &#xd; then wc:add($wc:filepath,$resource-pid,$project-pid) &#xd; else
                util:log-app("ERROR",$config:app-name,"$wc:filepath is empty")&#xd; return
                $wc:filepath &#xd; };&#xd; &#xd; (:~&#xd; : Removes the data of a working copy from
                the database.&#xd; : &#xd; : @param $resource-pid pid of the resource &#xd; : @param
                $project-pid id of the project&#xd; : @return empty()&#xd; ~:)&#xd; declare function
                wc:remove-data($resource-pid as xs:string,$project-pid as xs:string) as empty()
                {&#xd; let $wc:path:= wc:get-path($resource-pid, $project-pid),&#xd; $wc:filename:=
                tokenize($wc:path,'/')[last()],&#xd; $wc:collection:=
                substring-before($wc:path,$wc:filename)&#xd; return
                xmldb:remove($wc:collection,$wc:filename)&#xd; };&#xd; &#xd; (:~&#xd; : Gets the
                registered working copy as its mets:file.&#xd; : &#xd; : @param $resource-pid pid of
                the resource &#xd; : @param $project-pid id of the project&#xd; : @return the
                mets:file entry of the working copy.&#xd; ~:)&#xd; declare function
                wc:get($resource-pid as xs:string,$project-pid as xs:string) as element(mets:file)?
                {&#xd; let $mets:resource:=resource:get($resource-pid,$project-pid),&#xd;
                $mets:resource-files:=resource:files($resource-pid,$project-pid)&#xd; (: the working
                copy is one of several &lt;fptr&gt; elements directly under the resource's mets:div,
                e.g. :)&#xd; (: &lt;div TYPE='resource'&gt;&#xd; &lt;fptr
                FILEID="id-of-masterfile"/&gt;&#xd; &lt;fptr FILEID="id-of-workingcopy"/&gt;&#xd;
                &lt;fptr FILEID="id-of-resourcefragments-file"/&gt;&#xd; ....&#xd; &lt;/div&gt;&#xd;
                :)&#xd; (: we have to find the right &lt;file&gt; element by looking at all of them
                and determining each one's @USE attribute :)&#xd; let
                $mets:workingcopy:=$mets:resource-files/mets:file[@USE eq
                $config:RESOURCE_WORKINGCOPY_FILE_USE]&#xd; return switch (true())&#xd; case
                not($mets:resource) return util:log-app("ERROR", $config:app-name,'Unknown resource
                with PID '||$resource-pid)&#xd; case not($mets:resource-files) return
                util:log-app("ERROR", $config:app-name,'Resource files mets entries not found for
                '||$resource-pid)&#xd; case not($mets:workingcopy) return util:log-app("ERROR",
                $config:app-name,'Working copy mets file entry not found for '||$resource-pid)&#xd;
                default return $mets:workingcopy&#xd; };&#xd; &#xd; (:~&#xd; : Returns the database
                path to the content of the resource's working copy.&#xd; : &#xd; : @param
                $resource-pid the pid of the resource&#xd; : @param $project-pid: the id of the
                current project&#xd; : @return the path the workingcopy of the resource as xs:anyURI
                &#xd; ~:)&#xd; declare function wc:get-path($resource-pid,$project-pid) as
                xs:anyURI? {&#xd; let $wc:=wc:get($resource-pid,$project-pid)&#xd; return
                xs:anyURI($wc/mets:FLocat/@xlink:href)&#xd; };&#xd; &#xd; (:~&#xd; : Returns the
                content of a working copy as a document-node().&#xd; : &#xd; : @param $resource-pid
                the pid of the resource&#xd; : @param $project-pid: the id of the current
                project&#xd; : @return if available, the document node of the working copy,
                otherwise an empty sequence. &#xd; ~:)&#xd; declare function
                wc:get-data($resource-pid,$project-pid) as document-node()? {&#xd; let
                $wc-path:=wc:get-path($resource-pid,$project-pid)&#xd; return &#xd; if
                (doc-available($wc-path))&#xd; then doc($wc-path)&#xd; else
                util:log-app("INFO",$config:app-name,"requested working copy at "||$wc-path||" is
                not available.")&#xd; };&#xd; &#xd; &#xd; (:~&#xd; : Registers the data of a working
                copy with the resource by appending a mets:file element to&#xd; : the resources
                mets:fileGrp.&#xd; : If there is already a working copy registered with this
                resource, it will be replaced.&#xd; : Note that this function does not actually
                create and store the working copy. This is done by &#xd; : wc:generate() which calls
                this function.&#xd; : &#xd; : @param $path the path to the stored working copy&#xd;
                : @param $resource-pid the pid of the resource&#xd; : @param $project-pid: the id of
                the current project&#xd; : @return the added mets:file element &#xd; ~:)&#xd;
                declare function wc:add($path as xs:string, $resource-pid as xs:string, $project-pid
                as xs:string) as element(mets:file)? {&#xd; let
                $mets:resource:=resource:get($resource-pid,$project-pid)&#xd; let
                $mets:wc-file:=wc:get($resource-pid,$project-pid),&#xd; (: get the fileptr to an
                existing wc :)&#xd; $mets:wc-fptr:=$mets:resource//mets:fptr[@FILEID eq
                $mets:wc-file/@ID]&#xd; (: construct new wc node :)&#xd; let
                $this:wc-fileid:=$resource-pid||$config:RESOURCE_WORKINGCOPY_FILEID_SUFFIX,&#xd;
                $this:wc-file:=resource:make-file($this:wc-fileid,$path,"wc"), &#xd;
                $this:wc-fptr:=&lt;mets:fptr FILEID="{$this:wc-fileid}"/&gt;&#xd; return&#xd; if
                (exists($mets:wc-file))&#xd; then &#xd; let $replace-file:=update replace
                $mets:wc-file with $this:wc-file&#xd; let $replace-fileptr:=update replace
                $mets:wc-fptr with $this:wc-fptr&#xd; let $log := util:log-app("DEBUG",
                $config:app-name, "mets:wc-file exists")&#xd; return $this:wc-file&#xd; else &#xd;
                let $log := util:log-app("DEBUG", $config:app-name,
                exists(resource:files($resource-pid,$project-pid)))&#xd; let $log :=
                util:log-app("DEBUG", $config:app-name, "resource-pid:" ||$resource-pid||"
                project-pid: "||$project-pid)&#xd; let $master :=
                resource:get-master($resource-pid,$project-pid)&#xd; (: we insert the wc
                &lt;file&gt; right after the resource's master &lt;file&gt; :)&#xd; let
                $insert-file:= update insert $this:wc-file following $master&#xd; (: we insert the
                wc &lt;fptr&gt; right after the &lt;fptr&gt; to the resource's master file :)&#xd;
                let $insert-fileptr:=update insert $this:wc-fptr following
                $mets:resource/mets:fptr[1]&#xd; return $this:wc-file &#xd; };&#xd; &#xd; (:~&#xd; :
                looks up a specific element in the working copy via it's document-wide unique @cr:id
                attribute.&#xd; : @param $cr:id the cr:id of the elment to find&#xd; : @param
                $resource-pid the pid of the resource&#xd; : @param $project-pid: the id of the
                current project&#xd; : @return zero or one element in the working copy &#xd;
                ~:)&#xd; declare function wc:lookup($cr:id as xs:string, $resource-pid as xs:string,
                $project-pid as xs:string) as element()? {&#xd; let
                $wc:=wc:get-data($resource-pid,$project-pid)&#xd; return $wc//*[@cr:id eq
                $cr:id]&#xd; };</f>
        </d>
        <d n="modules">
            <d n="access-control">
                <f n="login.xql">xquery version "1.0";&#xd; (: $Id: login.xql 13358 2010-12-07
                    03:45:03Z shabanovd $ :)&#xd; (:&#xd; eXist &amp; OpenId login forms.&#xd;
                    :)&#xd; &#xd; declare option exist:serialize "method=xhtml media-type=text/html
                    indent=yes omit-xml-declaration=no";&#xd; &#xd; let $tmp :=
                    util:log-system-out("login")&#xd; return&#xd; &lt;html&gt;&#xd;
                    &lt;head&gt;&#xd; &lt;/head&gt;&#xd; &lt;body&gt;&#xd; &lt;div class="yui-g"
                    style="margin: 1em auto 2em; width: 60em"&gt;&#xd; &lt;!-- native login form
                    --&gt;&#xd; &lt;div class="yui-u first"&gt;&#xd; &lt;h3 class="titlebar"&gt;Log
                    in with a eXist-db account&lt;/h3&gt;&#xd; &lt;form action="j_security_check"
                    method="post" id="login_native"&gt;&#xd; &#xd; &lt;!-- return url --&gt;&#xd;
                    &lt;input type="hidden" name="eXist_return_to"
                    value="{session:encode-url(request:get-uri())}" /&gt;&#xd; &#xd; &lt;p&gt;Enter
                    your account info:&lt;/p&gt;&#xd; &#xd; &lt;fieldset style="padding: 0"&gt;&#xd;
                    &lt;legend&gt;&lt;/legend&gt;&#xd; &lt;!-- user name block --&gt;&#xd; &lt;div
                    style="padding: 0.2em 0pt 0.2em 4em; margin-top: 0.5em;"&gt;&#xd; &lt;div
                    class="login_left"&gt;Username:&lt;/div&gt;&#xd; &lt;div&gt;&#xd; &lt;input
                    type="text" name="j_username" maxlength="15" value="" style="padding: .2em;
                    border: 1px solid #789"/&gt;&#xd; &lt;/div&gt;&#xd; &lt;/div&gt;&#xd; &lt;!--
                    password block --&gt;&#xd; &lt;div style="padding: 0.2em 0pt 0.2em 4em;
                    margin-top: 0.5em;"&gt;&#xd; &lt;div
                    class="login_left"&gt;Password:&lt;/div&gt;&#xd; &lt;div&gt;&#xd; &lt;input
                    type="password" name="j_password" maxlength="32" style="padding: .2em; border:
                    1px solid #789"/&gt;&#xd; &lt;/div&gt;&#xd; &lt;/div&gt;&#xd; &lt;!-- login
                    button block --&gt;&#xd; &lt;div style="padding: 15px 0.5em 0.5em 5em;"&gt;&#xd;
                    &lt;div class="login_left"&gt;&#xd; &lt;input type="submit" name="login"
                    value="Sign-In"/&gt;&#xd; &lt;/div&gt;&#xd; &lt;/div&gt;&#xd;
                    &lt;/fieldset&gt;&#xd; &lt;/form&gt;&#xd; &lt;/div&gt;&#xd; &#xd; &lt;!-- OpenID
                    login form --&gt;&#xd; &lt;div class="yui-u"&gt;&#xd; &#xd; &lt;h3
                    class="titlebar"&gt;Log in with a OpenID account&lt;/h3&gt;&#xd; &lt;!-- Simple
                    OpenID Selector --&gt;&#xd; &lt;form
                    action="{request:get-context-path()}/openid" method="get"
                    id="openid_form"&gt;&#xd; &lt;input type="hidden" name="action" value="verify"
                    /&gt;&#xd; &#xd; &lt;!-- return url --&gt;&#xd; &lt;input type="hidden"
                    name="return_to" value="{session:encode-url(request:get-uri())}" /&gt;&#xd;
                    &#xd; &lt;fieldset&gt;&#xd; &lt;legend&gt;&lt;/legend&gt;&#xd; &#xd; &lt;div
                    id="openid_choice"&gt;&#xd; &lt;p&gt;Please click your account
                    provider:&lt;/p&gt;&#xd; &lt;div id="openid_btns"&gt;&lt;/div&gt;&#xd;
                    &lt;/div&gt;&#xd; &#xd; &lt;div id="openid_input_area"&gt;&#xd; &lt;input
                    id="openid_identifier" name="openid_identifier" type="text" value="http://"
                    /&gt;&#xd; &lt;input id="openid_submit" type="submit" value="Sign-In"/&gt;&#xd;
                    &lt;/div&gt;&#xd; &lt;noscript&gt;&#xd; &lt;p&gt;OpenID is service that allows
                    you to log-on to many different websites using a single indentity.&#xd; Find out
                    &lt;a href="http://openid.net/what/"&gt;more about OpenID&lt;/a&gt; and &lt;a
                    href="http://openid.net/get/"&gt;how to get an OpenID enabled
                    account&lt;/a&gt;.&lt;/p&gt;&#xd; &lt;/noscript&gt;&#xd; &lt;/fieldset&gt;&#xd;
                    &lt;/form&gt;&#xd; &lt;!-- /Simple OpenID Selector --&gt;&#xd; &lt;/div&gt;&#xd;
                    &#xd; &lt;!-- OAuth login form --&gt;&#xd; &lt;div class="yui-u first"&gt;&#xd;
                    &#xd; &lt;h3 class="titlebar"&gt;Log in with a OAuth account&lt;/h3&gt;&#xd;
                    &#xd; &lt;fieldset&gt;&#xd; &lt;legend&gt;&lt;/legend&gt;&#xd; &#xd; &lt;a
                    href="/exist/oauth/cook?auth={session:encode-url(request:get-uri())}"&gt;facebook&lt;/a&gt;&#xd;
                    &lt;/fieldset&gt;&#xd; &lt;/div&gt;&#xd; &lt;/div&gt;&#xd; &lt;p
                    class="copyright"&gt;Copyright &amp;#169; 2012 &lt;a title="eXist-db Open Source
                    Native XML Database." href="http://exist-db.org"&gt;eXist-DB&lt;/a&gt; All
                    rights reserved.&lt;/p&gt;&#xd; &lt;/body&gt;&#xd; &lt;/html&gt;&#xd; </f>
            </d>
            <d n="admin">
                <d n="kickstrap">
                    <d n="Kickstrap">
                        <d n="apps">
                            <d n="animatecss"/>
                            <d n="bootstrap">
                                <d n="affix"/>
                                <d n="alert"/>
                                <d n="button"/>
                                <d n="carousel"/>
                                <d n="collapse"/>
                                <d n="dropdown"/>
                                <d n="modal"/>
                                <d n="popover"/>
                                <d n="scrollspy"/>
                                <d n="tab"/>
                                <d n="tooltip"/>
                                <d n="transition"/>
                                <d n="typeahead"/>
                            </d>
                            <d n="chosen"/>
                            <d n="colorschemer"/>
                            <d n="firebuglite"/>
                            <d n="jQueryLint"/>
                            <d n="knockout"/>
                            <d n="pinesnotify">
                                <d n="use for pines style icons"/>
                            </d>
                            <d n="universal">
                                <d n="jQueryUI"/>
                            </d>
                            <d n="updater"/>
                        </d>
                        <d n="bootstrap">
                            <d n="img"/>
                            <d n="js"/>
                            <d n="less"/>
                        </d>
                        <d n="css"/>
                        <d n="js"/>
                        <d n="themes">
                            <d n="amelia"/>
                            <d n="cerulean"/>
                            <d n="cyborg"/>
                            <d n="journal"/>
                            <d n="readable"/>
                            <d n="simplex"/>
                            <d n="slate"/>
                            <d n="spacelab"/>
                            <d n="spruce"/>
                            <d n="superhero"/>
                            <d n="united"/>
                        </d>
                    </d>
                    <f n="kickstrap.xql">xquery version "1.0"; module namespace
                        trigger="http://exist-db.org/xquery/trigger"; declare namespace sade =
                        "http://bbaw.de/sade"; declare option exist:serialize "method=text
                        media-type=text/plain omit-xml-declaration=yes"; declare function
                        trigger:after-update-document($uri as xs:anyURI) { let $theme :=
                        doc('/db/projects/ai-test/static/config.xml')/sade:SADE_project/sade:design/sade:theme/text()
                        let $theme.less := if (string-length($theme) &lt; 1) then (&lt;theme&gt; //
                        load default bootstrap theme // @import
                        "Kickstrap/themes/amelia/variables.less"; // @import
                        "Kickstrap/themes/amelia/bootswatch.less"; &lt;/theme&gt;) else (
                        &lt;theme&gt; @import "Kickstrap/themes/{$theme}/variables.less"; @import
                        "Kickstrap/themes/{$theme}/bootswatch.less"; &lt;/theme&gt;) let $isLoggedIn
                        := xmldb:login("/db/sade/modules/admin/kickstrap", "admin", "") let $ausgabe
                        := xmldb:store("/db/sade/modules/admin/kickstrap", "theme.less",
                        $theme.less/text()) return () }; </f>
                </d>
                <d n="resources">
                    <d n="css"/>
                    <d n="font"/>
                    <d n="images"/>
                    <d n="lang"/>
                </d>
                <d n="template"/>
                <f n="admin.xql">xquery version "1.0"; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0"; declare namespace
                    xmldb="http://exist-db.org/xquery/xmldb"; declare namespace
                    request="http://exist-db.org/xquery/request"; declare namespace exist =
                    "http://exist.sourceforge.net/NS/exist"; declare namespace transform =
                    "http://exist-db.org/xquery/transform"; declare namespace xf =
                    "http://www.w3.org/2002/xforms"; declare namespace sade = "http://bbaw.de/sade";
                    declare option exist:serialize "method=xhtml media-type=text/xml"; let $id :=
                    request:get-parameter("id", "general") let $lang :=
                    request:get-parameter("lang", "en") let $project :=
                    request:get-parameter("project", "") let $language :=
                    doc(concat('resources/lang/', $lang, '.xml'))//sade:lang let $configfile:=
                    concat('/db/projects/', $project, '/static/config.xml') let $formular :=
                    transform:transform(&lt;nocontent&gt;&lt;/nocontent&gt;, doc('formular.xsl'),
                    &lt;parameters&gt;&lt;param name="lang" value="{$lang}" /&gt;&lt;param name="id"
                    value="{$id}" /&gt;&lt;/parameters&gt;) let $nav := &lt;div id="nav"&gt;
                    &lt;ul&gt; { (if ($id='general') then (&lt;li class="active"&gt;&lt;a
                    href="?id=general&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:general/text()}&lt;/a&gt;&lt;/li&gt;)
                    else (&lt;li&gt;&lt;a
                    href="?id=general&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:general/text()}&lt;/a&gt;&lt;/li&gt;),
                    if ($id='design') then (&lt;li class="active"&gt;&lt;a
                    href="?id=design&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:design/text()}&lt;/a&gt;&lt;/li&gt;)
                    else (&lt;li&gt;&lt;a
                    href="?id=design&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:design/text()}&lt;/a&gt;&lt;/li&gt;),
                    if ($id='pages' or $id='edition' or $id='description'or $id='imprint') then
                    (&lt;li&gt;&lt;a
                    href="?id=pages&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:pages/text()}&lt;/a&gt;
                    &lt;ul&gt; {( if ($id='edition') then (&lt;li class="active"&gt;&lt;a
                    href="?id=edition&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:edition/text()}&lt;/a&gt;&lt;/li&gt;)
                    else (&lt;li&gt;&lt;a
                    href="?id=edition&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:edition/text()}&lt;/a&gt;&lt;/li&gt;),
                    if ($id='description') then (&lt;li class="active"&gt;&lt;a
                    href="?id=description&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:description/text()}&lt;/a&gt;&lt;/li&gt;)
                    else (&lt;li&gt;&lt;a
                    href="?id=description&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:description/text()}&lt;/a&gt;&lt;/li&gt;),
                    if ($id='imprint') then (&lt;li class="active"&gt;&lt;a
                    href="?id=imprint&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:imprint/text()}&lt;/a&gt;&lt;/li&gt;)
                    else (&lt;li&gt;&lt;a
                    href="?id=imprint&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:imprint/text()}&lt;/a&gt;&lt;/li&gt;)
                    )} &lt;/ul&gt; &lt;/li&gt;) else (&lt;li&gt;&lt;a
                    href="?id=pages&amp;amp;project={$project}&amp;amp;lang={$lang}"&gt;{$language//sade:general/sade:nav/sade:pages/text()}&lt;/a&gt;&lt;/li&gt;))
                    } &lt;/ul&gt; &lt;/div&gt; let $instances := if (contains($id, 'design')) then
                    (&lt;xf:instance xmlns=""
                    src="/exist/rest/db/sade/modules/admin/kickstrap/Kickstrap/themes" id="themes"
                    /&gt;) else () let $bind := ( if (contains($id, 'general')) then ( &lt;xf:bind
                    id="name" nodeset="/sade:SADE_project/sade:meta/sade:project_name"
                    required="true()" constraint="string-length(.) &gt; 0" /&gt; ) else (), if
                    (contains($id, 'design')) then ( (: Datentyp muss definiert werden, sonst
                    funktioniert Uploadfeld nicht :) &lt;xf:bind
                    nodeset="/sade:SADE_project/sade:design/sade:footer/sade:img" type="xs:anyURI"
                    /&gt; ) else () ) return &lt;html xmlns="http://www.w3.org/1999/xhtml"
                    xmlns:xf="http://www.w3.org/2002/xforms"
                    xmlns:ev="http://www.w3.org/2001/xml-events"
                    xmlns:sade="http://bbaw.de/sade"&gt; &lt;head&gt;
                    &lt;title&gt;{$language/sade:dashboard/sade:sade/text()}:
                    {doc($configfile)/sade:SADE_project/sade:meta/sade:project_name}&lt;/title&gt;
                    &lt;link rel="stylesheet" type="text/css" href="resources/css/font-awesome.css"
                    /&gt; &lt;link rel="stylesheet" type="text/css"
                    href="resources/css/adminpanel.css" /&gt; &lt;xf:model id="data"&gt; &lt;!--
                    Daten der config.xml laden --&gt; &lt;xf:action ev:event="xforms-ready"&gt;
                    &lt;xf:send submission="read"/&gt; &lt;/xf:action&gt; &lt;xf:instance
                    id="sade_config" src="/exist/rest{$configfile}" /&gt; &lt;xf:submission
                    id="read" method="get" replace="instance" instance="sade_config"
                    action="/exist/rest{$configfile}"&gt; &lt;xf:toggle case="none"
                    ev:event="xforms-submit-done" /&gt; &lt;/xf:submission&gt; &lt;!-- Geänderte
                    Daten in config.xml schreiben --&gt; &lt;xf:submission id="save" method="put"
                    replace="none" action="/exist/webdav{$configfile}"&gt; &lt;!-- Fälle für
                    Erfolg/Fehler beim Übermitteln --&gt; &lt;xf:toggle case="notsaved"
                    ev:event="xforms-submit-error" /&gt; &lt;xf:toggle case="saved"
                    ev:event="xforms-submit-done" /&gt; &lt;/xf:submission&gt; &lt;!--
                    Beschriftungen laden --&gt; &lt;xf:instance
                    src="/exist/rest/db/sade/modules/admin/resources/lang/{$lang}.xml" id="lang"
                    /&gt; &lt;!-- Weitere Instanzen --&gt; {$instances} {$bind} &lt;/xf:model&gt;
                    &lt;!-- Warnung beim Verlassen der Seite deaktivieren --&gt; &lt;script
                    type="text/javascript" src="resources/betterform_ext.js"
                    defer="defer"&gt;&amp;#160;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div
                    id="container"&gt; &lt;div id="head"&gt; &lt;h1&gt;&lt;a
                    href="/exist/rest/db/projects/{$project}/index.xql" target="_blank"
                    title="{$language/sade:general/sade:showWebsite}"&gt;{doc($configfile)/sade:SADE_project/sade:meta/sade:project_name}&lt;/a&gt;&lt;/h1&gt;
                    &lt;h2&gt;&lt;a
                    href="dashboard.xql?lang={$lang}"&gt;{$language/sade:dashboard/sade:sade/text()}
                    - {$language/sade:dashboard/sade:title/text()}&lt;/a&gt;&lt;/h2&gt; &lt;div
                    id="langmenu"&gt; &lt;a
                    href="?id={$id}&amp;amp;project={$project}&amp;amp;lang=en"
                    title="English"&gt;EN&lt;/a&gt; | &lt;a
                    href="?id={$id}&amp;amp;project={$project}&amp;amp;lang=de"
                    title="Deutsch"&gt;DE&lt;/a&gt; | &lt;a
                    href="?id={$id}&amp;amp;project={$project}&amp;amp;lang=fr"
                    title="Français"&gt;FR&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; {$nav} &lt;div
                    id="content"&gt; &lt;!-- Erfolgs- oder Fehlermeldung nach dem Speichern --&gt;
                    &lt;xf:switch&gt; &lt;xf:case id="saved"&gt; &lt;p
                    class="saved"&gt;{$language/sade:general/sade:submit_success/text()}&lt;/p&gt;
                    &lt;/xf:case&gt; &lt;xf:case id="notsaved"&gt; &lt;p
                    class="savefailed"&gt;{$language/sade:general/sade:submit_error/text()}&lt;/p&gt;
                    &lt;/xf:case&gt; &lt;xf:case id="none"&gt; &lt;/xf:case&gt; &lt;/xf:switch&gt;
                    &lt;!-- Formular aus formular.xsl --&gt; {$formular} &lt;!--
                    Speicherschaltfläche --&gt; &lt;xf:submit submission="save"&gt; &lt;xf:label
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:general/sade:submit"/&gt;
                    &lt;/xf:submit&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; </f>
                <f n="dashboard.xql">xquery version "1.0"; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0"; declare namespace
                    xmldb="http://exist-db.org/xquery/xmldb"; declare namespace
                    request="http://exist-db.org/xquery/request"; declare namespace exist =
                    "http://exist.sourceforge.net/NS/exist"; declare namespace transform =
                    "http://exist-db.org/xquery/transform"; declare namespace sade =
                    "http://bbaw.de/sade"; declare option exist:serialize "method=xhtml
                    media-type=text/xml"; let $id := request:get-parameter("id", "general") let
                    $lang := request:get-parameter("lang", "en") let $language :=
                    doc(concat('resources/lang/', $lang, '.xml'))//sade:lang let $projects := for $x
                    in collection('/db/projects/')//sade:SADE_project return &lt;div
                    xmlns="http://www.w3.org/1999/xhtml" class="kachel project"&gt; &lt;a
                    class="imga"
                    href="admin.xql?id=general&amp;amp;project={$x//sade:pid}&amp;amp;lang={$lang}"&gt;
                    &lt;i class="icon-folder-close"&gt;{$x/sade:meta/sade:project_name}&lt;/i&gt;
                    &lt;/a&gt; &lt;/div&gt; return &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
                    &lt;head&gt; &lt;title&gt;SADE - Scalable Architecture for Digital
                    Editions&lt;/title&gt; &lt;link rel="stylesheet" type="text/css"
                    href="resources/css/dashboard.css" /&gt; &lt;link rel="stylesheet"
                    type="text/css" href="resources/css/font-awesome.css" /&gt; &lt;/head&gt;
                    &lt;body&gt; &lt;div id="container"&gt; &lt;div id="head"&gt;
                    &lt;h1&gt;{$language/sade:dashboard/sade:sade}&lt;br
                    /&gt;{$language//sade:dashboard/sade:title}&lt;/h1&gt; &lt;div id="langmenu"&gt;
                    &lt;a href="?lang=en" title="English"&gt;EN&lt;/a&gt; | &lt;a href="?lang=de"
                    title="Deutsch"&gt;DE&lt;/a&gt; | &lt;a href="?lang=fr"
                    title="Français"&gt;FR&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div
                    id="content"&gt; {$projects} &lt;div class="kachel newproject"&gt; &lt;a
                    class="imga" href="new.xql?lang={$lang}"&gt; &lt;i
                    class="icon-plus-sign"&gt;&lt;br
                    /&gt;{$language/sade:dashboard/sade:newproject}&lt;/i&gt; &lt;/a&gt;
                    &lt;/div&gt; &lt;div class="kachel doc"&gt; &lt;a class="imga" href=""&gt; &lt;i
                    class="icon-file"&gt;&lt;br /&gt;{$language/sade:dashboard/sade:doc}&lt;/i&gt;
                    &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt; &lt;p&gt;SADE -
                    Scalable Architecture for Digital Editions is a project of TELOTA,
                    Berlin-Brandenburg Academy of Sciences and Humanities. SADE uses various open
                    source software: e.g. eXistdb, digilib and betterForm. Go to
                    http://sade.bbaw.de/ for details. SADE comes with ABSOLUTELY NO WARRANTY; click
                    for details. This is free software, and you are welcome to redistribute it under
                    certain conditions; click for details. Obstructing the appearance of this notice
                    is prohibited by law.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;
                    &lt;/html&gt;</f>
                <f n="generateproject.xql">xquery version "1.0"; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0"; declare namespace
                    xmldb="http://exist-db.org/xquery/xmldb"; declare namespace
                    request="http://exist-db.org/xquery/request"; declare namespace exist =
                    "http://exist.sourceforge.net/NS/exist"; declare namespace transform =
                    "http://exist-db.org/xquery/transform"; declare namespace sade =
                    "http://bbaw.de/sade"; declare option exist:serialize "method=xhtml
                    media-type=text/xml"; let $projectid := request:get-parameter("projectid", "")
                    let $existingProjects := &lt;ul&gt; { for $x in
                    xmldb:get-child-collections('/db/projects/') return &lt;li&gt;{$x}&lt;/li&gt; }
                    &lt;/ul&gt; let $isLoggedIn := xmldb:login("/db/sade/modules/admin/kickstrap",
                    "admin", "") let $createCollection := (xmldb:create-collection('/db/projects/',
                    $projectid), xmldb:copy('/db/projects/ai-test/static', concat('/db/projects/',
                    $projectid)), xmldb:copy('/db/projects/ai-test/index.xql',
                    concat('/db/projects/', $projectid))) return if
                    ($existingProjects//li/contains(./data(.), $projectid) and $projectid) then
                    ($createCollection) else (&lt;html&gt;FEHLER!!!&lt;/html&gt;) </f>
                <f n="login.xql">xquery version "1.0"; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0"; declare option exist:serialize "method=html5
                    media-type=text/html"; (: Für das Login und Logout :) let $_user :=
                    request:get-parameter("user",()) let $_pass := request:get-parameter("pass",())
                    let $loggedIn := if (session:exists()) then (true()) else ( if ($_user and
                    $_pass) then ( session:set-max-inactive-interval(28800),
                    xmldb:login('/db/admin', $_user, $_pass, true()) ) else (false()) ) let $url :=
                    if ($loggedIn) then concat('/exist/rest/db/sade/modules/admin/dashboard.xql',
                    '?=', session:get-id()) else () return if ($loggedIn) then
                    (response:redirect-to($url)) else ( &lt;html&gt; &lt;head&gt;
                    &lt;title&gt;Login: SADE-Administration&lt;/title&gt; &lt;/head&gt; &lt;body&gt;
                    &lt;h1&gt;Login: SADE-Administration&lt;/h1&gt; &lt;form action="login.xql"&gt;
                    &lt;label for="user"&gt;Benutzername&lt;/label&gt; &lt;input name="user" /&gt;
                    &lt;label for="pass"&gt;Passwort&lt;/label&gt; &lt;input name="pass" /&gt;
                    &lt;input type="submit" value="Login"/&gt; &lt;/form&gt; &lt;/body&gt;
                    &lt;/html&gt; )</f>
                <f n="main.xqm">module namespace admin = "http://sade/admin" ; declare namespace tei
                    = "http://www.tei-c.org/ns/1.0"; declare namespace sade = "http://bbaw.de/sade";
                    declare function admin:main($configfile as xs:anyURI) as item()* { let $conf :=
                    doc($configfile)/sade:SADE_project let $fluid := if
                    ($conf/sade:design/sade:fluid[contains(., 'true')]) then ('-fluid') else ()
                    return &lt;html&gt; &lt;head&gt; &lt;!-- TODO title jeder Seite beim
                    Zusammenbauen aus der conf auslesen --&gt;
                    &lt;title&gt;{$conf/sade:meta/sade:project_name/text()}&lt;/title&gt; &lt;!--
                    TODO Die folgenden Zeilen im Header in ein Standardmodul auslagern, das die
                    Seiten zusammenbaut und bei der Gelegenheit die benötigten Komponenten einfügt!
                    --&gt; &lt;link rel="stylesheet/less" type="text/css"
                    href="/exist/rest/db/sade/modules/admin/kickstrap/kickstrap.less"/&gt; &lt;link
                    rel="stylesheet" type="text/css" href="static/sade.css" /&gt; &lt;script
                    src="/exist/rest/db/sade/modules/admin/kickstrap/Kickstrap/js/less-1.3.0.min.js"&gt;
                    &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--TODO Layout aus der conf
                    auslesen --&gt; &lt;div class="container{$fluid}"&gt; &lt;div
                    class="row{$fluid}" id="header"&gt; &lt;div class="span12 offset0"&gt;
                    &lt;h1&gt;{$conf/sade:meta/sade:project_name/text()}&lt;/h1&gt; &lt;/div&gt;
                    &lt;/div&gt; &lt;div class="row{$fluid}" id="navigation"&gt; &lt;div
                    class="span12 offset0"&gt; &lt;div class="navbar "&gt; &lt;div
                    class="navbar-inner"&gt; &lt;div class="container-fluid"&gt; &lt;ul
                    class="nav"&gt; &lt;li class="active"&gt; &lt;a
                    href="index.xql"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=""&gt; &lt;a
                    href="edition.xql"&gt;Digitale Edition&lt;/a&gt; &lt;/li&gt; &lt;li
                    class="disabled"&gt; &lt;a href="#"&gt;Help&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;
                    &lt;!--&lt;form class="navbar-search pull-right"&gt; &lt;input type="text"
                    class="search-query" placeholder="Search"/&gt; &lt;/form&gt;--&gt; &lt;/div&gt;
                    &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div
                    class="row{$fluid}"&gt; &lt;div class="span8 offset0"&gt; &lt;div
                    class="hero-unit"&gt; &lt;h1&gt;AvH Briefedition&lt;/h1&gt; &lt;p&gt;The
                    Scalable Architecture for Digital Editions (SADE) gives you the opprtunity to
                    set up your own project within minutes! &lt;/p&gt; &lt;p&gt; &lt;a class="btn
                    btn-primary btn-large" href="admin/dashboard.xql"&gt; Get started! &lt;/a&gt;
                    &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row{$fluid}"
                    id="footer"&gt; &lt;div class="container{$fluid}"&gt; &lt;p&gt;&lt;a
                    href="{$conf/sade:design/sade:footer/sade:url}"&gt;&lt;img style="height: 100px"
                    src="{$conf/sade:design/sade:footer/sade:img/replace(., '%5C', '/')}"
                    /&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script
                    src="admin/kickstrap/Kickstrap/js/jquery-1.7.1.min.js"&gt; &lt;/script&gt;
                    &lt;script src="admin/kickstrap/Kickstrap/js/kickstrap.min.js"&gt;
                    &lt;/script&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; };</f>
                <f n="new.xql">xquery version "1.0"; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0"; declare namespace
                    xmldb="http://exist-db.org/xquery/xmldb"; declare namespace
                    request="http://exist-db.org/xquery/request"; declare namespace exist =
                    "http://exist.sourceforge.net/NS/exist"; declare namespace transform =
                    "http://exist-db.org/xquery/transform"; declare namespace xf =
                    "http://www.w3.org/2002/xforms"; declare namespace sade = "http://bbaw.de/sade";
                    declare option exist:serialize "method=xhtml media-type=text/xml"; let $id :=
                    request:get-parameter("id", "general") let $lang :=
                    request:get-parameter("lang", "en") let $project :=
                    request:get-parameter("project", "") let $language :=
                    doc(concat('resources/lang/', $lang, '.xml'))//sade:lang return &lt;html
                    xmlns="http://www.w3.org/1999/xhtml" xmlns:xf="http://www.w3.org/2002/xforms"
                    xmlns:ev="http://www.w3.org/2001/xml-events"
                    xmlns:sade="http://bbaw.de/sade"&gt; &lt;head&gt; &lt;title&gt;SADE - Scalable
                    Architecture for Digital Editions&lt;/title&gt; &lt;link rel="stylesheet"
                    type="text/css" href="resources/css/newproject.css" /&gt; &lt;link
                    rel="stylesheet" type="text/css" href="resources/css/font-awesome.css" /&gt;
                    &lt;xf:model&gt; &lt;xf:instance&gt; &lt;data xmlns=""&gt; &lt;projectname/&gt;
                    &lt;projectid/&gt; &lt;/data&gt; &lt;/xf:instance&gt; &lt;!-- Daten an
                    generateproject.xql übergeben --&gt; &lt;xf:submission id="save" method="get"
                    action="/exist/rest/db/sade/modules/admin/generateproject.xql"&gt; &lt;xf:toggle
                    case="notsaved" ev:event="xforms-submit-error" /&gt; &lt;xf:toggle case="saved"
                    ev:event="xforms-submit-done" /&gt; &lt;/xf:submission&gt; &lt;!--
                    Beschriftungen laden --&gt; &lt;xf:instance
                    src="/exist/rest/db/sade/modules/admin/resources/lang/{$lang}.xml" id="lang"
                    /&gt; &lt;!-- Weitere Instanzen --&gt; &lt;/xf:model&gt; &lt;!-- Warnung beim
                    Verlassen der Seite deaktivieren --&gt; &lt;script type="text/javascript"
                    src="resources/betterform_ext.js" defer="defer"&gt;&amp;#160;&lt;/script&gt;
                    &lt;/head&gt; &lt;body&gt; &lt;div id="container"&gt; &lt;div id="head"&gt;
                    &lt;h1&gt;{$language/sade:dashboard/sade:sade/data(.)}&lt;br
                    /&gt;{$language/sade:dashboard/sade:title/data(.)}&lt;/h1&gt; &lt;div
                    id="langmenu"&gt; &lt;a href="?lang=en" title="English"&gt;EN&lt;/a&gt; | &lt;a
                    href="?lang=de" title="Deutsch"&gt;DE&lt;/a&gt; | &lt;a href="?lang=fr"
                    title="Français"&gt;FR&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div
                    id="content"&gt; &lt;h1&gt; &lt;xf:value
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:meta/sade:h"/&gt;
                    &lt;/h1&gt; &lt;xf:input ref="projectname"&gt; &lt;xf:label
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:newproject/sade:name/sade:title"/&gt;
                    &lt;xf:hint
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:newproject/sade:name/sade:hint"/&gt;
                    &lt;xf:alert
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:general/sade:requiredField"/&gt;
                    &lt;/xf:input&gt; &lt;xf:input ref="projectid"&gt; &lt;xf:label
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:newproject/sade:id/sade:title"/&gt;
                    &lt;xf:hint
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:newproject/sade:id/sade:hint"/&gt;
                    &lt;xf:alert
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:general/sade:requiredField"/&gt;
                    &lt;/xf:input&gt; &lt;!-- Speicherschaltfläche --&gt; &lt;xf:submit
                    submission="save"&gt; &lt;xf:label
                    ref="instance('lang')/sade:lang[@id='{$lang}']/sade:newproject/sade:submit"/&gt;
                    &lt;/xf:submit&gt; &lt;/div&gt; &lt;div id="footer"&gt; &lt;p&gt;SADE - Scalable
                    Architecture for Digital Editions is a project of TELOTA, Berlin-Brandenburg
                    Academy of Sciences and Humanities. SADE uses various open source software: e.g.
                    eXistdb, digilib and betterForm. Go to http://sade.bbaw.de/ for details. SADE
                    comes with ABSOLUTELY NO WARRANTY; click for details. This is free software, and
                    you are welcome to redistribute it under certain conditions; click for details.
                    Obstructing the appearance of this notice is prohibited by law.&lt;/p&gt;
                    &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; </f>
            </d>
            <d n="aqay">
                <d n="scripts"/>
                <f n="admin.xql">xquery version "1.0";&#xd; import module namespace
                    request="http://exist-db.org/xquery/request";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace crday = "http://aac.ac.at/content_repository/data-ay" at
                    "crday.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "modules/diagnostics/diagnostics.xqm";&#xd; import module namespace repo-utils =
                    "http://aac.ac.at/content_repository/utils" at "../../core/repo-utils.xqm";&#xd;
                    &#xd; let $config-path := request:get-parameter("config",
                    "/db/cr/conf/cr/config.xml"),&#xd; $op := request:get-parameter("operation",
                    ""),&#xd; (: $config := doc($config-path),&#xd; $config :=
                    repo-utils:config($config-path), :) &#xd; $project :=
                    request:get-parameter("project",""),&#xd; $config :=
                    config:config($project),&#xd; $format :=
                    request:get-parameter("x-format",'htmlpage'),&#xd; $x-context :=
                    request:get-parameter("x-context", "") (: "univie.at:cpas"
                    "clarin.at:icltt:cr:stb" :),&#xd; &#xd; $result := if ($op eq '') then &#xd;
                    crday:display-overview($config)&#xd; else if (contains ($op, 'query')) then&#xd;
                    crday:get-query-internal($config, $x-context, (contains($op, 'run')), $format)
                    &#xd; else if (contains ($op, 'scan-fcs-resource')) then&#xd;
                    crday:get-fcs-resource-scan($config-path, (contains($op, 'run')), $format) &#xd;
                    else if (contains ($op, 'struct')) then&#xd; let $init-path :=
                    request:get-parameter("init-path", ""), &#xd; $max-depth :=
                    request:get-parameter("x-maximumDepth", $crday:defaultMaxDepth)&#xd; return
                    crday:get-ay-xml($config, $x-context, $init-path, $max-depth, (contains($op,
                    'run')), $format) &#xd; else &#xd; diag:diagnostics("unsupported-operation",
                    $op)&#xd; return $result&#xd; &#xd; </f>
                <f n="aqay.xql">xquery version "3.0";&#xd; import module namespace
                    request="http://exist-db.org/xquery/request";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "../diagnostics/diagnostics.xqm";&#xd; import module namespace crday =
                    "http://aac.ac.at/content_repository/data-ay" at "crday.xqm";&#xd; import module
                    namespace fcs-tests = "http://clarin.eu/fcs/1.0/tests" at "tests.xqm";&#xd;
                    &#xd; (:~ action-list:&#xd; ! resources-overview -&gt; moved to
                    resource.xqm&#xd; ! ay-xml-run&#xd; ! ay-xml-view&#xd; &#xd; queryset-overview -
                    default&#xd; rest-queryset-run&#xd; rest-queryset-run-store&#xd;
                    rest-queryset-view&#xd; ! xpath-queryset-* ! TODO (internal query)&#xd; :)&#xd;
                    let $action := request:get-parameter("action", ""),&#xd; (: $config :=
                    doc($config-path),&#xd; $config := repo-utils:config($config-path), :) &#xd;
                    $project := request:get-parameter("project",""),&#xd; $config :=
                    config:config($project),&#xd; $format :=
                    request:get-parameter("x-format",'htmlpage'),&#xd; $x-context :=
                    request:get-parameter("x-context", $project),&#xd; &#xd; $result := (: if
                    ($action eq '' or $action eq 'resources-overview' ) then &#xd;
                    crday:display-overview($config, $x-context, $format)&#xd; &#xd; else if
                    (contains ($action, 'ay-xml')) then&#xd; let $init-path :=
                    request:get-parameter("init-path", ""), &#xd; $max-depth :=
                    request:get-parameter("x-maximumDepth", $crday:defaultMaxDepth)&#xd; return
                    crday:get-ay-xml($config, $x-context, $init-path, $max-depth, (contains($action,
                    'run')), 'terms2htmldetail')&#xd; &#xd; else :) &#xd; if ($action eq '' or
                    contains ($action, 'queryset-overview') or contains ($action, 'rest-queryset'))
                    then&#xd; let $target := request:get-parameter("target", "0"),&#xd; $queryset :=
                    request:get-parameter("queryset", "0")&#xd; let $run := if
                    (contains($action,"run")) then fcs-tests:run-testset($target, $queryset,
                    $action, $config) else ()&#xd; &#xd; return fcs-tests:display-page($target,
                    $queryset,$action, $config) &#xd; &#xd; else if (contains ($action,
                    'xpath-queryset')) then&#xd; crday:get-query-internal($config, $x-context,
                    (contains($action, 'run')), $format) &#xd; (:else if (contains ($op,
                    'scan-fcs-resource')) then&#xd; crday:get-fcs-resource-scan($config-path,
                    (contains($op, 'run')), $format) &#xd; :) &#xd; else &#xd;
                    diag:diagnostics("unsupported-operation", $action)&#xd; &#xd; let $opt :=
                    util:declare-option("exist:serialize", "media-type=text/html method=xhtml")
                    &#xd; return &lt;html&gt;&#xd; &lt;head&gt;&#xd; &lt;title&gt;cr-xq/aqay -
                    autoquery/testing suite&lt;/title&gt;&#xd; &lt;meta http-equiv="Content-Type"
                    content="text/html; charset=UTF-8"/&gt;&#xd; &lt;link rel="stylesheet"
                    type="text/css" href="/exist/apps/cr-xq/modules/aqay/scripts/tests.css" /&gt;
                    &#xd; &lt;link rel="stylesheet" type="text/css"
                    href="/exist/apps/cr-xq/modules/shared/scripts/style/cmds-ui.css" /&gt;&#xd;
                    &lt;/head&gt;&#xd; &lt;body&gt; &#xd; &lt;div id="header"&gt;&#xd; &lt;!--
                    &lt;ul id="menu"&gt; &#xd; &lt;li&gt;&lt;a
                    href="collectresults.xql"&gt;Results&lt;/a&gt;&lt;/li&gt;&#xd; &lt;/ul&gt;--&gt;
                    &#xd; &lt;h1&gt;cr-xq/aqay - autoquery/testing suite&lt;/h1&gt;&#xd; &lt;a
                    href="resource?action=resources-overview"&gt;resources &lt;/a&gt; &lt;a
                    href="aqay?action=queryset-overview"&gt; querysets&lt;/a&gt;&#xd; &lt;span&gt;
                    user: {request:get-attribute("org.exist.demo.login.user")}&lt;/span&gt;&#xd;
                    &lt;/div&gt;&#xd; &lt;div id="content-wrapper"&gt; {$result }&lt;/div&gt;&#xd;
                    &lt;/body&gt;&#xd; &lt;/html&gt; &#xd; &#xd; </f>
                <f n="crday.xqm">module namespace crday =
                    "http://aac.ac.at/content_repository/data-ay";&#xd; &#xd; import module
                    namespace repo-utils = "http://aac.ac.at/content_repository/utils" at
                    "../../core/repo-utils.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "../diagnostics/diagnostics.xqm";&#xd; (:import module namespace fcs =
                    "http://clarin.eu/fcs/1.0" at "../fcs/fcs.xqm";&#xd; import module namespace
                    resource = "http://cr-xq/resource" at "../resource/resource.xqm";&#xd; :)&#xd;
                    import module namespace xdb="http://exist-db.org/xquery/xmldb";&#xd; (:import
                    module namespace diag = "http://www.loc.gov/zing/srw/diagnostic/" at
                    "modules/diagnostics/diagnostics.xqm";&#xd; import module namespace
                    util="http://exist-db.org/xquery/util";&#xd; import module namespace
                    kwic="http://exist-db.org/xquery/kwic";&#xd; :)&#xd; declare namespace sru =
                    "http://www.loc.gov/zing/srw/";&#xd; (:declare namespace fcs =
                    "http://clarin.eu/fcs/1.0";:)&#xd; declare namespace cmd =
                    "http://www.clarin.eu/cmd/";&#xd; (:declare namespace tei =
                    "http://www.tei-c.org/ns/1.0";:)&#xd; declare namespace cr=
                    "http://aac.ac.at/content-repository";&#xd; &#xd; declare variable
                    $crday:docTypeTerms := "Termset";&#xd; declare variable $crday:defaultMaxDepth:=
                    8;&#xd; (: just analyze a subsequence of: &#xd; can be overriden with the
                    request-param: maxItems :)&#xd; declare variable $crday:maxAyRecords:= 1000;
                    &#xd; declare variable $crday:restrictAyRecordsSize:= true();&#xd; &#xd; &#xd;
                    &#xd; (:~ run or view (if available) internal check queries &#xd; &#xd; the
                    check queries need to be parametrized ( -&gt; queryset)&#xd; &#xd; @param format
                    [raw, htmlpage, html] - raw: return only the produced table, html* : serialize
                    as html&#xd; :)&#xd; declare function crday:get-query-internal($config,
                    $x-context as xs:string, $run-flag as xs:boolean, $format as xs:string ) as
                    item()* {&#xd; &#xd; let $testset := doc(repo-utils:config-value($config,
                    'tests.path')),&#xd; &#xd; $cache-path := repo-utils:config-value($config,
                    'cache.path'), &#xd; $queries-doc-name := crday:check-queries-doc-name($config,
                    $x-context), &#xd; &#xd; (: get the the results from cache, or create :)&#xd;
                    $result := if (exists($testset)) then &#xd; if
                    (repo-utils:is-in-cache($queries-doc-name, $config) and not($run-flag))
                    then&#xd; repo-utils:get-from-cache($queries-doc-name, $config) &#xd; else &#xd;
                    let $context := repo-utils:context-to-collection($x-context, $config)&#xd;
                    return if (exists($context)) then &#xd; crday:gen-query-internal($testset,
                    $context, $x-context, $cache-path, $queries-doc-name,$config)&#xd; (: no need to
                    store, because already continuously stored during querying &#xd; return
                    repo-utils:store-in-cache($index-doc-name , $data, $config) :)&#xd; else &#xd;
                    diag:diagnostics("general-error", concat("run-check-queries: no context: ",
                    $x-context))&#xd; else&#xd; diag:diagnostics("general-error",
                    concat("run-check-queries: no testset available: ",
                    repo-utils:config-value($config, 'tests.path')))&#xd; &#xd; (: return $result:)
                    &#xd; return if ($format eq 'raw') then&#xd; $result&#xd; else &#xd;
                    repo-utils:serialise-as($result, $format, 'table', $config, ()) &#xd; };&#xd;
                    &#xd; (:~ evaluates queries against given context and stores the result in
                    aresult-file&#xd; &#xd; @param $queries list of &lt;xpath&gt;-elements&#xd;
                    @param $context nodeset to evaluate the queries against ($context shall be used
                    in the queries)&#xd; @param $x-context string-key identifying the context &#xd;
                    :)&#xd; declare function crday:gen-query-internal($queries, $context as node()*,
                    $x-context as xs:string+, $result-path as xs:string, $result-filename as
                    xs:string, $config ) as item()* {&#xd; &#xd; (: collect the xpaths from the
                    queries-list before fiddling with the namespace :)&#xd; let $xpaths :=
                    $queries//xpath&#xd; (: let $context :=
                    repo-utils:context-to-collection($x-context, $config) &#xd; $context:=
                    collection("/db/mdrepo-data/cmdi-providers"), :)&#xd; &#xd; (: let $result-store
                    := xmldb:store($result-path , $result-filename, &lt;result
                    test="{$queries//test/xs:string(@id)}" context="{$x-context}"
                    &gt;&lt;/result&gt;),:)&#xd; let $result := &lt;result
                    test="{$queries//test/xs:string(@id)}" context="{$x-context}"
                    &gt;&lt;/result&gt; &#xd; let $result-doc := repo-utils:store($result-path ,
                    $result-filename, $result, true(), $config) &#xd; (: $result-doc:=
                    doc($result-store):)&#xd; &#xd; let $ns-uri := namespace-uri($context[1]/*)
                    &#xd; (: dynamically declare a default namespace for the xpath-evaluation, if
                    one is defined in current context &#xd; WATCHME: this is not very reliable,
                    mainly meant to handle default-ns: cmd :)&#xd; (: $dummy := if (exists($ns-uri))
                    then util:declare-namespace("",$ns-uri) else () :)&#xd; let $dummy :=
                    util:declare-namespace("",xs:anyURI($ns-uri)) &#xd; &#xd; let $start-time :=
                    util:system-dateTime() &#xd; let $upd-dummy := &#xd; for $xpath in $xpaths &#xd;
                    let $start-time := util:system-dateTime()&#xd; let $answer :=
                    util:eval($xpath/text())&#xd; let $duration := util:system-dateTime() -
                    $start-time&#xd; return update insert &lt;xpath key="{$xpath/@key}"
                    label="{$xpath/@label}" dur="{$duration}"&gt;{$answer}&lt;/xpath&gt; into
                    $result-doc/result&#xd; &#xd; return $result-doc&#xd; };&#xd; &#xd; &#xd; &#xd;
                    (:~&#xd; generates ay-xml for individual collections, &#xd; by invoking
                    get-ay-xml for each collection individually (as x-context)&#xd; &#xd; not
                    finished - smc:gen-mappings does this basically (for CMD data)&#xd; &#xd;
                    @returns a summary of generated stuff&#xd; :)(:&#xd; declare function
                    smc:gen-ay-xml($config, $x-context as xs:string+, $run-flag as xs:boolean,
                    $format as xs:string) as item()* {&#xd; &#xd; (\: let $mappings :=
                    doc(repo-utils:config-value($config, 'mappings')),:\)&#xd; let $context-mapping
                    := fcs:get-mapping('',$x-context, $config),&#xd; (\: if not specific mapping
                    found for given context, use whole mappings-file :\)&#xd; $mappings := if
                    ($context-mapping/xs:string(@key) = $x-context) then $context-mapping &#xd; else
                    doc(repo-utils:config-value($config, 'mappings')) &#xd; &#xd; for $map in
                    $mappings/descendant-or-self::map[@key]&#xd; let $map :=
                    crday:get-ay-xml($config, $map/xs:string(@key), true(), 'raw')&#xd; return
                    &lt;structure count_indexes="{count($map/index)}" &gt;{$map/@*}&lt;/map&gt;&#xd;
                    &#xd; };:)&#xd; &#xd; (:~ wrapper for the ay-xml function cares for storing the
                    result or fetching a stored one&#xd; &#xd; @param $format [raw, htmlpage, html]
                    - raw: return only the produced table, html* : serialize as html&#xd; @param
                    $run-flag if true - re-run even if in cache&#xd; :)&#xd; declare function
                    crday:get-ay-xml($config, $x-context as xs:string+, $init-xpath as xs:string,
                    $max-depth as xs:integer, $run-flag as xs:boolean, $format as xs:string ) as
                    item()? {&#xd; &#xd; let $name := repo-utils:gen-cache-id("structure",
                    ($x-context, $init-xpath), xs:string($max-depth)),&#xd; $result := &#xd; if
                    (repo-utils:is-in-cache($name, $config) and not($run-flag)) then&#xd;
                    repo-utils:get-from-cache($name, $config)&#xd; else&#xd; &#xd; let $context :=
                    repo-utils:context-to-collection($x-context, $config)&#xd; (: prevent running on
                    whole default collection - rather do it context by context :)&#xd; return if
                    (exists($context) and $x-context ne '') then&#xd; let $data :=
                    crday:gen-ay-xml($context, $init-xpath, $max-depth, $x-context)&#xd; return
                    repo-utils:store-in-cache($name, $data,$config)&#xd; else &#xd;
                    diag:diagnostics("general-error", concat("run-ay-xml: no context: ",
                    $x-context)) &#xd; &#xd; return if ($format eq 'raw') then&#xd; $result&#xd;
                    else &#xd; repo-utils:serialise-as($result, $format, 'terms', $config, ()) &#xd;
                    };&#xd; &#xd; &#xd; (:~ analyzes the xml-structure - sub-elements and
                    text-nodes&#xd; in the context of given collection, starting from given
                    xpath&#xd; &#xd; @param $context nodeset to analyze&#xd; @param $path if
                    starts-with '/' or = '' start directly at the $context, else eval on f
                    'descendants-or-self'-axis&#xd; if $path empty - diagnostics&#xd; calls elem-r
                    for recursive processing&#xd; &#xd; @returns xml-with paths and numbers &#xd;
                    :)&#xd; declare function crday:gen-ay-xml($context as item()*, $path as
                    xs:string, $depth as xs:integer ) as element() {&#xd; crday:gen-ay-xml($context,
                    $path, $depth, '')&#xd; };&#xd; &#xd; (:~ &#xd; @param $maxItems can be injected
                    via request (as URL-param), default= 1000&#xd; :)&#xd; declare function
                    crday:gen-ay-xml($context as item()*, $path as xs:string, $depth as xs:integer,
                    $x-context as xs:string ) as element() {&#xd; &#xd; (:let $collection :=
                    collection($cr:dataPath),&#xd; if ($collections[1] eq $cr:collectionRoot)
                    then&#xd; util:eval(fn:concat("$collection/descendant::IsPartOf[ft:query(.,
                    &lt;query&gt;&lt;term&gt;", xdb:decode($coll),
                    "&lt;/term&gt;&lt;/query&gt;)]/ancestor-or-self::CMD/descendant-or-self::",
                    $path))&#xd; :)&#xd; if (not(exists($path))) then&#xd;
                    diag:diagnostics("general-error", "ay-xml: no starting path provided") &#xd;
                    else&#xd; &#xd; let $max-records :=
                    request:get-parameter("maxItems",$crday:maxAyRecords),&#xd; $ns-uri :=
                    namespace-uri($context[1]/*),&#xd; $local-name :=
                    $context[1]/*/local-name(),&#xd; (: $prefix := if
                    (exists(prefix-from-QName($qname))) then prefix-from-QName($qname) else
                    "",:)&#xd; $dummy := if (exists($ns-uri)) then
                    util:declare-namespace("",$ns-uri) else ()&#xd; &#xd; let $full-path := if
                    (starts-with($path,'/') or $path = '') then&#xd; fn:concat("$context",
                    $path)&#xd; else fn:concat("$context/descendant-or-self::", $path)&#xd; &#xd;
                    let $all-nodes := util:eval($full-path)&#xd; let $path-nodes := if
                    ($crday:restrictAyRecordsSize) then&#xd; subsequence($all-nodes, 1,
                    $max-records)&#xd; else &#xd; $all-nodes&#xd; &#xd; let $entries :=
                    crday:elem-r($path-nodes, $path, $ns-uri, $depth, $depth),&#xd; (:
                    $coll-names-value := if (fn:empty($collections)) then () else attribute colls
                    {fn:string-join($collections, ",")},:)&#xd; $dummy-undeclare-ns :=
                    util:declare-namespace("",xs:anyURI("")), &#xd; $result := element
                    {$crday:docTypeTerms} {&#xd; (: $coll-names-value,:)&#xd; attribute context
                    {$x-context},&#xd; attribute count {count($all-nodes)},&#xd; attribute depth
                    {$depth},&#xd; (: attribute fullpath {$full-path},:)&#xd; attribute created
                    {fn:current-dateTime()},&#xd; $entries &#xd; }&#xd; return $result&#xd; &#xd;
                    };&#xd; &#xd; (:~ goes down the xml-structure recursively and creates a summary
                    about it along the way&#xd; &#xd; namespace aware (handles namespace: none,
                    default, explicit)&#xd; :)&#xd; declare function crday:elem-r($path-nodes as
                    node()*, $path as xs:string, $ns as xs:anyURI?, $max-depth as xs:integer, $depth
                    as xs:integer) as element() {&#xd; let $path-count := count($path-nodes),&#xd;
                    $child-elements := $path-nodes/child::element(),&#xd; $child-ns-qnames := if
                    (exists($child-elements)) then
                    distinct-values($child-elements/concat(namespace-uri(), '|', local-name())) else
                    (), &#xd; $nodes-child-terminal := if (empty($child-elements)) then $path-nodes
                    else () (: Maybe some selected elements $child-elements[not(element())] later on
                    :),&#xd; $text-nodes := $nodes-child-terminal/text(),&#xd; (: $text-nodes :=
                    $path-nodes/text(),:)&#xd; $text-count := count($text-nodes),&#xd;
                    $text-count-distinct := count(distinct-values($text-nodes)),&#xd;
                    $dummy-undeclare-ns := util:declare-namespace("",xs:anyURI(""))&#xd; return
                    &#xd; (: &lt;Term path="{fn:concat("//", $path)}" name="{text:groups($path,
                    "/([^/]+)$")[last()]}" count="{$path-count}" count_text="{$text-count}"
                    count_distinct_text="{$text-count-distinct}"&gt;{ :)&#xd; &lt;Term
                    path="{fn:concat("", translate($path,'/','.'))}" name="{(text:groups($path,
                    "/([^/]+)$")[last()],$path)[1] }" count="{$path-count}"
                    count_text="{$text-count}"
                    count_distinct_text="{$text-count-distinct}"&gt;{&#xd; (attribute ns {$ns},&#xd;
                    if ($depth &gt; 0) then&#xd; for $ns-qname in $child-ns-qnames[. != '']&#xd; let
                    $ns-uri := substring-before($ns-qname, '|'),&#xd; $local-name :=
                    substring-after($ns-qname, '|'),&#xd; (: $prefix := if
                    (exists(prefix-from-QName($qname))) then prefix-from-QName($qname) else
                    "",:)&#xd; (: dynamically declare a namespace for the next step, if one is
                    defined in current context :)&#xd; $dummy := if (exists($ns-uri)) then
                    util:declare-namespace("",$ns-uri) else ()&#xd; return &#xd;
                    crday:elem-r(util:eval(concat("$path-nodes/", $local-name)), concat($path, '/',
                    $local-name), $ns-uri, $max-depth, $depth - 1) &#xd; (:&#xd; for $ns-qname in
                    $child-ns-qnames[. != '']&#xd; let $ns-uri := substring-before($ns-qname,
                    '|'),&#xd; $qname := substring-after($ns-qname, '|'),&#xd; $prefix := if
                    (exists(prefix-from-QName($qname))) then prefix-from-QName($qname) else "",&#xd;
                    (\: dynamically declare a namespace for the next step, if one is defined in
                    current context :\)&#xd; $dummy := if (exists($ns-uri)) then
                    util:declare-namespace($prefix,$ns-uri) else ()&#xd; return &#xd;
                    crday:elem-r(util:eval(concat("$path-nodes/", $qname)), concat($path, '/',
                    $qname), $ns-uri, $max-depth, $depth - 1):) &#xd; else 'maxdepth'&#xd;
                    )}&lt;/Term&gt;&#xd; };&#xd; &#xd; &#xd; (:~ return doc-name out of context and
                    testset (from config) or empty string if testset does not exist :)&#xd; declare
                    function crday:check-queries-doc-name($config, $x-context as xs:string) as
                    xs:string {&#xd; let $testset := doc(repo-utils:config-value($config,
                    'tests.path')),&#xd; $testset-name := if (exists($testset)) then
                    util:document-name($testset) else (),&#xd; $sanitized-xcontext :=
                    repo-utils:sanitize-name($x-context) &#xd; return if (exists($testset)) then
                    repo-utils:gen-cache-id("queries", ($sanitized-xcontext, $testset-name),"") else
                    ""&#xd; &#xd; };&#xd; </f>
                <f n="tests.xql">xquery version "1.0";&#xd; &#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace fcs-tests = "http://clarin.eu/fcs/1.0/tests" at
                    "tests.xqm"; &#xd; (:import module namespace httpclient =
                    "http://exist-db.org/xquery/httpclient";:)&#xd; &#xd; declare namespace sru =
                    "http://www.loc.gov/zing/srw/";&#xd; declare namespace fcs =
                    "http://clarin.eu/fcs/1.0";&#xd; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0";&#xd; &#xd; (:let $target :=
                    "http://localhost:8681/exist/cr/"&#xd; let $testset-name := "test_connect"&#xd;
                    &#xd; let $tests := doc(concat("testsets/", $testset-name,
                    ".xml"))//TestSet&#xd; :)&#xd; (:let $data :=
                    httpclient:get(xs:anyURI("http://localhost:8680/exist/rest/db/content_repository/scripts/cr.xql"),
                    false(), () ) :)&#xd; (:let $store := xmldb:store("results",
                    concat($testset-name, '.xml'), t:run-testSet($tests)) :)&#xd; &#xd; &#xd; (:
                    t:run-testSet($tests)&#xd; t:format-testResult($store):)&#xd; &#xd; (: ??
                    :)&#xd; let $project := request:get-parameter("project","")&#xd; let $config :=
                    config:config($project) &#xd; &#xd; let $target :=
                    request:get-parameter("target", "0")&#xd; let $queryset :=
                    request:get-parameter("queryset", "0")&#xd; let $operation :=
                    request:get-parameter("operation", "overview")&#xd; let $messages := ""&#xd;
                    return&#xd; if ($operation eq "run" or $operation eq "run-store") then &#xd; let
                    $run := fcs-tests:run-testset($target, $queryset, $operation, $config)&#xd; (:
                    return $run:)&#xd; return fcs-tests:display-page($target, $queryset, $operation,
                    $config)&#xd; else&#xd; fcs-tests:display-page($target, $queryset,$operation,
                    $config)</f>
                <f n="tests.xqm">xquery version "3.0";&#xd; module namespace fcs-tests =
                    "http://clarin.eu/fcs/1.0/tests";&#xd; &#xd; import module namespace httpclient
                    = "http://exist-db.org/xquery/httpclient";&#xd; import module namespace
                    t="http://exist-db.org/xquery/testing";&#xd; import module namespace repo-utils
                    = "http://aac.ac.at/content_repository/utils" at
                    "../../core/repo-utils.xqm";&#xd; import module namespace
                    xqjson="http://xqilla.sourceforge.net/lib/xqjson";&#xd; &#xd; declare namespace
                    zr="http://explain.z3950.org/dtd/2.0/";&#xd; declare namespace sru =
                    "http://www.loc.gov/zing/srw/";&#xd; declare namespace fcs =
                    "http://clarin.eu/fcs/1.0";&#xd; declare namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/";&#xd; declare namespace ds =
                    "http://aac.ac.at/corpus_shell/dataset";&#xd; declare namespace
                    xhtml="http://www.w3.org/1999/xhtml";&#xd; &#xd; &#xd; (: sample input: &#xd;
                    :)&#xd; (:declare variable $fcs-tests:config := doc("config.xml");&#xd; declare
                    variable $fcs-tests:cr-config :=
                    repo-utils:config("/db/apps/cr-xq/modules/fcs/config.xml");:)&#xd; (:declare
                    variable $fcs-tests:run-config := "run-config.xml";:)&#xd; (:declare variable
                    $fcs-tests:testsets-coll := "/db/cr/modules/testing/testsets/";&#xd; declare
                    variable $fcs-tests:results-coll := "/db/cr/modules/testing/results/";&#xd;
                    :)&#xd; declare variable $fcs-tests:href-prefix := "tests.xql";&#xd; &#xd; (:~
                    this function is accessed by the testing-code to get configuration-options from
                    the run-config :)&#xd; declare function fcs-tests:config-value($config, $type,
                    $key as xs:string?) as xs:string* {&#xd; &#xd; (: let $config :=
                    doc(concat($fcs-tests:testsets-coll, $fcs-tests:run-config))/config:)&#xd; (: if
                    ($type eq "queryset") then
                    xs:string($config//queryset[xs:string(@key)=$key]/&#xd; else :)&#xd; if ($type
                    eq "action") then repo-utils:config-value($config, 'action')&#xd; else
                    $config//target[xs:string(@key)=$key]/xs:string(@url)&#xd; };&#xd; (:&#xd;
                    declare function fcs-tests:config-key($key as xs:string) as xs:string* {&#xd;
                    let $config := doc(concat($fcs-tests:testsets-coll,
                    $fcs-tests:run-config))/config&#xd; return if ($key eq "testset") then
                    xs:string($config//testset/@key)&#xd; else xs:string($config//target/@key)&#xd;
                    };&#xd; :)&#xd; &#xd; declare function fcs-tests:get-result-paths($target as
                    xs:string, $queryset as xs:string, $config) as xs:string* {&#xd; let $store-path
                    := repo-utils:config-value($config, "store.path") &#xd; return
                    (concat($store-path, $target, "/"), concat($queryset, ".xml"))&#xd; };&#xd;
                    &#xd; declare function fcs-tests:get-result-path($target as xs:string, $queryset
                    as xs:string, $config) as xs:string* {&#xd;
                    string-join(fcs-tests:get-result-paths($target , $queryset, $config ), "" )&#xd;
                    };&#xd; &#xd; declare function fcs-tests:get-result($target as xs:string,
                    $queryset as xs:string, $config) as item() {&#xd; let $result-path :=
                    fcs-tests:get-result-path($target, $queryset, $config)&#xd; let $result := if
                    ($target = '' or $queryset = '') then () &#xd; else if
                    (doc-available($result-path)) then&#xd; doc($result-path) &#xd; else
                    &lt;diagnostics&gt;&lt;diagnostic key="result-unavailable"&gt;result
                    unavailable: {$result-path}&lt;/diagnostic&gt;&#xd;
                    &lt;diagnostic&gt;{fcs-tests:get-queryset($queryset,
                    $config)}&lt;/diagnostic&gt;&#xd; &lt;/diagnostics&gt;&#xd; return $result&#xd;
                    };&#xd; &#xd; (:~ try to get the testset-file based on the testset-key&#xd;
                    @returns testset-file if available, otherwise empty result&#xd; :)&#xd; declare
                    function fcs-tests:get-queryset($queryset as xs:string, $config) as item()*
                    {&#xd; let $queryset-basepath := repo-utils:config-value($config,
                    "queryset.path") &#xd; let $queryset-path := concat($queryset-basepath,
                    $queryset, ".xml")&#xd; return if (doc-available($queryset-path)) then &#xd;
                    doc($queryset-path)&#xd; else &#xd; &lt;diagnostic&gt;unknown testset:
                    {$queryset}&lt;/diagnostic&gt;&#xd; };&#xd; &#xd; &#xd; (:~ main function
                    governing the execution of the tests&#xd; &#xd; Generates a run-config out of
                    the full config based on the parameters.&#xd; @param $target-key identifying key
                    of the target as set in the config, or 'all' for all targets in th config&#xd;
                    @param $queryset-key identifying key of the testset as set in the config (that
                    also has to be the name of the testset-file)&#xd; @param $action run or
                    run-store; with `run-store` also the fetched individual results stored, the
                    final result is stored anyway&#xd; :)&#xd; declare function
                    fcs-tests:run-testset($target-key as xs:string, $queryset-key as xs:string,
                    $action as xs:string, $config) as item()* {&#xd; &#xd; (: preparing a
                    configuration for given run, based on the parameters :)&#xd; (: let $run-config
                    := &lt;config&gt;{($config//target[xs:string(@key) = $target],&#xd;
                    $config//testset[xs:string(@key) = $queryset-key],&#xd; &lt;property
                    key="action"&gt;{$action}&lt;/property&gt;)}&lt;/config&gt;&#xd; :)&#xd; (: for
                    now put the whole config plus the action-param&#xd; perhaps this could be
                    cleaned up :) &#xd; let $run-config := &lt;config&gt;{($config, &lt;property
                    key="action"&gt;{$action}&lt;/property&gt;)}&lt;/config&gt;&#xd; (: let
                    $run-config := ($config, &lt;property
                    key="operation"&gt;{$action}&lt;/property&gt;):)&#xd; &#xd; &#xd; (: TODO:
                    eliminate the run-config - but probably needed for t:run-testSet :)&#xd; (: let
                    $queryset-path := repo-utils:config-value($config, "queryset.path") &#xd; let
                    $store := repo-utils:store($queryset-path, $fcs-tests:run-config, $run-config,
                    true()) :)&#xd; &#xd; (: return $run-config:)&#xd; &#xd; let $targets := if
                    ($target-key='all') then fcs-tests:get-target-keys($config) else $target-key
                    &#xd; for $target in $targets &#xd; &#xd; let $querysets := if
                    ($queryset-key='all') then fcs-tests:get-querysets($config, $target) else
                    fcs-tests:get-queryset($queryset-key, $config) &#xd; &#xd; for $queryset in
                    $querysets&#xd; (: let $queryset := fcs-tests:get-queryset($queryset-key,
                    $config):)&#xd; let $start-time := util:system-dateTime()&#xd; let $result := if
                    (exists($queryset)) then &#xd; let $tests := $queryset//TestSet&#xd; (:
                    distinguish the testset, that the testing-module can process&#xd; and the
                    home-made test-doc, that tests URLs :)&#xd; return if (exists($tests)) then&#xd;
                    t:run-testSet($tests, ())&#xd; else&#xd; fcs-tests:test-rest($queryset, $target,
                    $run-config)&#xd; else&#xd; $queryset &#xd; let $end-time :=
                    util:system-dateTime()&#xd; let $test-wrap := &lt;testrun duration="{$end-time -
                    $start-time}" on="{fn:current-dateTime()}" &gt;{$result}&lt;/testrun&gt;&#xd;
                    let $store-result := fcs-tests:store-result($target, $queryset-key, $test-wrap,
                    $config)&#xd; (:for $test in $tests/tests/test return
                    fcs-tests:run-test($test):)&#xd; return $store-result&#xd; &#xd; };&#xd; &#xd;
                    (:~ process a test-doc (target is expected to be set in the config)&#xd; :)&#xd;
                    declare function fcs-tests:test-rest($test-doc as node(), $target, $config) as
                    item()* {&#xd; &#xd; let $result := local:dispatch($test-doc, $target,
                    $config)&#xd; &#xd; (:&#xd; let $targets := if (exists($test/target)) then
                    $test/target else $test/preceding-sibling::target&#xd; let $requests := for
                    $target in $targets return concat($target, $test/request/text())&#xd; let $data
                    := for $request in $requests return&#xd; &lt;request href="{$request}" id&#xd;
                    httpclient:get(xs:anyURI($request), false(), () )&#xd; &#xd; let $check := for
                    $condition in $test/condition &#xd; let $expr :=concat("($data/",
                    $condition/text(), " eq ", xs:string($condition/@result), ")")&#xd; return
                    &lt;check expr="{$expr}" &gt;{util:eval($expr)} &lt;/check&gt;&#xd; return
                    &lt;test&gt;&lt;id&gt;{$test/id}&lt;/id&gt;&lt;label&gt;{$test/label}&lt;/label&gt;&#xd;
                    &lt;requests&gt;{$requests}&lt;/requests&gt;&#xd;
                    &lt;results&gt;{$check}&lt;/results&gt;&#xd; &lt;/test&gt;&#xd; :)&#xd; return
                    $result&#xd; &#xd; };&#xd; &#xd; (:~ This function takes the children of the
                    node and passes them&#xd; back into the typeswitch function. :)&#xd; declare
                    function local:passthru($x as node(), $target, $config) as node()*&#xd; {&#xd;
                    for $z in $x/node() return local:dispatch($z, $target, $config)&#xd; };&#xd;
                    &#xd; (:~ This is the recursive typeswitch function, to traverse the
                    testset-document :)&#xd; declare function local:dispatch($x as node(), $target,
                    $config) as node()*&#xd; {&#xd; typeswitch ($x)&#xd; case text() return $x&#xd;
                    case element (test) return element div
                    {$x/@*[not(name()=('username','password'))], attribute class {"test"},
                    fcs-tests:process-test($x, $target, $config)} &#xd; case element() return
                    element {$x/name()} {$x/@*, local:passthru($x, $target, $config)} &#xd; default
                    return local:passthru($x, $target, $config)&#xd; };&#xd; &#xd; (:~ executes a
                    rest-test. &#xd; &#xd; if the test references a list, iterate over the items of
                    the list and run a request for each&#xd; (substituting the values from the list
                    in the request)&#xd; the substituted request is passed to
                    fcs-tests:process-request() for actual execution&#xd; &#xd; expects:&#xd;
                    &lt;div class="test" id="search-haus"&gt;&#xd; &lt;a class="request"
                    href="?operation=searchRetrieve&amp;amp;query=Haus"&gt;search:
                    Haus&lt;/a&gt;&#xd; &lt;span class="check
                    xpath"&gt;//sru:numberOfRecords&lt;/span&gt;&#xd; &lt;/div&gt;&#xd; &#xd;
                    @returns the (sequence of) requested-url as link, results of the
                    xpath-evaluations as a div-list and any diagnostics&#xd; :) &#xd; declare
                    function fcs-tests:process-test($test as node(), $target-key, $config) as
                    item()* {&#xd; &#xd; let $a := $test/a,&#xd; $test-id :=
                    xs:string($test/@id),&#xd; $test-list := xs:string($test/@list),&#xd; $list-doc
                    := if (doc-available($test-list)) then doc($test-list) else (),&#xd; $target-uri
                    := fcs-tests:config-value($config, "target", $target-key), &#xd; (: $target-key
                    := fcs-tests:config-key("target"),:)&#xd; $action :=
                    fcs-tests:config-value($config, "action", ())&#xd; &#xd; &#xd; return if
                    (empty($list-doc)) then &#xd; let $request := concat($target-uri,
                    xs:string($a/@href)) &#xd; return fcs-tests:process-request ($test, $request,
                    $a/text(), $target-key, $test-id, $action, $config)&#xd; else &#xd; (: if we
                    have a list, iterate over the items of the list and run a request for each
                    :)&#xd; &#xd; for $i at $c in $list-doc/*/*&#xd; let $request :=
                    concat($target-uri, fcs-tests:subst(xs:string($a/@href), $i)),&#xd; $i-id := if
                    ($i/@id) then xs:string($i/@id) else $c,&#xd; $request-id := concat($test-id,
                    $i-id),&#xd; $a-text := fcs-tests:subst(xs:string($a/text()), $i)&#xd; return
                    fcs-tests:process-request ($test, $request, $a-text, $target-key, $request-id,
                    $action, $config)&#xd; };&#xd; &#xd; (:~ executes one URL-request. &#xd; &#xd;
                    Issues one http-call to the target-url in the a@href-attribute, stores the
                    incoming result (only if $action='run-store') and evaluates the associated
                    xpaths &#xd; &#xd; allows for simple authentication mechanism, via
                    http-header.&#xd; also tried to send as params which the the new exist auth
                    seemed to accept, &#xd; but it did not work out, still got redirect to
                    login&#xd; &#xd; @param $test div[@class='test']-element&#xd; @param $request
                    resolved (substituted) link&#xd; @param $a-text resolved (substituted) text for
                    the link&#xd; @param $target-key identifier of the target (will be used as
                    directory, when storing the result)&#xd; @param $request-id identifier of the
                    request (will be used as the name of the file, when storing the result)&#xd;
                    &#xd; @returns the requested-url as link, results of the xpath-evaluations as a
                    div-list and any diagnostics&#xd; :) &#xd; declare function
                    fcs-tests:process-request($test, $request as xs:string, $a-text as xs:string,
                    $target-key as xs:string, $request-id as xs:string, $action as xs:string,
                    $config) as item()* { &#xd; &#xd; (: let $result-link :=
                    $config//property[xs:string(@key)='result-link'] :)&#xd; let $result-link :=
                    repo-utils:config-value($config,'result-link')&#xd; &#xd; let $username := if
                    ($test/@username) then $test/xs:string(@username) else "" &#xd; let $password :=
                    if ($test/@password) then $test/xs:string(@password) else "" &#xd; &#xd; (: not
                    working let $auth-param := if ($test/@auth-type) then concat('&amp;amp;user=',
                    $username, '&amp;amp;password=', $password) else "" :)&#xd; &#xd; let $headers
                    := if ($username='') then () else &#xd; let $auth := concat("Basic ",
                    util:base64-encode(concat($username, ':', $password)))&#xd; return
                    &lt;headers&gt;&lt;header name="Authorization"
                    value="{$auth}"/&gt;&lt;/headers&gt;&#xd; &#xd; &#xd; let $a-processed := (if
                    (contains($result-link,'original')) then &lt;a
                    href="{$request}"&gt;{$a-text}&lt;/a&gt; else (),&#xd; if
                    (contains($result-link,'rewrite')) then&#xd; (: let $cache-uri-prefix :=
                    $config//property[xs:string(@key)='result-uri-prefix']:)&#xd; let
                    $cache-uri-prefix := repo-utils:config-value($config,'result-uri-prefix')&#xd;
                    let $req-rwr := concat($cache-uri-prefix, $request-id, ".xml") &#xd; return
                    &lt;a href="{$req-rwr}"&gt;{$a-text}&lt;/a&gt;&#xd; else (),&#xd; if
                    (contains($result-link,'cache')) then&#xd; (:let $cache-uri := if
                    (exists($store)):) &#xd; &lt;a href="{concat('results/', $target-key, "/",
                    $request-id, ".xml")}" &gt; cache &lt;/a&gt; &#xd; else ()&#xd; ) &#xd; &#xd;
                    let $result-data-raw := httpclient:get(xs:anyURI($request), false(), $headers
                    )&#xd; &#xd; &#xd; (: if json data - convert to xml - and add the converted xml
                    to the result :)&#xd; let $json := if
                    ($result-data-raw//httpclient:body/xs:string(@encoding)="Base64Encoded")
                    then&#xd; util:base64-decode($result-data-raw//httpclient:body/text())&#xd; else
                    &#xd; $result-data-raw//httpclient:body/text()&#xd; &#xd; let $json-xml := if
                    ($json) then&#xd; try {&#xd; xqjson:parse-json($json) &#xd; }&#xd; catch * &#xd;
                    {&#xd; diag:diagnostics('general-error', string-join(($err:code ,
                    $err:description, $err:value), '; '))&#xd; }&#xd; else ()&#xd; &#xd; &#xd; let
                    $result-data := if
                    ($result-data-raw//httpclient:headers/httpclient:header[xs:string(@name)="Content-Type"]&#xd;
                    /contains(xs:string(@value),"application/json")) then &#xd; (: let $json := if
                    ($result-data-raw//httpclient:body/xs:string(@encoding)="Base64Encoded")
                    then&#xd; util:base64-decode($result-data-raw//httpclient:body/text())&#xd; else
                    &#xd; $result-data-raw//httpclient:body/text()&#xd; let $json-xml := $json
                    (\:xqjson:parse-json($json):\):)&#xd; &#xd; &lt;httpclient:response&gt;&#xd;
                    {($result-data-raw/@statusCode,&#xd; $result-data-raw/httpclient:headers,&#xd;
                    $result-data-raw/httpclient:body,&#xd; &lt;httpclient:body
                    mimetype="application/xml;
                    charset=UTF-8"&gt;{$json-xml}&lt;/httpclient:body&gt;&#xd;
                    )}&lt;/httpclient:response&gt;&#xd; else if (repo-utils:config-value($config,
                    'store.flag') eq 'data-only') then &#xd;
                    $result-data-raw//httpclient:body/*&#xd; else $result-data-raw &#xd; &#xd; (:
                    let $store := if ($action eq 'run-store') then
                    fcs-tests:store-result($target-key, $request-id,
                    $result-data//httpclient:body/*) else ()&#xd; rather store everything including
                    the envelope: :)&#xd; let $store := if (contains($action,'run-store')) then
                    fcs-tests:store-result($target-key, $request-id, $result-data, $config) else
                    ()&#xd; &#xd; &#xd; (: &lt;a href="{fcs-tests:get-result-paths($target-key,
                    $request-id) else ():)&#xd; (: let $cache-uri := if (exists($store)) then &lt;a
                    href="{concat(repo-utils:base-url(()), document-uri($store))}" &gt; cache
                    &lt;/a&gt; else ():)&#xd; (: evaluate all xpaths defined for given request :)
                    &#xd; let $check := for $xpath in $test/xpath &#xd; let $evald :=
                    util:eval($xpath/text())&#xd; &#xd; return &#xd; &lt;div&gt;&lt;span
                    class="key"&gt;{if (exists($xpath/@key)) then xs:string($xpath/@key) else
                    $xpath/text()}:&lt;/span&gt; &#xd; &lt;span class="value {if ($evald instance of
                    xs:boolean) then xs:string($evald) else '' }"&gt;{$evald}&lt;/span&gt;&#xd;
                    &lt;/div&gt;&#xd; &#xd; (: checking extra for diagnostics :)&#xd; let
                    $http-status := $result-data//xs:string(@statusCode) &#xd; let $diag :=
                    ($result-data//diag:diagnostic, $result-data//exception, &#xd; if ($http-status
                    ne '200') then &lt;http-status&gt;{$http-status}&lt;/http-status&gt; else ())
                    &#xd; let $wrapped-diag := if (exists($diag)) then &#xd; &lt;diagnostics
                    type="{string-join($diag/name(),',')}" &gt;{$diag}&lt;/diagnostics&gt; else
                    ()&#xd; &#xd; return ($a-processed, $check, $wrapped-diag)&#xd; (: ,
                    $cache-uri:)&#xd; };&#xd; &#xd; &#xd; declare function
                    fcs-tests:store-result($target as xs:string, $queryset as xs:string, $result as
                    node(), $config) as item()* { &#xd; fcs-tests:store-result ($target, $queryset,
                    "", $result, $config)&#xd; };&#xd; &#xd; &#xd; (:~ stores the result of a
                    testset &#xd; @returns reference to the stored document (as the underlying
                    function repo-utils:store())&#xd; :)&#xd; declare function
                    fcs-tests:store-result($target as xs:string, $queryset as xs:string, $test as
                    xs:string, $result as node(), $config) as item()* {&#xd; (: create collection
                    for results for one target :)&#xd; let $store-path :=
                    repo-utils:config-value($config, "store.path")&#xd; &#xd; let $create-coll := if
                    (not(xmldb:collection-available(concat($store-path, $target)))) then&#xd;
                    repo-utils:mkcol("",concat($store-path, $target)) else ()&#xd; (:
                    xmldb:create-collection($store-path, $target) else ():)&#xd; &#xd; &#xd; let
                    $result-path := fcs-tests:get-result-paths($target, concat($queryset, $test),
                    $config)&#xd; &#xd; let $store-result := repo-utils:store($result-path[1],
                    $result-path[2], $result, true(),$config)&#xd; &#xd; return $store-result&#xd;
                    };&#xd; &#xd; (:~ generates a html-view of the resulting testset&#xd; relies on
                    repo-utils serialization function, expecting a stylesheet with the key:
                    &lt;b&gt;test2view&lt;/b&gt;&#xd; :)&#xd; declare function
                    fcs-tests:format-result($result as node(), $config) as item()* {&#xd; &#xd; if
                    ($result[self::element(diagnostics)]) then&#xd; &lt;div
                    class="message"&gt;{$result/text()}&lt;/div&gt;&#xd; else if
                    (exists($result/testrun)) then&#xd; repo-utils:serialise-as ($result, "html",
                    "test", $config)&#xd; else repo-utils:serialise-as ($result, "html", "test",
                    $config)&#xd; (: return quite empty html ?? &#xd; t:format-testResult($result)
                    :)&#xd; };&#xd; &#xd; (:~ generates the html-page displaying either the
                    overview, or the result of selected testset &#xd; :)&#xd; declare function
                    fcs-tests:display-page($target as xs:string, $queryset as xs:string, $action,
                    $config) as item()* {&#xd; &#xd; let $result := fcs-tests:get-result($target,
                    $queryset, $config) &#xd; &#xd; let $formatted-result :=
                    fcs-tests:format-result($result, $config) &#xd; let $opt :=
                    util:declare-option("exist:serialize", "media-type=text/html method=xhtml")
                    &#xd; (:&#xd; &lt;html&gt;&#xd; &lt;head&gt;&#xd; &lt;title&gt;cr-xq/aqay -
                    autoquery/testing suite&lt;/title&gt;&#xd; &lt;meta http-equiv="Content-Type"
                    content="text/html; charset=UTF-8"/&gt;&#xd; &lt;link rel="stylesheet"
                    type="text/css" href="/exist/apps/cr-xq/modules/aqay/scripts/tests.css" /&gt;
                    &#xd; &lt;link rel="stylesheet" type="text/css"
                    href="/exist/apps/cr-xq/modules/shared/scripts/style/cmds-ui.css" /&gt;&#xd;
                    &lt;/head&gt;&#xd; &lt;body&gt; &#xd; &lt;div id="header"&gt;&#xd; &lt;!--
                    &lt;ul id="menu"&gt; &#xd; &lt;li&gt;&lt;a
                    href="collectresults.xql"&gt;Results&lt;/a&gt;&lt;/li&gt;&#xd; &lt;/ul&gt;--&gt;
                    &#xd; &lt;h1&gt;cr-xq/aqay - autoquery/testing suite&lt;/h1&gt;&#xd; &lt;a
                    href="?operation=overview"&gt;overview&lt;/a&gt;&#xd; &lt;/div&gt;&#xd; &lt;!--
                    &lt;div&gt;{$config}&lt;/div&gt; --&gt;:) &#xd; return &lt;div
                    id="content"&gt;&#xd; {if (contains($action, 'overview')) then
                    fcs-tests:display-overview($config) else () }&#xd; &lt;form&gt;&#xd;
                    &lt;label&gt;targets&lt;/label&gt;&lt;select name="target"&gt;&#xd; {&#xd; for
                    $target-elem in fcs-tests:get-targets($config)&#xd; let $target-key :=
                    xs:string($target-elem/@key)&#xd; let $option := if ($target = $target-key)
                    then&#xd; &lt;option selected="selected" value="{$target-key}"
                    &gt;{$target-key}&lt;/option&gt;&#xd; else&#xd; &lt;option value="{$target-key}"
                    &gt;{$target-key } &lt;/option&gt;&#xd; return $option&#xd; }&#xd;
                    &lt;/select&gt;&#xd; &lt;label&gt;query-set&lt;/label&gt;&lt;select
                    name="queryset"&gt;&#xd; {&#xd; for $queryset-key in
                    fcs-tests:get-queryset-keys($config)&#xd; let $option := if ($queryset=
                    $queryset-key) then&#xd; &lt;option selected="selected" value="{$queryset-key}"
                    &gt;{$queryset-key}&lt;/option&gt;&#xd; else&#xd; &lt;option
                    value="{$queryset-key}" &gt;{$queryset-key}&lt;/option&gt;&#xd; return
                    $option&#xd; }&#xd; &lt;/select&gt;&#xd; &lt;label&gt;action&lt;/label&gt;&#xd;
                    &lt;select name="action"&gt;&#xd; &lt;option value="rest-queryset-run" &gt;{if
                    (contains($action, 'run') and not(contains($action, 'run-store'))) then
                    attribute selected { "selected" } else ()} run&lt;/option&gt;&#xd; &lt;option
                    value="rest-queryset-run-store" &gt;{if (contains($action, 'run-store')) then
                    attribute selected { "selected" } else ()} run-store&lt;/option&gt;&#xd;
                    &lt;option value="rest-queryset-view" &gt; {if (contains($action,'view')) then
                    attribute selected { "selected" } else ()} view&lt;/option&gt; &#xd;
                    &lt;/select&gt; &#xd; &lt;input type="submit" value="View/Run" /&gt;&#xd;
                    &lt;/form&gt;&#xd; &#xd; &lt;div
                    id="result"&gt;{$formatted-result}&lt;/div&gt;&#xd; &#xd; &lt;/div&gt; &#xd;
                    (:&lt;/body&gt;&#xd; &lt;/html&gt;:)&#xd; &#xd; };&#xd; &#xd; declare function
                    fcs-tests:display-overview($config) as item()* {&#xd; &#xd;
                    &lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;{for $target in
                    fcs-tests:get-targets($config) return
                    &lt;th&gt;{xs:string($target/@key)}&lt;/th&gt;}&lt;/tr&gt;&#xd; {for
                    $queryset-key in fcs-tests:get-queryset-keys($config)&#xd; return
                    &lt;tr&gt;&#xd; &lt;th&gt;{$queryset-key}&lt;/th&gt;&#xd; {for $target in
                    fcs-tests:get-targets($config)&#xd; let $target-key :=
                    $target/xs:string(@key)&#xd; let $test-result :=
                    fcs-tests:get-result($target-key , $queryset-key, $config) &#xd; let $root-elem
                    := $test-result/*/name()&#xd; let $op := if
                    ($test-result//diagnostic["result-unavailable" = xs:string(@key)]) then 'run'
                    else 'view'&#xd; (: display number of all and failed tests in the testset,
                    operates on the HTML produced during the test-run :)&#xd; let $view:= if
                    ($test-result//diagnostic["result-unavailable" = xs:string(@key)]) then ()&#xd;
                    else &#xd; let $show := if ($root-elem[1] eq 'testrun') then &#xd;
                    &lt;span&gt;&lt;span
                    class="test-passed"&gt;{count($test-result//div[@class='test'][.//span[@class='value
                    true']])}&lt;/span&gt;{"/"}&#xd; &lt;span
                    class="test-failed"&gt;{count($test-result//div[@class='test'][.//span[@class='value
                    false']])}&lt;/span&gt;{"/"} &#xd;
                    {count($test-result//div[@class='test'])}&#xd; {if
                    (exists($test-result//diagnostics)) then &lt;span
                    class="test-failed"&gt;!!&lt;/span&gt; else () }&#xd; &lt;/span&gt;&#xd; else
                    $root-elem &#xd; return &lt;a
                    href="?target={$target-key}&amp;amp;queryset={$queryset-key}&amp;amp;action=rest-queryset-view"
                    &gt;{$show}&lt;/a&gt; &#xd; let $run := if ($queryset-key =
                    $target/queryset/xs:string(@key)) then &#xd; ('[', &lt;a
                    href="?target={$target-key}&amp;amp;queryset={$queryset-key}&amp;amp;action=rest-queryset-run"
                    &gt;run&lt;/a&gt;, ']')&#xd; else () &#xd; return &lt;td
                    align="center"&gt;{($view, $run)} &lt;/td&gt;&#xd; }&#xd; &lt;/tr&gt;&#xd;
                    }&lt;/table&gt;&#xd; };&#xd; &#xd; (:~&#xd; old way of getting querysets =
                    explicitely stated in config: $config//queryset&#xd; &#xd; @param $target -
                    optionally only querysets for given target&#xd; :)&#xd; declare function
                    fcs-tests:get-querysets($config, $target) as element()* {&#xd; let $querysets :=
                    collection(repo-utils:config-value($config, "queryset.path"))//queryset&#xd;
                    return if ($target='') then $querysets &#xd; else $querysets[xs:string(@id) =
                    fcs-tests:get-targets($config, $target)/queryset/xs:string(@key)] &#xd; };&#xd;
                    &#xd; declare function fcs-tests:get-querysets($config) as element()* {&#xd;
                    fcs-tests:get-querysets($config, '')&#xd; };&#xd; &#xd; (:~ helper function to
                    list the queryset-keys&#xd; reading from queryset-dir :)&#xd; declare function
                    fcs-tests:get-queryset-keys($config) as xs:string* {&#xd;
                    fcs-tests:get-querysets($config)/xs:string(@id)&#xd; };&#xd; &#xd; declare
                    function fcs-tests:get-target-keys($config) as xs:string* {&#xd;
                    fcs-tests:get-targets($config)/xs:string(@key)&#xd; };&#xd; &#xd; declare
                    function fcs-tests:get-targets($config) as element()* {&#xd;
                    fcs-tests:get-targets($config, '') &#xd; };&#xd; &#xd; declare function
                    fcs-tests:get-targets($config, $target) as element()* {&#xd;
                    $config//target[$target='' or xs:string(@key)=$target]&#xd; };&#xd; &#xd; &#xd;
                    &#xd; (:~ helper function for substituting a string with values from a
                    substitution-element&#xd; ? should be probably moved to repo-utils&#xd; &#xd;
                    @param $string string with %-keys in it (eg: "My name is %name") &#xd; @param
                    $substset an element with attributes and subelements that will be used for
                    substitution (their name being use for matching the %-keys in the string&#xd;
                    (eg &lt;subst name="Homer" /&gt;)&#xd; @return the original string, with %-keys
                    replaced by values from the substitution element (if found, otherwise the %-key
                    stays unchanged)&#xd; (eg "My name is Homer") &#xd; :)&#xd; declare function
                    fcs-tests:subst($string as xs:string, $substset)&#xd; {&#xd; let $substkeys :=
                    for $substi in $substset/(*|@*) return&#xd; if (ends-with($substi/name(),'url'))
                    then concat('%', $substi/name()) &#xd; else (concat('%',
                    $substi/name()),concat('%_', $substi/name(), '_url')) &#xd; &#xd; &#xd; let
                    $substvalues := for $substi in $substset/(*|@*) return &#xd; if
                    (ends-with($substi/name(),'url')) then xmldb:encode(xs:string($substi)) &#xd;
                    else &#xd; (xs:string($substi), xmldb:encode(xs:string($substi)))&#xd; &#xd; (:
                    let $temp := replace($string, concat('%', $substkey), $substvalue) &#xd; return
                    if count($substset local:subst($temp, $substset/*[position() &gt; 1]) :)&#xd;
                    return repo-utils:replace-multi ($string, $substkeys, $substvalues)&#xd; &#xd;
                    };&#xd; </f>
            </d>
            <d n="cmd">
                <f n="cmd-check.xqm"> xquery version "1.0";&#xd; module namespace cmdcheck =
                    "http://clarin.eu/cmd/check";&#xd; (: checking (trying to ensure) consistency of
                    the IDs in CMD-records (MdSelfLink vs. ResourceProxies vs. IsPartOf)&#xd; &#xd;
                    TODO: check (and/or generate) the inverse links in IsPartOf (vs.
                    ResourceProxies)&#xd; :)&#xd; &#xd; (:import module namespace cmd =
                    "http://clarin.eu/cmd/collections" at "cmd-collections.xqm";:)&#xd; import
                    module namespace repo-utils = "http://aac.ac.at/content_repository/utils" at
                    "../../core/repo-utils.xqm";&#xd; import module namespace fcs =
                    "http://clarin.eu/fcs/1.0" at "../fcs/fcs.xqm";&#xd; import module namespace
                    crday = "http://aac.ac.at/content_repository/data-ay" at
                    "../aqay/crday.xqm";&#xd; import module namespace smc = "http://clarin.eu/smc"
                    at "../smc/smc.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "../diagnostics/diagnostics.xqm";&#xd; &#xd; declare namespace sru =
                    "http://www.loc.gov/zing/srw/";&#xd; declare namespace cmd =
                    "http://www.clarin.eu/cmd/";&#xd; &#xd; (:~ default namespace: cmd - declared
                    statically, because dynamic ns-declaration did not work &#xd; cmd is the default
                    namespace in (not) all the CMD records &#xd; :)&#xd; (:declare default element
                    namespace "http://www.clarin.eu/cmd/";:)&#xd; (:~ default namespace - not
                    declared explicitely, it is declared dynamically where necessary (function:
                    addIsPartOf() :) &#xd; declare variable $cmdcheck:default-ns :=
                    "http://www.clarin.eu/cmd/";&#xd; declare variable $cmdcheck:root-coll :=
                    "root";&#xd; &#xd; &#xd; (:~ runs cmd.profile-scan for all contexts defined in
                    the mappings :)&#xd; &#xd; declare function cmdcheck:run-stats($config-path as
                    xs:string) as item()* {&#xd; &#xd; let $config :=
                    repo-utils:config($config-path), &#xd; $mappings :=
                    doc(repo-utils:config-value($config, 'mappings'))&#xd; &#xd; let $opt :=
                    util:declare-option("exist:serialize", "media-type=text/html method=xhtml")&#xd;
                    &#xd; for $map in $mappings//map[@key]&#xd; let $map-key :=
                    $map/xs:string(@key),&#xd; $map-dbcoll-path := $map/xs:string(@path),&#xd;
                    $scan-cmd-profile := fcs:scan('cmd.profile', $map-key, 1, 50, 1, 1, "text", '',
                    $config) &#xd; return $scan-cmd-profile&#xd; };&#xd; &#xd; (:~&#xd; generate a
                    mapping out of the db-collection structure&#xd; combine it with manual
                    configuration (expects: mappings-manual.xml in projects-config-collections)&#xd;
                    and store it to conf&#xd; :)&#xd; declare function
                    cmdcheck:collection-to-mapping($config,$x-context as xs:string+ ) as item()*
                    {&#xd; &#xd; let $config-path := util:collection-name($config[1])&#xd; let
                    $context-path := repo-utils:context-to-collection-path($x-context, $config)&#xd;
                    &#xd; let $mappings-manual := doc(concat($config-path, '/mappings-manual.xml'))
                    &#xd; &#xd; let $maps := &lt;map&gt;{ ($mappings-manual/map/*,&#xd; for
                    $dataset-coll in xmldb:get-child-collections($context-path)&#xd; for
                    $provider-coll in
                    xmldb:get-child-collections(concat($context-path,'/',$dataset-coll))&#xd; return
                    &#xd; &lt;map key="{$provider-coll}" label="{translate($provider-coll,'_', '
                    ')}"
                    path="{concat($context-path,'/',$dataset-coll,'/',$provider-coll)}"/&gt;&#xd; )
                    }&lt;/map&gt;&#xd; &#xd; let $store := repo-utils:store($config-path ,
                    'mappings.xml', $maps, true(),$config) &#xd; return $store&#xd; };&#xd; &#xd;
                    &#xd; &#xd; (:~ currently not used -&gt; DEPRECATE? &#xd; init-function meant to
                    call individual functions actually doing something.&#xd; at least it resolves
                    x-context to a nodeset&#xd; :)&#xd; declare function cmdcheck:check($x-context
                    as xs:string+, $config ) as item()* {&#xd; &#xd; let $log-file-name :=
                    concat('log_checks_', repo-utils:sanitize-name($x-context), '.xml')&#xd; let
                    $log-path := repo-utils:config-value($config, 'log.path')&#xd; &#xd; let
                    $start-time := util:system-dateTime()&#xd; &#xd; let $stat-profiles :=
                    cmdcheck:scan-profiles($x-context, $config), &#xd; (: $check-linking :=
                    cmdcheck:check-linking($data-collection),:)&#xd; $duration :=
                    util:system-dateTime() - $start-time &#xd; &#xd; let $result-data := &lt;checks
                    context="{$x-context}" on="{$start-time}" duration="{$duration}" &gt;&#xd;
                    &lt;profiles&gt;{$stat-profiles}&lt;/profiles&gt;&#xd;
                    &lt;check-linking&gt;{$check-linking}&lt;/check-linking&gt;&#xd;
                    &lt;/checks&gt;&#xd; let $store := xmldb:store($log-path , $log-file-name,
                    $result-data) &#xd; return $store &#xd; };&#xd; &#xd; (:~ extracts CMD-Profiles
                    from given nodeset&#xd; expects the data to be in CMD format (especially
                    cmd-namespace)&#xd; generates a list of profile-ids&#xd; and matches each
                    against $smc:cmd-terms (-&gt; and diagnostics)&#xd; &#xd; special handling of
                    missing profile-ids&#xd; &#xd; REMOVED dynamic handling of namespaces, just scan
                    cmd-ns, otherwise got bad errors, when some not cmd-data was in given
                    db-collection&#xd; also REMOVED generating a list of profile-id#profile-name
                    pairs, as it was too expensive - and just for data-debugging (consistence
                    checks) purposes&#xd; &#xd; :)&#xd; declare function
                    cmdcheck:scan-profiles($x-context as xs:string, $config as node()*) as item()*
                    {&#xd; (: try- to handle namespace problem - primitively :) &#xd; &#xd; let
                    $context := repo-utils:context-to-collection($x-context, $config),&#xd; $ns-uri
                    := namespace-uri($context[1]/*) &#xd; &#xd; &#xd; let $profiles-summary := &#xd;
                    if (not(exists($context))) then&#xd; diag:diagnostics("general-error",
                    concat("scan-profiles: no context: ", $x-context))&#xd; else&#xd; &#xd; &#xd;
                    let $missing-profiles-records := $context//cmd:MdProfile[. =
                    '']/ancestor::cmd:CMD&#xd; let $missing-profiles-distinct-names :=
                    distinct-values($missing-profiles-records/cmd:Components/*/local-name())&#xd;
                    &#xd; let $missing-profiles := for $profile-name in
                    $missing-profiles-distinct-names&#xd; (: if ID missing try to fill up from
                    smc:cmd-terms :)&#xd; let $matching-cmd-profile :=
                    $smc:cmd-terms//Termset[xs:string(@name)=$profile-name and
                    @type="CMD_Profile"]&#xd; let $profile-id := if
                    (count($matching-cmd-profile)&gt;0) then $matching-cmd-profile[1]/xs:string(@id)
                    else $profile-name&#xd; let $cnt :=
                    count($missing-profiles-records/cmd:Components/*[local-name()=$profile-name]/ancestor::cmd:CMD)&#xd;
                    let $diag := concat($profile-name, ' - ',&#xd; "no matching
                    profile"[$matching-cmd-profile = ()],&#xd; concat("matched with profile:
                    ",$matching-cmd-profile[1]/xs:string(@id))[count($matching-cmd-profile)=1],&#xd;
                    concat("ambiguous match with profiles: ",
                    string-join($matching-cmd-profile/xs:string(@id),',
                    '))[count($matching-cmd-profile)&gt;1]&#xd; )&#xd; return &lt;sru:term&gt;&#xd;
                    &lt;sru:value&gt;{$profile-id}&lt;/sru:value&gt; &#xd;
                    &lt;sru:numberOfRecords&gt;{$cnt}&lt;/sru:numberOfRecords&gt;&#xd;
                    &lt;sru:displayTerm&gt;{$profile-name}&lt;/sru:displayTerm&gt;&#xd;
                    &lt;sru:extraTermData&gt;&#xd; { diag:diagnostics("profile-id-missing", $diag)
                    }&#xd; &lt;/sru:extraTermData&gt; &#xd; &lt;/sru:term&gt;&#xd; &#xd; let
                    $profile-ids := distinct-values($context//cmd:MdProfile)&#xd; &#xd; let
                    $profiles := for $profile-id in $profile-ids[. ne '']&#xd; let $records :=
                    $context//cmd:MdProfile[. = $profile-id]/ancestor::cmd:CMD&#xd; let
                    $profile-name := ($records)[1]/cmd:Components/*[1]/local-name()&#xd; let $cnt :=
                    count($records)&#xd; &#xd; let $matching-cmd-profile :=
                    $smc:cmd-terms//Termset[xs:string(@id)=$profile-id and @type="CMD_Profile"]&#xd;
                    (: check if the defined name of the profile matches with the base-component
                    element in the data (at least the first record we took as sample *sigh* :)&#xd;
                    let $profile-name-matching := ($profile-name =
                    $matching-cmd-profile/xs:string(@name))&#xd; &#xd; (: for debugging mainly, to
                    check if there are more base-components (cmd:Components/*) associated with one
                    id&#xd; but prohibitively slow for larger datasets - &#xd; let
                    $distinct-base-components :=
                    distinct-values($records/cmd:Components/*/local-name())&#xd; alternatively just
                    check, if there is another record with the same profile-id, but other local-name
                    - a bit less slow :)&#xd; (: let $other-base-comp:=
                    $records/cmd:Components/*[xs:string(local-name()) ne
                    $first-base-comp]/local-name(.):)&#xd; &#xd; return &lt;sru:term&gt;&#xd;
                    &lt;sru:value&gt;{$profile-id}&lt;/sru:value&gt; &#xd;
                    &lt;sru:numberOfRecords&gt;{$cnt}&lt;/sru:numberOfRecords&gt;&#xd;
                    &lt;sru:displayTerm&gt;{$profile-name}&lt;/sru:displayTerm&gt;&#xd; { if
                    ($matching-cmd-profile = () or not($profile-name-matching)) then&#xd;
                    &lt;sru:extraTermData&gt;&#xd; { (diag:diagnostics("profile-unknown",
                    $profile-id)[not(exists($matching-cmd-profile))] ,&#xd;
                    diag:diagnostics("profile-name-mismatch", &#xd; concat($profile-name, '!=',
                    $matching-cmd-profile/xs:string(@name)))[exists($matching-cmd-profile) and
                    not($profile-name-matching)]&#xd; )&#xd; }&#xd; &lt;/sru:extraTermData&gt;&#xd;
                    else ()&#xd; }&#xd; &lt;/sru:term&gt;&#xd; &#xd; return ($profiles,
                    $missing-profiles)&#xd; &#xd; let $count-all := count($profiles-summary) &#xd;
                    return&#xd; &lt;sru:scanResponse xmlns:sru="http://www.loc.gov/zing/srw/"
                    xmlns:fcs="http://clarin.eu/fcs/1.0"&gt;&#xd;
                    &lt;sru:version&gt;1.2&lt;/sru:version&gt; &#xd; &lt;sru:terms&gt; &#xd;
                    {$profiles-summary }&#xd; &lt;/sru:terms&gt;&#xd;
                    &lt;sru:extraResponseData&gt;&#xd;
                    &lt;fcs:countTerms&gt;{$count-all}&lt;/fcs:countTerms&gt;&#xd;
                    &lt;/sru:extraResponseData&gt;&#xd; &lt;sru:echoedScanRequest&gt; &#xd;
                    &lt;sru:scanClause&gt;cmd.profile&lt;/sru:scanClause&gt;&#xd;
                    &lt;/sru:echoedScanRequest&gt;&#xd; &lt;/sru:scanResponse&gt; &#xd; };&#xd;
                    &#xd; &#xd; declare function cmdcheck:display-overview($config) as item()*
                    {&#xd; &#xd; (:$config := repo-utils:config($config-path),:)&#xd; let &#xd;
                    $dummy := util:declare-namespace("",xs:anyURI("")),&#xd; $mappings :=
                    doc(repo-utils:config-value($config, 'mappings'))&#xd; (: $baseurl :=
                    repo-utils:config-value($config, 'base.url'),:)&#xd; &#xd; let $opt :=
                    util:declare-option("exist:serialize", "media-type=text/html method=xhtml")
                    &#xd; &#xd; (: let $overview := crday:display-overview($config-path,
                    'raw'):)&#xd; let $overview := "temporarily deactivated (not updated yet):
                    crday:display-overview($config-path, 'raw')"&#xd; &#xd; let $profiles-overview
                    := &lt;table
                    class="show"&gt;&lt;tr&gt;&lt;th&gt;collection&lt;/th&gt;&lt;th&gt;profiles&lt;/th&gt;&lt;/tr&gt;&#xd;
                    { for $map in util:eval("$mappings//map[@key]")&#xd; let $map-key :=
                    $map/xs:string(@key),&#xd; $map-dbcoll-path := $map/xs:string(@path),&#xd;
                    $scan-cmd-profile := fcs:scan('cmd.profile', $map-key, 1, 50, 1, 1, "text", '',
                    $config), &#xd; $scan-formatted := repo-utils:serialise-as( $scan-cmd-profile,
                    'htmldetail', 'scan', $config, ())&#xd; return &lt;tr&gt;&#xd;
                    &lt;td&gt;{$map-key}&lt;/td&gt;&#xd; &lt;td&gt;{ $scan-formatted
                    }&lt;/td&gt;&#xd; &lt;/tr&gt;&#xd; }&#xd; &lt;/table&gt;&#xd; (: { for $profile
                    in $scan-cmd-profile//sru:term &#xd; return ($profile/sru:value,
                    $profile/sru:displayTerm, $profile/sru:numberOfRecords)&#xd; }:)&#xd; &#xd;
                    return repo-utils:serialise-as( &lt;div&gt;{($overview,
                    $profiles-overview)}&lt;/div&gt;, 'htmlpage', 'html', $config, ())&#xd; &#xd;
                    };&#xd; &#xd; &#xd; &#xd; &#xd; (:~ WARNING - CHANGES DATA! adds IsPartOf to the
                    CMDrecords (contained in the db-coll)&#xd; - expects CMD-records for collections
                    in specific db-coll (with name of the db-coll matching the name of the
                    collectionfile):&#xd; ./_corpusstructure/collection_{db-coll-name}.cmdi&#xd; -
                    logs the progress of the processing in a separate file&#xd; - can be applied
                    repeatedly - deletes(!) old IsPartOfList, before inserting new&#xd; &#xd; @param
                    $x-context an identifier of a collection (as defined in mappings)&#xd; @param
                    $config config-node - used to get log.path and collection-path&#xd; &#xd; TODO:
                    could also generate the CMD-records for collections (assuming db-colls as
                    collections) &#xd; (now done by the python script: dir2cmdicollection.py)&#xd;
                    TODO: currently a hack: the collection-records also are marked as root elements
                    - this has to be optional at least, &#xd; and may even be dangerous
                    (count(IsPartOf[@level=1])&gt;1)!&#xd; TODO: not recursive yet!&#xd; :)&#xd;
                    declare function cmdcheck:addIsPartOf-colls($x-context as xs:string, $config as
                    node()*) as item()* {&#xd; &#xd; let $log-file-name :=
                    concat('log_addIsPartOf_', $x-context, '.xml')&#xd; let $log-path :=
                    repo-utils:config-value($config, 'log.path')&#xd; let $log-doc-path :=
                    xmldb:store($log-path , $log-file-name, &lt;result&gt;&lt;/result&gt;)&#xd; let
                    $log-doc := doc($log-doc-path)&#xd; &#xd; (:let $root-dbcoll :=
                    repo-utils:context-to-collection($x-context, $config),:)&#xd; let
                    $root-dbcoll-path := repo-utils:context-to-collection-path($x-context,
                    $config)&#xd; &#xd; let $coll-dbcoll := '_corpusstructure'&#xd; &#xd; (: beware
                    empty path!! would return first-level collections and run over whole database :)
                    &#xd; let $colls := if ($root-dbcoll-path ne "") then
                    xmldb:get-child-collections($root-dbcoll-path) else ()&#xd; let $start_time :=
                    fn:current-dateTime()&#xd; &#xd; (: dynamic ns-declaration does not work for
                    xpath &#xd; let $declare-dummy :=
                    util:declare-namespace("",xs:anyURI($cmdcheck:default-ns))&#xd; :)&#xd; let
                    $log-dummy := update insert &lt;edit x-context="{$x-context}"
                    root-dbcoll="{$root-dbcoll-path}" &#xd; coll-dbcoll="{$coll-dbcoll}"
                    count-colls="{count($colls)}" time="{$start_time}" /&gt; into
                    $log-doc/result&#xd; (:if (exists($colls)) then:)&#xd; for $coll_name in
                    $colls[not(.=$coll-dbcoll)]&#xd; (: let $coll_name := 'HomeFamilyManagement'
                    :)&#xd; let $files := collection(concat($root-dbcoll-path,$coll_name))&#xd; (:
                    let $files := xmldb:xcollection($root_coll) :) &#xd; let $coll_file :=
                    concat($root-dbcoll-path, $coll-dbcoll, '/collection_', $coll_name,
                    '.cmdi')&#xd; let $coll_doc := doc($coll_file)&#xd; let $coll_id :=
                    $coll_doc//MdSelfLink/text()&#xd; &#xd; (: let $cmdi_files :=
                    $files[ends-with(util:document-name(.),".cmdi")]:)&#xd; &#xd; let $pre_time :=
                    util:system-dateTime()&#xd; let $duration := $pre_time - $start_time&#xd; return
                    ( update insert &lt;edit coll="{$coll_name}" collid="{$coll_id}"
                    coll_file="{$coll_file}" count="{count($files)}" time="{$pre_time}" /&gt; into
                    $log-doc/result, &#xd; update delete $files//IsPartOfList,&#xd; update delete
                    $coll_doc//IsPartOfList,&#xd; update insert &lt;IsPartOfList&gt;&#xd;
                    &lt;IsPartOf level="1"&gt;{$x-context}&lt;/IsPartOf&gt;&#xd; &lt;IsPartOf
                    level="1"&gt;{$cmdcheck:root-coll}&lt;/IsPartOf&gt;&#xd;
                    &lt;/IsPartOfList&gt;&#xd; into $coll_doc//Resources,&#xd; update insert
                    &lt;IsPartOfList&gt;&#xd; &lt;IsPartOf
                    level="2"&gt;{$x-context}&lt;/IsPartOf&gt;&#xd; &lt;IsPartOf
                    level="1"&gt;{$coll_id}&lt;/IsPartOf&gt;&#xd; &lt;/IsPartOfList&gt; &#xd; into
                    $files//Resources,&#xd; update value $log-doc/result/edit[last()] with
                    (util:system-dateTime() - $pre_time)&#xd; )&#xd; (:&#xd; return ($coll_name,
                    count($cmdi_files), $coll_file, update insert &lt;IsPartOfList&gt;&#xd;
                    &lt;IsPartOf level="1"&gt;{$coll_id}&lt;/IsPartOf&gt;&#xd; &lt;/IsPartOfList&gt;
                    into $cmdi_files//Resources ):)&#xd; };&#xd; &#xd; (:~ recursive addIsPartOf
                    &#xd; starts by finding "orphaned" mdrecords = expecting that to be the root
                    records.&#xd; and continues ?&#xd; :)&#xd; declare function
                    cmdcheck:addIsPartOf($x-context as xs:string, $config as node()*) as item()*
                    {&#xd; &#xd; let $log-file-name := concat('log_addIsPartOf_', $x-context,
                    '.xml')&#xd; let $log-path := repo-utils:config-value($config, 'log.path')&#xd;
                    let $log-doc-path := xmldb:store($log-path , $log-file-name,
                    &lt;result&gt;&lt;/result&gt;)&#xd; let $log-doc := doc($log-doc-path)&#xd;
                    &#xd; let $root-dbcoll := repo-utils:context-to-collection($x-context,
                    $config),&#xd; $root-dbcoll-path :=
                    repo-utils:context-to-collection-path($x-context, $config)&#xd; &#xd; (: let
                    $coll-dbcoll := '_corpusstructure':)&#xd; &#xd; (: beware empty path!! would
                    return first-level collections and run over whole database :) &#xd; let $colls
                    := if ($root-dbcoll-path ne "") then
                    xmldb:get-child-collections($root-dbcoll-path) else ()&#xd; let $start_time :=
                    fn:current-dateTime()&#xd; &#xd; &#xd; let $log-dummy := update insert &lt;edit
                    x-context="{$x-context}" root-dbcoll="{$root-dbcoll-path}" &#xd;
                    count-colls="{count($colls)}" time="{$start_time}" /&gt; into
                    $log-doc/result&#xd; &#xd; let $root := cmdcheck:addIsPartOf-root($root-dbcoll,
                    $log-doc) &#xd; let $updated := cmdcheck:addIsPartOf-r($root-dbcoll, $root, 1,
                    $log-doc)&#xd; &#xd; return $log-doc&#xd; };&#xd; &#xd; (:~ consider those,
                    whose MdSelfLink isn't referenced anywhere (orphans) as the root-cmd-collections
                    &#xd; @returns the edited records :) &#xd; declare function
                    cmdcheck:addIsPartOf-root($context as node()*, $log-doc as node()*) as item()*
                    {&#xd; &#xd; let $pre_time := util:system-dateTime()&#xd; &#xd; let $orphaned :=
                    $context//CMD[not(Header/MdSelfLink = $context//ResourceProxy[ResourceType eq
                    'Metadata']/ResourceRef)]&#xd; &#xd; let $update := ( update insert &lt;edit
                    collid="root" count="{count($orphaned)}" time="{$pre_time}" /&gt; into
                    $log-doc/result, &#xd; update delete $orphaned//IsPartOfList,&#xd; update insert
                    &lt;IsPartOfList&gt;&#xd; &lt;IsPartOf&gt;{$cmdcheck:root-coll}&lt;/IsPartOf&gt;
                    &#xd; &lt;/IsPartOfList&gt; &#xd; into $orphaned//Resources, &#xd; update value
                    $log-doc/result/edit[last()] with (util:system-dateTime() - $pre_time)&#xd;
                    )&#xd; &#xd; return $orphaned&#xd; &#xd; };&#xd; &#xd; declare function
                    cmdcheck:addIsPartOf-r($context as node()*, $parents as node()*, $level as
                    xs:integer, $log-doc as node()*) as item()* {&#xd; &#xd; let $start_time :=
                    util:system-dateTime()&#xd; let $log-dummy := update insert &lt;edit
                    level="{$level}" &#xd; count-colls="{count($parents)}" time="{$start_time}"
                    /&gt; into $log-doc/result&#xd; &#xd; let $update := for $cmd-record in $parents
                    &#xd; let $parent-id := $cmd-record//MdSelfLink/text()&#xd; let $children :=
                    $context//CMD[Header/MdSelfLink = $cmd-record//ResourceRef] &#xd; let
                    $ispartoflist :=
                    &lt;IsPartOfList&gt;{($cmd-record//IsPartOfList/IsPartOf[not(text()=$cmdcheck:root-coll)],&#xd;
                    &lt;IsPartOf &gt;{$parent-id}&lt;/IsPartOf&gt;) } &#xd; &lt;/IsPartOfList&gt;
                    &#xd; &#xd; let $pre_time := util:system-dateTime()&#xd; let $duration :=
                    $pre_time - $start_time&#xd; return ( update insert &lt;edit
                    collid="{$parent-id}" count="{count($children)}" time="{$pre_time}" /&gt; into
                    $log-doc/result, &#xd; update delete $children//IsPartOfList,&#xd; update insert
                    $ispartoflist &#xd; into $children//Resources, &#xd; update value
                    $log-doc/result/edit[last()] with (util:system-dateTime() - $pre_time)&#xd;
                    )&#xd; &#xd; (: go next level - we dont have to recurse in the update-loop,
                    &#xd; but we can do whole next level in one call :)&#xd; let $next-level :=
                    $context//CMD[Header/MdSelfLink = $parents//ResourceRef]&#xd; let $updated := if
                    (exists($next-level)) then cmdcheck:addIsPartOf-r($context, $next-level
                    ,($level+1),$log-doc)&#xd; else ()&#xd; return $update &#xd; };&#xd; &#xd; </f>
                <f n="cmdi.xqm">xquery version "3.0"; module namespace cmdi =
                    "http://www.clarin.eu/cmd/"; declare variable $cmdi:profiles :=
                    doc("profiles.xml"); declare function cmdi:profile-id-to-name($profile-id as
                    xs:string) as xs:string { $cmdi:profiles//profile[@id =
                    $profile-id]/xs:string(@name) }; declare function cmdi:name-to-profile-id($name
                    as xs:string) as xs:string { $cmdi:profiles//profile[@name =
                    $name]/xs:string(@id) };</f>
            </d>
            <d n="cqlparser">
                <f n="cql.xql">xquery version "1.0";&#xd; &#xd; import module namespace cql =
                    "http://exist-db.org/xquery/cql" at
                    "/db/cr/modules/cqlparser/cqlparser.xqm";&#xd; import module namespace
                    request="http://exist-db.org/xquery/request";&#xd; &#xd; let $cql :=
                    request:get-parameter("cql", "title any Wien and date &lt; 1950")&#xd; return
                    (cql:cql-to-xcql($cql))</f>
                <f n="cqlparser.xqm">xquery version "3.0";&#xd; (:~ This module provides methods to
                    transform CQL query to XPath &#xd; : @see http://clarin.eu/fcs &#xd; : @author
                    Matej Durco&#xd; : @since 2012-03-01&#xd; : @version 1.1 &#xd; :)&#xd; module
                    namespace cql = "http://exist-db.org/xquery/cql";&#xd; &#xd; import module
                    namespace cqlparser = "http://exist-db.org/xquery/cqlparser";&#xd; import module
                    namespace repo-utils = "http://aac.ac.at/content_repository/utils" at
                    "/db/cr/repo-utils.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "/db/cr/modules/diagnostics/diagnostics.xqm";&#xd; &#xd; (:declare variable
                    $cql:transform-doc := doc("XCQL2Xpath.xsl");:)&#xd; declare variable
                    $cql:transform-doc :=
                    doc(concat(system:get-module-load-path(),"/XCQL2Xpath.xsl"));&#xd; declare
                    variable $cql:log := util:log("INFO",$cql:transform-doc);&#xd; (:~ use the
                    extension module CQLParser (using cql-java library)&#xd; to parse the expression
                    and return the xml version of the parse-tree&#xd; or a diagnostic, on parsing
                    error&#xd; :)&#xd; declare function cql:cql-to-xcql($cql-expression as
                    xs:string) {&#xd; try {&#xd; (: util:parse(cqlparser:parse-cql($cql-expression,
                    "XCQL")) :)&#xd; cqlparser:parse-cql($cql-expression, "XCQL")&#xd; }&#xd; catch
                    err:XPTY0004 &#xd; {&#xd; diag:diagnostics("query-syntax-error", ($err:code ,
                    $err:description, $err:value))&#xd; } &#xd; catch *&#xd; { &#xd;
                    diag:diagnostics("query-syntax-error", $cql-expression)&#xd; }&#xd; };&#xd;
                    &#xd; (:~ translate a query in CQL-syntax to a corresponding XPath &#xd; :
                    &lt;ol&gt;&#xd; : &lt;li&gt;1. parsing into XCQL (XML-representation of the
                    parsed query&lt;/li&gt;&#xd; : &lt;li&gt;2. and transform via
                    XCQL2Xpath.xsl-stylesheet&lt;/li&gt;&#xd; : &lt;/ol&gt;&#xd; : @returns
                    xpath-string, or if not a string, whatever came from the parsing (if not a
                    string, it must be a diagnostic) &#xd; :)&#xd; declare function
                    cql:cql2xpath($cql-expression as xs:string, $x-context as xs:string) as item()
                    {&#xd; let $xcql := cql:cql-to-xcql($cql-expression)&#xd; (: return
                    transform:transform ($xcql, $cql:transform-doc, &lt;parameters&gt;&lt;param
                    name="mappings-file" value="{repo-utils:config-value('mappings')}"
                    /&gt;&lt;/parameters&gt;):)&#xd; return &#xd; if (not($xcql instance of
                    element(diagnostics))) &#xd; then&#xd; let
                    $parameters:=&lt;parameters&gt;&lt;param name="x-context" value="{$x-context}"
                    /&gt;&lt;/parameters&gt;&#xd; return transform:transform ($xcql,
                    $cql:transform-doc, $parameters)&#xd; else $xcql&#xd; };&#xd; &#xd; (:~ a
                    version that accepts mappings-element(s) as param&#xd; :)&#xd; declare function
                    cql:cql2xpath($cql-expression as xs:string, $x-context as xs:string, $mappings
                    as element(map)*) as item() {&#xd; let $xcql := if (exists($mappings)) &#xd;
                    then cql:cql-to-xcql($cql-expression)&#xd; else
                    diag:diagnostics("mappings-missing", $mappings)&#xd; return &#xd; if ($xcql[1]
                    instance of element(diagnostics))&#xd; then $xcql&#xd; else &#xd; let $input:=
                    &lt;wrapper&gt;&#xd; &lt;query&gt;{$xcql}&lt;/query&gt;&#xd;
                    &lt;mappings&gt;{$mappings}&lt;/mappings&gt;&#xd; &lt;/wrapper&gt; &#xd; let
                    $parameters:= &lt;parameters&gt;&#xd; &lt;param name="x-context"
                    value="{$x-context}"/&gt;&#xd; &lt;/parameters&gt; &#xd; return
                    transform:transform($input, $cql:transform-doc,$parameters)&#xd; };&#xd; &#xd;
                    declare function cql:xcql2xpath ($xcql as node(), $x-context as xs:string) as
                    xs:string {&#xd; &#xd; (: return transform:transform ($xcql, $cql:transform-doc,
                    &lt;parameters&gt;&lt;param name="mappings-file"
                    value="{repo-utils:config-value('mappings')}" /&gt;&lt;/parameters&gt;):) &#xd;
                    transform:transform ($xcql, $cql:transform-doc, &lt;parameters&gt;&lt;param
                    name="x-context" value="{$x-context}" /&gt;&lt;/parameters&gt; )&#xd; &#xd;
                    };&#xd; &#xd; </f>
            </d>
            <d n="cs-xsl">
                <d n="dataset"/>
                <d n="fcs"/>
                <d n="md"/>
                <d n="misc"/>
            </d>
            <d n="cs-xsl-local"/>
            <d n="diagnostics">
                <f n="diagnostics.xqm">xquery version "3.0";&#xd; module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/";&#xd; &#xd; &#xd; declare namespace
                    sru = "http://www.loc.gov/zing/srw/";&#xd; &#xd; &#xd; declare variable
                    $diag:msgs := doc('diagnostics.xml');&#xd; &#xd; declare function
                    diag:diagnostics($key as xs:string, $param as xs:string*) as item()? {&#xd;
                    &#xd; let $diag := &#xd; if (exists($diag:msgs//diag:diagnostic[@key=$key]))
                    then&#xd; $diag:msgs//diag:diagnostic[@key=$key]&#xd; else
                    $diag:msgs//diag:diagnostic[@key='general-error']&#xd; return&#xd;
                    &lt;diagnostics&gt;&#xd; { if (exists($diag)) then
                    util:eval(util:serialize($diag,())) else () }&#xd; &lt;/diagnostics&gt; &#xd;
                    };</f>
            </d>
            <d n="facsviewer">
                <f n="extract-pages.xql">xquery version "3.0";&#xd; &#xd; import module namespace
                    facs="http://www.oeaw.ac.at/icltt/cr-xq/facsviewer" at "facsviewer.xqm";&#xd;
                    (:import module namespace jobs="http://www.oeaw.ac.at/icltt/cr-xq/jobs" at
                    "../jobs/jobs.xqm";:)&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "../diagnostics/diagnostics.xqm";&#xd; &#xd; (: extracts pages from a TEI doc
                    (ie. chunks between tei:pb tags) and saves them into a new TEI file :)&#xd;
                    &#xd; &#xd; let $doc-uri := request:get-parameter('doc-uri',''),&#xd; $page-elt
                    := request:get-parameter('page-element',''),&#xd; $page-elt-ns :=
                    request:get-parameter('page-element-namespace',''),&#xd; $page-elt-attr :=
                    request:get-parameter('page-element-attributes','')&#xd; &#xd; (:let $pid:=
                    request:get-parameter('pid',''),&#xd; $pid-file:=
                    jobs:pid-file-by-doc-uri($doc-uri):)&#xd; &#xd; &#xd; return &#xd; if ($doc-uri
                    eq '')&#xd; then diag:diagnostics('param-missing','doc-uri')&#xd; else&#xd; (:
                    if ($pid-file/pid eq $pid):)&#xd; (: then :)&#xd; if ($page-elt != '')&#xd; then
                    facs:create-scratchfile($doc-uri)&#xd; else
                    facs:create-scratchfile($doc-uri,$page-elt,$page-elt-ns,$page-elt-attr) &#xd; (:
                    else ():)</f>
                <f n="facsviewer.xql">xquery version "3.0";&#xd; &#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace facs="http://www.oeaw.ac.at/icltt/cr-xq/facsviewer" at
                    "facsviewer.xqm";&#xd; &#xd; (: handles requests to facsimile files :)&#xd;
                    &#xd; let $filename := request:get-parameter("exist-resource","")&#xd; let
                    $project := request:get-parameter("project","")&#xd; let $config := map {
                    "config" := config:config($project)}&#xd; &#xd; &#xd; let
                    $file-path:=facs:filename-to-path($filename,$project,$config) &#xd; &#xd; &#xd;
                    return response:redirect-to($file-path)&#xd; &#xd; &#xd; </f>
                <f n="facsviewer.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                    facs="http://www.oeaw.ac.at/icltt/cr-xq/facsviewer";&#xd; import module
                    namespace config="http://exist-db.org/xquery/apps/config" at
                    "../../core/config.xqm";&#xd; import module namespace
                    config-params="http://exist-db.org/xquery/apps/config-params" at
                    "../../core/config.xql";&#xd; import module namespace repo-utils =
                    "http://aac.ac.at/content_repository/utils" at "../../core/repo-utils.xqm";
                    &#xd; declare namespace exist="http://exist.sourceforge.net/NS/exist";&#xd;
                    declare namespace tei="http://www.tei-c.org/ns/1.0";&#xd; import module
                    namespace kwic="http://exist-db.org/xquery/kwic";&#xd; import module namespace
                    ngram="http://exist-db.org/xquery/ngram";&#xd; import module namespace fcs =
                    "http://clarin.eu/fcs/1.0" at "../fcs/fcs.xqm";&#xd; &#xd; &#xd; (: moved to
                    fcs.xqm :)&#xd; (:declare function facs:add-exist-match($match as node()) {&#xd;
                    let $ancestor-with-id:= $match/ancestor-or-self::*[@xml:id][1]&#xd; return if
                    (exists($ancestor-with-id)) &#xd; then facs:add-exist-match($ancestor-with-id,
                    $match)&#xd; else $match&#xd; };&#xd; &#xd; declare function
                    facs:add-exist-match($ancestor as node(), $match as node()) {&#xd; typeswitch
                    ($ancestor)&#xd; case element() return element {name($ancestor)} {&#xd;
                    $ancestor/@*,&#xd; if ((some $x in $ancestor/@* satisfies $x is $match) or
                    $ancestor is $match)&#xd; then &lt;exist:match&gt;{$ancestor/node() except
                    $ancestor/@*}&lt;/exist:match&gt; &#xd; else for $i in $ancestor/node() except
                    $ancestor/@* &#xd; return facs:add-exist-match($i, $match)&#xd; }&#xd; case
                    text() return $ancestor&#xd; default return $ancestor&#xd; };:)&#xd; &#xd;
                    declare function facs:filename-to-path($filename as xs:string, $x-context){&#xd;
                    let $config:=config:config($x-context)&#xd; return
                    facs:filename-to-path($filename, $x-context, map{"config":=$config})&#xd;
                    };&#xd; &#xd; &#xd; declare function facs:filename-to-path($filename as
                    xs:string, $x-context, $config){&#xd; let $facs-path:= config:param-value((),
                    $config, 'facsviewer', '', "facs.path"),&#xd; $facs-prefix:= if
                    (config:param-value($config, "facs.prefix")) then config:param-value($config,
                    "facs.prefix") else '',&#xd; $facs-suffix:= if (config:param-value($config,
                    "facs.suffix")) then config:param-value($config, "facs.suffix") else ''&#xd;
                    return&#xd; concat(&#xd; (if
                    (not(matches($facs-path,concat($x-context,'/?$'))))&#xd; then
                    $facs-path||$x-context||'/'&#xd; else (if (ends-with($facs-path,'/')) then
                    $facs-path else $facs-path||'/')),&#xd; $facs-prefix,$filename,$facs-suffix&#xd;
                    )&#xd; };&#xd; &#xd; &#xd; &#xd; declare function
                    facs:doc-uri-to-project-id($uri as xs:anyURI) as xs:string? {&#xd; if
                    ($uri!='/.')&#xd; then &#xd; let $path:=util:collection-name($uri||".") (: dot
                    needed to get to the innermost collection, otherwise
                    collection-name("/db/collection") wil return /db instead of /db/collection
                    :)&#xd; let
                    $project-dirs:=collection($config-params:projects-dir)//param[@key='data-dir']&#xd;
                    let $log:=if(empty($project-dirs)) then util:log("INFO","$project-dirs is
                    empty") else ()&#xd; return &#xd; if ($project-dirs!replace(.,'/$','') = $path)
                    &#xd; then&#xd; let $project-id:=$project-dirs[replace(.,'/$','') = $path]
                    /ancestor::config//param[@key='project-id']&#xd; return &#xd; if ($project-id
                    !='' and config:project-exists($project-id))&#xd; then
                    ($project-id,util:log("INFO","$project-id: "||$project-id))&#xd; else ()&#xd;
                    else
                    (facs:doc-uri-to-project-id(xs:anyURI(replace($path,'/[^/.]*?$','')||"/.")))&#xd;
                    else ()&#xd; };&#xd; &#xd; declare function facs:innerContent($input as node())
                    as node() {&#xd; let $content:= typeswitch ($input)&#xd; case attribute() return
                    $input&#xd; case text() return $input&#xd; case document-node() return
                    $input/*&#xd; case element(TEI) return $input/text&#xd; default return
                    $input/*&#xd; return switch (count($content))&#xd; case 0 return $input&#xd;
                    case 1 return facs:innerContent($content) &#xd; default return $input&#xd;
                    };&#xd; &#xd; declare function facs:create-scratchfile($doc-uri) {&#xd; let
                    $facs:page-element:="div",&#xd;
                    $facs:page-element-namespace:="http://www.tei-c.org/ns/1.0",&#xd;
                    $facs:page-element-attributes:="type='page' n='{pos}'"&#xd; return
                    facs:create-scratchfile($doc-uri,$facs:page-element,$facs:page-element-namespace,$facs:page-element-attributes)&#xd;
                    };&#xd; &#xd; declare function facs:create-scratchfile($doc-uri,
                    $facs:page-element, $facs:page-element-namespace, $facs:page-element-attributes)
                    {&#xd; (: TODO read from config :)&#xd; let $doc-filename:=
                    replace($doc-uri,'/.*/','')&#xd; let $project:=
                    facs:doc-uri-to-project-id($doc-uri)&#xd; let $config:= if
                    (config:project-exists($project)) &#xd; then map {"config" :=
                    config:project-config($project)} &#xd; else ()&#xd; let $data-dir:=
                    config:param-value($config,"data-dir")&#xd; let
                    $pages-project-dir:=config:param-value($config,"pages-dir")&#xd; let
                    $data-dir-to-pages-dir:=replace($pages-project-dir,$data-dir,'')&#xd; let
                    $scratchfile-filename:="pages-"||$doc-filename&#xd; &#xd; let $doc:= if
                    (doc-available($doc-uri))&#xd; then doc($doc-uri)&#xd; else util:log("INFO",
                    "document "||$doc-uri||" not available")&#xd; &#xd; let
                    $create-pages-project-dir:= if
                    (xmldb:collection-available($pages-project-dir))&#xd; then ()&#xd; else
                    xmldb:create-collection($data-dir,$data-dir-to-pages-dir)&#xd; let $t1:=
                    current-time()&#xd; let $pages:= if (exists($doc) and
                    config:project-exists($project))&#xd; then &#xd; for $pb at $pos in
                    ($doc//pb|$doc//tei:pb)&#xd; let $page-id:= let $orig-id:= switch(true())&#xd;
                    case exists($pb/@xml:id)return $pb/@xml:id&#xd; case exists($pb/@facs) return
                    $pb/@facs&#xd; default return fn:format-number($pos,'000000')&#xd; return
                    "page_"||$orig-id&#xd; let $next:=
                    ($pb/following::tei:pb|$pb/following::pb)[1]&#xd; let $log:= util:log("INFO",
                    "start processing "||$page-id)&#xd; let $content:= util:parse(&#xd;
                    util:get-fragment-between($pb,$next,true(),true())&#xd; )&#xd; (:let
                    $innerContent:=facs:innerContent($content)&#xd; return &lt;div type="page"
                    xml:id="{$page-id}"&gt;{$innerContent}&lt;/div&gt;:)&#xd; return &#xd; element
                    {QName($facs:page-element-namespace,$facs:page-element)} {&#xd; if
                    ($facs:page-element-attributes != '')&#xd; then &#xd; for $attr in
                    tokenize($facs:page-element-attributes, '\s+')&#xd; let
                    $name:=substring-before($attr,'='),&#xd;
                    $value:=replace(substring-after($attr,'='),'(^["'']|["'']$)','')&#xd; return
                    attribute {$name} {&#xd; switch ($value)&#xd; case '{pos}' return
                    xs:string($pos)&#xd; default return xs:string($value)&#xd; }&#xd; else (),&#xd;
                    attribute xml:id {$page-id},&#xd; $content&#xd; }&#xd; else ()&#xd; let $t2:=
                    current-time() &#xd; let $scratchfile-content:= &lt;TEI
                    xmlns="http://www.tei-c.org/ns/1.0"&gt;&#xd; &lt;teiHeader&gt;&#xd;
                    &lt;fileDesc&gt;&#xd; &lt;titleStmt&gt;&#xd; &lt;title&gt;Pages from
                    {$doc-filename}&lt;/title&gt;&#xd; &lt;/titleStmt&gt;&#xd;
                    &lt;publicationStmt&gt;&#xd; &lt;p&gt;Publication Information&lt;/p&gt;&#xd;
                    &lt;/publicationStmt&gt;&#xd; &lt;sourceDesc&gt;&#xd; &lt;p&gt;Automatically
                    generated by exist:get-fragment-between()&lt;/p&gt;&#xd;
                    &lt;/sourceDesc&gt;&#xd; &lt;revisionDesc&gt;&#xd; &lt;change type="created"
                    when="{current-dateTime()}" who="{xmldb:get-current-user()}"/&gt;&#xd;
                    &lt;/revisionDesc&gt;&#xd; &lt;/fileDesc&gt;&#xd; &lt;/teiHeader&gt;&#xd;
                    &lt;text&gt;&#xd; &lt;body&gt;{$pages}&lt;/body&gt;&#xd; &lt;/text&gt;&#xd;
                    &lt;/TEI&gt;&#xd; &#xd; return &#xd; if (exists($doc) and
                    config:project-exists($project)) &#xd; then &#xd; let
                    $log:=util:log("INFO","created a scratchfile "||$scratchfile-filename),&#xd;
                    $log:=util:log("INFO","writing it to "||$pages-project-dir)&#xd; let
                    $store:=xmldb:store($pages-project-dir,$scratchfile-filename,$scratchfile-content)&#xd;
                    let $reindex:=xmldb:reindex($pages-project-dir)&#xd; (: let
                    $log:=util:log("INFO","reindexing "||$pages-project-dir):)&#xd; return ()&#xd;
                    else ()&#xd; };</f>
            </d>
            <d n="fcs">
                <f n="debug-fcs.xql">xquery version "3.0";&#xd; &#xd; (:~ This is a simple XQuery
                    script for debugging purposes which assembles the various steps of the fcs
                    module to produce results to a query. ~:)&#xd; &#xd; import module namespace fcs
                    = "http://clarin.eu/fcs/1.0" at
                    "/db/apps/cr-xq-dev0913/modules/fcs/fcs.xqm";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at
                    "/db/apps/cr-xq-dev0913/core/config.xqm";&#xd; import module namespace
                    repo-utils = "http://aac.ac.at/content_repository/utils" at
                    "/db/apps/cr-xq-dev0913/core/repo-utils.xqm";&#xd; import module namespace cql =
                    "http://exist-db.org/xquery/cql" at
                    "/db/apps/cr-xq-dev0913/modules/cqlparser/cqlparser.xqm";&#xd; &#xd; declare
                    namespace tei="http://www.tei-c.org/ns/1.0";&#xd; declare namespace
                    mets="http://www.loc.gov/METS/";&#xd; &#xd; (:~ These variables represent user
                    parameters received by the fcs module. ~:)&#xd; let $query:="Haus",&#xd;
                    $index:='',&#xd; $x-context:="abacus",&#xd; $startRecord:=1,&#xd;
                    $maximumRecords:=15,&#xd; $x-dataview:="kwic",&#xd;
                    $config:=config:project-config($x-context)&#xd; &#xd; let
                    $project-config-map:=map{"config":=$config}&#xd; let $relPath :=
                    "modules/shared/scripts/js/query_input/CQLConfig.js"&#xd; &#xd; (:let
                    $data-collection := repo-utils:context-to-collection($x-context, $config):)&#xd;
                    let $xpath-query := fcs:transform-query ($query, $x-context, $config,
                    true())&#xd; (:let $results := if ($xpath-query instance of text() or
                    $xpath-query instance of xs:string) then:)&#xd; (:
                    util:eval(concat("$data-collection",translate($xpath-query,'&amp;amp;','?'))):)&#xd;
                    (: else ():)&#xd; (: :)&#xd; (:let $index:="resource-pid":)&#xd; (:return for
                    $data in $results return:)&#xd; (: let $index-map :=
                    fcs:get-mapping($index,$x-context, $config),:)&#xd; (: $index-xpath :=
                    fcs:index-as-xpath($index,$x-context, $config):)&#xd; (: return
                    fcs:apply-index($data,$index,$x-context,$config):)&#xd; &#xd; (:return
                    fcs:get-mapping('resourcefragment-pid',$x-context,config:config($x-context)):)&#xd;
                    (:return
                    fcs:index-as-xpath('resourcefragment-pid',$x-context,config:config($x-context)):)&#xd;
                    (:return
                    $config//mets:techMD[@ID='crProjectMappings']/mets:mdWrap/mets:xmlData/map:)&#xd;
                    let $dataset:=repo-utils:resources-by-project($x-context)&#xd; &#xd; (:let
                    $import:=fcs:import-project-index-functions($x-context):)&#xd; (:let $data:=for
                    $d in $dataset return doc($d):)&#xd; (:return :)&#xd; (: for $d in $data
                    return:)&#xd; (: fcs:apply-index($d, 'title', $x-context, $config):)&#xd; &#xd;
                    return cql:cql2xpath($query, $x-context, config:mappings($x-context))&#xd; &#xd;
                    (:let $mappings := config:param-value(map{"config":=$config},"mappings"):)&#xd;
                    (:return:)&#xd; (: for $index in $mappings//index :)&#xd; (: return
                    fcs:index-as-xpath($index/@key,$x-context,$config):)&#xd; (:(:return
                    config:project-config($x-context):):)</f>
                <f n="fcs-sade.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                    fcs="http://sade/fcs";&#xd; &#xd; import module namespace
                    templates="http://exist-db.org/xquery/templates" at "templates.xql";&#xd; import
                    module namespace kwic="http://exist-db.org/xquery/kwic"&#xd; at
                    "resource:org/exist/xquery/lib/kwic.xql";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace fcsm =
                    "http://clarin.eu/fcs/1.0" at "fcs.xqm";&#xd; &#xd; declare namespace cmd =
                    "http://www.clarin.eu/cmd/";&#xd; &#xd; (:declare variable $app:SESSION :=
                    "shakespeare:results";:)&#xd; (:declare variable $fcs:config :=
                    repo-utils:config("/db/cr/conf/mdrepo/config.xml");:)&#xd; &#xd; (:~ deliver a
                    query-input "widget" (especially with a selector of fcs-resources&#xd; :)&#xd;
                    (:%templates:default("x-dataview","kwic")&#xd;
                    %templates:default("x-format","html"):)&#xd; declare &#xd; %templates:wrap&#xd;
                    %templates:default("x-format","html")&#xd; %templates:default("x-context","")
                    &#xd; function fcs:query-input($node as node()*, $model as map(*), $query as
                    xs:string?, $x-context as xs:string*, $x-dataview as xs:string*, $x-format as
                    xs:string?, $base-path as xs:string?) {&#xd; &#xd; let $template := &lt;a
                    href="query-input" class="template" /&gt; &#xd; let $params :=
                    &lt;parameters&gt;&lt;param name="format" value="{$x-format}"/&gt;&#xd;
                    config:param-value($model, 'project-static-dir')&#xd; &lt;param name="base_url"
                    value="{config:param-value($model,'base-url')}"/&gt; &#xd; &lt;param name="q"
                    value="{$query}"/&gt;&#xd; &lt;param name="x-context" value="{$x-context}"/&gt;
                    &#xd; &lt;param name="x-dataview" value="{$x-dataview}"/&gt;&#xd;
                    &lt;/parameters&gt;&#xd; (:&lt;param name="base_url"
                    value="{$base-path}"/&gt;&#xd; &lt;param name="base_url"
                    value="{repo-utils:base-url($model("config"))}"/&gt;:)&#xd; &#xd; return
                    repo-utils:serialise-as($template, $x-format, 'static', $model("config"),
                    $params)&#xd; &#xd; };&#xd; &#xd; &#xd; &#xd; (:~ invokes the search-retrieve
                    function of the fcs-module&#xd; tries to use x-context and x-dataview parameter
                    from the configuration, if no explicit x-context was given&#xd; :)&#xd; declare
                    &#xd; %templates:wrap&#xd; %templates:default("x-context","")&#xd;
                    %templates:default("x-dataview","title,kwic")&#xd;
                    %templates:default("startRecord",1)&#xd;
                    %templates:default("maximumRecords",10)&#xd;
                    %templates:default("x-format","html") &#xd; function fcs:query($node as node()*,
                    $model as map(*), $query as xs:string?, $x-context as xs:string*, $x-dataview as
                    xs:string*, $x-format as xs:string?, $startRecord as xs:integer, $maximumRecords
                    as xs:integer, $base-path as xs:string?) {&#xd; session:create(),&#xd; (: let
                    $hits := app:do-query($query, $mode):) &#xd; (: let $store :=
                    session:set-attribute($app:SESSION, $hits):)&#xd; &#xd; let $x-context-x := if
                    ($x-context='') then config:param-value($node, $model,'fcs','','x-context') else
                    $x-context&#xd; let $x-dataview-x := if ($x-dataview='') then
                    config:param-value($node, $model,'fcs','','x-dataview') else $x-dataview&#xd;
                    &#xd; let $base-path-x := if ($base-path='') then
                    config:param-value($model,'base-url') else $base-path&#xd; &#xd; (: hardcoded
                    sorting - needs to be optional (currently only used in STB :)&#xd; (:let
                    $cql-query := if (contains($query, 'sortBy')) then $query else concat ($query, "
                    sortBy sort"):)&#xd; let $cql-query := $query &#xd; let $result := &#xd; (:
                    fcs:search-retrieve($query, $x-context, xs:integer($start-item),
                    xs:integer($max-items), $x-dataview, $config):)&#xd;
                    fcsm:search-retrieve($cql-query, $x-context-x, $startRecord , $maximumRecords,
                    $x-dataview-x, $model("config"))&#xd; let $params := &lt;parameters&gt;&lt;param
                    name="format" value="{$x-format}"/&gt;&#xd; &lt;param name="base_url"
                    value="{config:param-value($model,'base-url')}"/&gt;&#xd; &lt;param
                    name="x-context" value="{$x-context-x}"/&gt; &#xd; &lt;param name="x-dataview"
                    value="{$x-dataview-x}"/&gt;&#xd; &lt;/parameters&gt;&#xd; (:&lt;param
                    name="base_url" value="{repo-utils:base-url($config)}"/&gt;:)&#xd; &#xd; return
                    repo-utils:serialise-as($result, $x-format, 'searchRetrieve', $model("config"),
                    $params)&#xd; &#xd; };&#xd; &#xd; &#xd; (:~ invokes the scan-function of the
                    fcs-module&#xd; tries to use x-context parameter from the configuration, if no
                    explicit x-context was given&#xd; :)&#xd; &#xd; declare &#xd;
                    %templates:wrap&#xd; %templates:default("x-context","")&#xd;
                    %templates:default("x-format","html")&#xd;
                    %templates:default("start-term",1)&#xd; %templates:default("max-terms",50)&#xd;
                    %templates:default("sort","size")&#xd; function fcs:scan($node as node()*,
                    $model as map(*), $scanClause as xs:string, $start-term as xs:integer,
                    $max-terms as xs:integer, $sort as xs:string, &#xd; $x-context as xs:string*,
                    $x-format as xs:string?, $base-path as xs:string?) {&#xd; &#xd; let $x-context-x
                    := if ($x-context='') then config:param-value($node,
                    $model,'fcs','','x-context') else $x-context&#xd; let $base-path-x := if
                    ($base-path='') then config:param-value($model,'base-url') else $base-path&#xd;
                    &#xd; let $result :=&#xd; fcsm:scan($scanClause, $x-context-x, $start-term,
                    $max-terms, 1, 1, $sort, '', $model("config"))&#xd; &#xd; let $params :=
                    &lt;parameters&gt;&lt;param name="format" value="{$x-format}"/&gt;&#xd;
                    &lt;param name="base_url"
                    value="{concat(config:param-value($model,'base-url'),'fcs')}"/&gt;&#xd;
                    &lt;param name="sort" value="{$sort}"/&gt;&#xd; &lt;param name="x-context"
                    value="{$x-context-x}"/&gt; &#xd; &#xd; &lt;/parameters&gt;&#xd; return
                    repo-utils:serialise-as($result, $x-format, 'scan', $model("config"),
                    $params)&#xd; &#xd; };&#xd; &#xd; &#xd; &#xd; (:~ return number of documents in
                    the data.path collection&#xd; :)&#xd; declare function fcs:count-records($node
                    as node(), $model as map(*)) {&#xd; &#xd; let $data-path :=
                    repo-utils:config-value($model("config"),"data.path")&#xd; return
                    count(collection($data-path)/(cmd:CMD|CMD))&#xd; &#xd; };&#xd; &#xd; &#xd;
                    declare function fcs:status($node as node(), $model as map(*)) {&#xd; &#xd; let
                    $count-records := fcs:count-records($node, $model)&#xd; &#xd; let $logs :=
                    collection("/db/mdrepo-data/logs")/log[translate(xs:string(@start-time),' ',
                    'T') castable as xs:dateTime]&#xd; &#xd; let $dataset_status := for $dataset in
                    distinct-values ($logs/xs:string(@dataset))&#xd; let $last-updated := max
                    ($logs[xs:string(@dataset)=$dataset]/xs:dateTime(translate(@start-time,'
                    ','T')))&#xd; let $count-files :=
                    $logs[xs:string(@dataset)=$dataset][xs:dateTime(translate(@start-time,'
                    ','T'))=$last-updated]/xs:string(@count-files)&#xd; return &lt;dataset
                    key="{$dataset}" last-updated="{$last-updated}" count-files="{$count-files}"
                    /&gt;&#xd; &#xd; return &#xd; &lt;div&gt;&#xd; &lt;h3&gt;Status&lt;/h3&gt; &#xd;
                    &lt;table class="bordered" &gt;&#xd;
                    &lt;thead&gt;&lt;tr&gt;&lt;th&gt;dataset&lt;/th&gt;&lt;th&gt;count
                    records&lt;/th&gt;&lt;th&gt;last
                    updated&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&#xd; { &#xd; for $dataset in
                    $dataset_status&#xd; return
                    &lt;tr&gt;&lt;td&gt;{$dataset/xs:string(@key)}&lt;/td&gt;&lt;td
                    class="number"&gt;{$dataset/xs:string(@count-files)}&lt;/td&gt;&lt;td&gt;{$dataset/xs:string(@last-updated)}&lt;/td&gt;&#xd;
                    &lt;/tr&gt;&#xd; }&#xd; &lt;tr&gt;&lt;td&gt;total records&lt;/td&gt;&lt;td
                    class="number"&gt;&lt;b&gt;{$count-records}&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&#xd;
                    &lt;/table&gt;&#xd; &lt;/div&gt;&#xd; &#xd; };&#xd; </f>
                <f n="fcs.xql">xquery version "3.0";&#xd; &#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace fcsm = "http://clarin.eu/fcs/1.0" at "fcs.xqm";&#xd;
                    &#xd; &#xd; let $project := request:get-parameter("project","")&#xd; let $config
                    := config:config($project) &#xd; &#xd; return fcsm:repo($config) &#xd; &#xd; </f>
                <f n="fcs.xqm">xquery version '3.0'; (: : Module Name: FCS : Date: 2012-03-01 : :
                    XQuery : Specification : XQuery v1.0 : Module Overview: Federated Content Search
                    :) (:~ This module provides methods to serve XML-data via the FCS/SRU-interface
                    : @see http://clarin.eu/fcs : @author Matej Durco : @since 2011-11-01 : @version
                    1.1 :) module namespace fcs = "http://clarin.eu/fcs/1.0"; declare namespace err
                    = "http://www.w3.org/2005/xqt-errors"; declare namespace sru =
                    "http://www.loc.gov/zing/srw/"; declare namespace zr =
                    "http://explain.z3950.org/dtd/2.0/"; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0"; declare namespace cmd =
                    "http://www.clarin.eu/cmd/"; declare namespace xhtml=
                    "http://www.w3.org/1999/xhtml"; declare namespace aac = "urn:general"; declare
                    namespace mets="http://www.loc.gov/METS/"; declare namespace
                    xlink="http://www.w3.org/1999/xlink"; import module namespace
                    request="http://exist-db.org/xquery/request"; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at "../diagnostics/diagnostics.xqm";
                    import module namespace cr="http://aac.ac.at/content_repository" at
                    "../../core/cr.xqm"; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm"; import module namespace kwic =
                    "http://exist-db.org/xquery/kwic"; (:import module namespace cmdcoll =
                    "http://clarin.eu/cmd/collections" at "../cmd/cmd-collections.xqm"; :) import
                    module namespace cmdcheck = "http://clarin.eu/cmd/check" at
                    "../cmd/cmd-check.xqm"; import module namespace cql =
                    "http://exist-db.org/xquery/cql" at "../query/cql.xqm"; import module namespace
                    query = "http://aac.ac.at/content_repository/query" at "../query/query.xqm";
                    (:import module namespace facs = "http://www.oeaw.ac.at/icltt/cr-xq/facsviewer"
                    at "../facsviewer/facsviewer.xqm";:) import module namespace facs =
                    "http://aac.ac.at/content_repository/facs" at "../../core/facs.xqm"; import
                    module namespace wc="http://aac.ac.at/content_repository/workingcopy" at
                    "../../core/wc.xqm"; import module namespace
                    project="http://aac.ac.at/content_repository/project" at
                    "../../core/project.xqm"; import module namespace
                    resource="http://aac.ac.at/content_repository/resource" at
                    "../../core/resource.xqm"; import module namespace
                    index="http://aac.ac.at/content_repository/index" at "../../core/index.xqm";
                    import module namespace
                    rf="http://aac.ac.at/content_repository/resourcefragment" at
                    "../../core/resourcefragment.xqm"; declare variable $fcs:explain as xs:string :=
                    "explain"; declare variable $fcs:scan as xs:string := "scan"; declare variable
                    $fcs:searchRetrieve as xs:string := "searchRetrieve"; declare variable
                    $config:app-root external; declare variable $fcs:scanSortText as xs:string :=
                    "text"; declare variable $fcs:scanSortSize as xs:string := "size"; declare
                    variable $fcs:indexXsl :=
                    doc(concat(system:get-module-load-path(),'/index.xsl')); declare variable
                    $fcs:kwicWidth := 40; (: this limit is introduced due to performance problem
                    &gt;50.000? nodes (100.000 was definitely too much) :) declare variable
                    $fcs:maxScanSize:= 100000; declare variable
                    $fcs:project-index-functions-ns-base-uri :=
                    "http://aac.ac.at/content-repository/projects-index-functions/"; (:~ The main
                    entry-point. Processes request-parameters regards config given as parameter +
                    the predefined sys-config @returns the result document (in xml, html or json) :)
                    (: declare function fcs:repo($config-file as xs:string) as item()* { :) declare
                    function fcs:repo($config) as item()* { let (: $config :=
                    repo-utils:config($config-file), :) $key := request:get-parameter("key",
                    "index"), (: accept "q" as synonym to query-param; "query" overrides:) $q :=
                    request:get-parameter("q", ""), $query := request:get-parameter("query", $q), (:
                    if query-parameter not present, 'explain' as DEFAULT operation, otherwise
                    'searchRetrieve' :) (: $operation := if ($query eq "") then
                    request:get-parameter("operation", $fcs:explain):) $operation := if ($query eq
                    "") then request:get-parameter("operation", "explain") else
                    request:get-parameter("operation", $fcs:searchRetrieve), $recordPacking:=
                    request:get-parameter("recordPacking", 'xml'), (: take only first
                    format-argument (otherwise gives problems down the line) TODO: diagnostics :)
                    $x-format := (request:get-parameter("x-format",
                    $repo-utils:responseFormatXml))[1], $x-context_ :=
                    request:get-parameter("x-context", request:get-parameter("project", "")),
                    $x-context := if ($x-context_ eq '') then request:get-parameter("project", "")
                    else $x-context_, (: $query-collections := if (matches($collection-params,
                    "^root$") or $collection-params eq "") then $cr:collectionRoot else
                    tokenize($collection-params,','), :) (: $collection-params, :) $max-depth as
                    xs:integer := xs:integer(request:get-parameter("maxdepth", 1)) let $result := (:
                    if ($operation eq $cr:getCollections) then
                    cr:get-collections($query-collections, $format, $max-depth) else :) if
                    ($operation eq $fcs:explain) then fcs:explain($x-context, $config) else if
                    ($operation eq $fcs:scan) then (: allow optional $index-parameter to be prefixed
                    to the scanClause this is just to simplify input on the client-side :) let
                    $index := request:get-parameter("index", ""), $scanClause-param :=
                    request:get-parameter("scanClause", ""), $scanClause := if ($index ne '' and
                    not(starts-with($scanClause-param, $index)) ) then concat( $index, '=',
                    $scanClause-param) else $scanClause-param, $mode :=
                    request:get-parameter("x-mode", ""), $start-term :=
                    request:get-parameter("startTerm", 1), $response-position :=
                    request:get-parameter("responsePosition", 1), $max-terms :=
                    request:get-parameter("maximumTerms", 50), $max-depth :=
                    request:get-parameter("x-maximumDepth", 1), $sort :=
                    request:get-parameter("sort", 'text') return if ($scanClause='') then
                    &lt;sru:scanResponse&gt; &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    {diag:diagnostics('param-missing',"scanClause")} &lt;/sru:scanResponse&gt; else
                    if (not(number($max-terms)=number($max-terms)) or number($max-terms) &lt; 0 )
                    then &lt;sru:scanResponse&gt; &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    {diag:diagnostics('unsupported-param-value',"maximumTerms")}
                    &lt;/sru:scanResponse&gt; else if
                    (not(number($response-position)=number($response-position)) or
                    number($response-position) &lt; 0 ) then &lt;sru:scanResponse&gt;
                    &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    {diag:diagnostics('unsupported-param-value',"responsePosition")}
                    &lt;/sru:scanResponse&gt; else fcs:scan($scanClause, $x-context, $start-term,
                    $max-terms, $response-position, $max-depth, $sort, $mode, $config) (: return
                    fcs:scan($scanClause, $x-context) :) else if ($operation eq $fcs:searchRetrieve)
                    then if ($query eq "") then
                    &lt;sru:searchRetrieveResponse&gt;&lt;sru:version&gt;1.2&lt;/sru:version&gt;&lt;sru:numberOfRecords&gt;0&lt;/sru:numberOfRecords&gt;
                    {diag:diagnostics("param-missing", "query")}&lt;/sru:searchRetrieveResponse&gt;
                    else let $cql-query := $query, $start-item :=
                    request:get-parameter("startRecord", 1), $max-items :=
                    request:get-parameter("maximumRecords", 50), $x-dataview :=
                    request:get-parameter("x-dataview", repo-utils:config-value($config,
                    'default.dataview')) (: return cr:search-retrieve($cql-query,
                    $query-collections, $format, xs:integer($start-item), xs:integer($max-items)) :)
                    return if (not($recordPacking = ('string','xml'))) then
                    &lt;sru:searchRetrieveResponse&gt;&lt;sru:version&gt;1.2&lt;/sru:version&gt;&lt;sru:numberOfRecords&gt;0&lt;/sru:numberOfRecords&gt;
                    {diag:diagnostics("unsupported-record-packing",
                    $recordPacking)}&lt;/sru:searchRetrieveResponse&gt; else if
                    (not(number($max-items)=number($max-items)) or number($max-items) &lt; 0 ) then
                    &lt;sru:searchRetrieveResponse&gt;&lt;sru:version&gt;1.2&lt;/sru:version&gt;&lt;sru:numberOfRecords&gt;0&lt;/sru:numberOfRecords&gt;
                    {diag:diagnostics("unsupported-param-value",
                    "maximumRecords")}&lt;/sru:searchRetrieveResponse&gt; else if
                    (not(number($start-item)=number($start-item)) or number($start-item) &lt;= 0 )
                    then
                    &lt;sru:searchRetrieveResponse&gt;&lt;sru:version&gt;1.2&lt;/sru:version&gt;&lt;sru:numberOfRecords&gt;0&lt;/sru:numberOfRecords&gt;
                    {diag:diagnostics("unsupported-param-value",
                    "startRecord")}&lt;/sru:searchRetrieveResponse&gt; else
                    fcs:search-retrieve($cql-query, $x-context, xs:integer($start-item),
                    xs:integer($max-items), $x-dataview, $config) else
                    diag:diagnostics('unsupported-operation',$operation) return
                    repo-utils:serialise-as($result, $x-format, $operation, $config) }; (:~
                    OBSOLETED ! Strictly speaking not part of the FCS-protocol, this function
                    delivers static content, to be returned as HTML. : @param $content-id required,
                    identifies the content to be returned. The id is matched against id-attribute in
                    the {config:static.path}-collection : @param $x-context not used right now!
                    probably not needed : @returns found static data or nothing :) (:declare
                    function fcs:static($content-id as xs:string+, $x-context as xs:string*,
                    $config) as item()* { let $context := if ($x-context) then $x-context else
                    repo-utils:config-value($config, 'explain') let $static-dbcoll :=
                    collection(repo-utils:config-value($config,'static.path')) let $data :=
                    $static-dbcoll//*[@id=$content-id] return $data }; :) (:~ handles the
                    explain-operation requests. : @param $x-context optional, identifies a resource
                    to return the explain-record for. (Accepts both MD-PID or Res-PID (MdSelfLink or
                    ResourceRef/text)) : @returns either the default root explain-record, or - when
                    provided with the $x-context parameter - the explain-record of given resource :)
                    declare function fcs:explain($x-context as xs:string*, $config) as item()* { (:
                    let $context := if ($x-context) then $x-context else
                    repo-utils:config-value($config, 'explain') let $explain :=
                    $md-dbcoll//CMD[Header/MdSelfLink/text() eq $context or .//ResourceRef/text() eq
                    $context]//(explain|zr:explain) (\: //ResourceRef/text() :\):) let $md-dbcoll :=
                    collection(repo-utils:config-value($config,'metadata.path')) let
                    $context-mapping := fcs:get-mapping('',$x-context, $config), (: if not specific
                    mapping found for given context, use whole mappings-file this currently happens
                    already in the get-mapping function $mappings := if
                    ($context-mapping/xs:string(@key) = $x-context) then $context-mapping else
                    doc(repo-utils:config-value($config, 'mappings')):) $mappings :=
                    $context-mapping (: let $mappings := doc(repo-utils:config-value($config,
                    'mappings')) (\: let $context-mappings := if ($x-context='') then $mappings else
                    $mappings//map[xs:string(@key)=$x-context]:\):\) let $context-map :=
                    fcs:get-mapping("",$x-context, $config) :) let $server-host := 'TODO:
                    config:param-value($config, "base-url")', $database :=
                    repo-utils:config-value($config, 'project-id'), $title := concat(
                    repo-utils:config-value($config, 'project-title'), if ($x-context != '') then
                    concat(' - ', $mappings/xs:string(@title)) else '') , $descr :=
                    repo-utils:config-value($config, 'teaser-text'), $author :=
                    repo-utils:config-value($config, 'author'), $contact :=
                    repo-utils:config-value($config, 'contact'), $date-modified := 'TODO' let
                    $explain:= &lt;sru:explainResponse&gt;
                    &lt;sru:version&gt;1.1&lt;/sru:version&gt; &lt;sru:record&gt;
                    &lt;sru:recordSchema&gt;http://explain.z3950.org/dtd/2.1/&lt;/sru:recordSchema&gt;
                    &lt;sru:recordPacking&gt;xml&lt;/sru:recordPacking&gt; &lt;sru:recordData&gt;
                    &lt;zr:explain xmlns:zr="http://explain.z3950.org/dtd/2.0/"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="http://explain.z3950.org/dtd/2.0/
                    file:/C:/Users/m/3lingua/corpus_shell/_repo2/corpus_shell/fcs/schemas/zeerex-2.0.xsd"
                    authoritative="false" id="id1"&gt; &lt;zr:serverInfo protocol="SRU"
                    version="1.2" transport="http"&gt; &lt;zr:host&gt;{$server-host}&lt;/zr:host&gt;
                    &lt;zr:port&gt;80&lt;/zr:port&gt;
                    &lt;zr:database&gt;{$database}&lt;/zr:database&gt; &lt;/zr:serverInfo&gt;
                    &lt;zr:databaseInfo&gt; &lt;zr:title lang="en"
                    primary="true"&gt;{$title}&lt;/zr:title&gt; &lt;zr:description lang="en"
                    primary="true"&gt;{$descr}&lt;/zr:description&gt;
                    &lt;zr:author&gt;{$author}&lt;/zr:author&gt;
                    &lt;zr:contact&gt;{$contact}&lt;/zr:contact&gt; &lt;/zr:databaseInfo&gt;
                    &lt;zr:metaInfo&gt;
                    &lt;zr:dateModified&gt;{$date-modified}&lt;/zr:dateModified&gt;
                    &lt;/zr:metaInfo&gt; &lt;zr:indexInfo&gt; &lt;zr:set
                    identifier="isocat.org/datcat" name="isocat"&gt; &lt;zr:title&gt;ISOcat data
                    categories&lt;/zr:title&gt; &lt;/zr:set&gt; &lt;zr:set
                    identifier="clarin.eu/fcs" name="fcs"&gt; &lt;zr:title&gt;CLARIN - Federated
                    Content Search&lt;/zr:title&gt; &lt;/zr:set&gt; &lt;!-- &lt;index search="true"
                    scan="true" sort="false"&gt; &lt;title lang="en"&gt;Resource&lt;/title&gt;
                    &lt;map&gt; &lt;name set="fcs"&gt;resource&lt;/name&gt; &lt;/map&gt;
                    &lt;/index&gt; --&gt; { for $index in
                    distinct-values($mappings//index/xs:string(@key)) order by $index return
                    &lt;zr:index search="true" scan="true" sort="false"&gt; &lt;zr:title
                    lang="en"&gt;{$index}&lt;/zr:title&gt; &lt;zr:map&gt; &lt;zr:name
                    set="fcs"&gt;{$index}&lt;/zr:name&gt; &lt;/zr:map&gt; &lt;/zr:index&gt; }
                    &lt;/zr:indexInfo&gt; &lt;zr:schemaInfo&gt; &lt;!-- &lt;schema
                    identifier="clarin.eu/cmd" location="" name="cmd" retrieve="true"&gt; &lt;title
                    lang="en"&gt;Component Metadata&lt;/title&gt; &lt;/schema&gt; --&gt;
                    &lt;/zr:schemaInfo&gt; &lt;zr:configInfo&gt; &lt;!-- should translate to
                    x-cmd-context extension-parameter if correctly interpreted:
                    http://explain.z3950.org/dtd/commentary.html#8 or shall we rather directly
                    write: x-cmd-context or x-fcs-context --&gt; &lt;!-- &lt;supports
                    type="extraSearchData"&gt;cmd context&lt;/supports&gt; --&gt;
                    &lt;/zr:configInfo&gt; &lt;/zr:explain&gt; &lt;/sru:recordData&gt;
                    &lt;/sru:record&gt; &lt;/sru:explainResponse&gt; return $explain }; (: TODO?:
                    only read explicit indexes + create index on demand. :) (: declare function
                    fcs:scan($scanClause as xs:string, $x-context as xs:string*) { let
                    $clause-tokens := tokenize($scanClause,'='), $index := $clause-tokens[1], $term
                    := $clause-tokens[2], (\:$map-index :=
                    $repo-utils:mappings/map/index[@key=$index], :\) $index-file :=
                    concat(repo-utils:config-value('index.prefix'),$index,'.xml'), h$result :=
                    doc($index-file) return $result }; :) (:~ This function handles the
                    scan-operation requests : (derived from cmd:scanIndex function) : two phases: :
                    1. one create full index for given path/element within given collection (for now
                    the collection is stored in the name - not perfect) (and cache) : 2. select
                    wished subsequence (on second call, only the second step is performed) :
                    actually wrapping function handling caching of the actual scan result (coming
                    from do-scan-default()) : or fetching the cached result (if available) : also
                    dispatching to cmd-collections for the scan-clause=cmd.collections : there
                    either scanClause-filter or x-context is used as constraint (scanClause-filter
                    is prefered)) :) declare function fcs:scan($scan-clause as xs:string, $x-context
                    as xs:string+, $start-item as xs:integer, $max-items as xs:integer,
                    $response-position as xs:integer, $max-depth as xs:integer, $p-sort as
                    xs:string?, $mode as xs:string?, $config) as item()? { let $scx :=
                    tokenize($scan-clause,'='), $index-name := $scx[1], (:$index :=
                    fcs:get-mapping($index-name, $x-context, $config ), :) (: if no index-mapping
                    found, dare to use the index-name as xpath :) (:$index-xpath :=
                    index:index-as-xpath($index-name,$x-context),:) $filter := ($scx[2],'')[1],
                    $sort := if ($p-sort eq $fcs:scanSortText or $p-sort eq $fcs:scanSortSize) then
                    $p-sort else $fcs:scanSortText let $sanitized-xcontext :=
                    repo-utils:sanitize-name($x-context) let $project-id := if
                    (config:project-exists($x-context)) then $x-context else
                    cr:resolve-id-to-project-pid($x-context) let $index-doc-name :=
                    repo-utils:gen-cache-id("index", ($sanitized-xcontext, $index-name, $sort,
                    $max-depth)), $dummy := util:log-app("DEBUG", $config:app-name, "cache-mode:
                    "||$mode), $dummy2 := util:log-app("DEBUG", $config:app-name, "is in cache:
                    "||repo-utils:is-in-cache($index-doc-name, $config) ), (: get the base-index
                    from cache, or create and cache :) $index-scan := if
                    (repo-utils:is-in-cache($index-doc-name, $config) and not($mode='refresh')) then
                    let $dummy := util:log-app("DEBUG", $config:app-name, "reading index
                    "||$index-doc-name||" from cache") return
                    repo-utils:get-from-cache($index-doc-name, $config) else (: TODO: cmd-specific
                    stuff has to be integrated in a more dynamic way! :) let $data := (: if
                    ($index-name eq $cmdcoll:scan-collection) then let $starting-handle := if
                    ($filter ne '') then $filter else $x-context return
                    cmdcoll:colls($starting-handle, $max-depth, cmdcoll:base-dbcoll($config)) (\:
                    just a hack for now, handling of special indexes should be put solved in some
                    more easily extensible way :\) else :) if ($index-name eq 'cmd.profile') then
                    (:(\: let $context := repo-utils:context-to-collection($x-context, $config):\):)
                    cmdcheck:scan-profiles($x-context, $config) else if (starts-with($index-name,
                    'fcs.')) then let $metsdivs := switch ($index-name) (: resources only :) case
                    'fcs.resource' return let $resources := project:list-resources($x-context)
                    return $resources!&lt;mets:div&gt;{./@*}&lt;/mets:div&gt; case 'fcs.rf' return
                    if ($project-id eq $x-context) then project:list-resources($x-context) else
                    resource:get($x-context,$project-id) case 'fcs.toc' return if ($project-id eq
                    $x-context) then (: this delivers the whole structure of all resources - it may
                    be too much in one shot resource:get-toc($project-id) would deliver only up
                    until chapter level alternatively just take fcs.resource to get only
                    resource-listing :) project:get-toc-resolved($project-id) else
                    resource:get-toc($x-context,$project-id) default return () (:let $map := (\: if
                    ($x-context= ('', 'default')) then doc(repo-utils:config-value($config,
                    'mappings')):\) if (not($context-map/xs:string(@key) = $x-context) ) then
                    $context-map else (\: generate a map based on the indexes defined for given
                    context :\) let $data-collection := repo-utils:context-to-collection($x-context,
                    $config) (\: let $context-map := fcs:get-mapping('', $x-context,$config):\) let
                    $fcs-resource-index := fcs:get-mapping('fcs.resource', $x-context,$config) let
                    $index-key-xpath := $fcs-resource-index/(path[xs:string(@type)='key'], path)[1]
                    let $index-label-xpath := $fcs-resource-index/(path[xs:string(@type)='label'],
                    path)[1] let $base-elem := $fcs-resource-index/xs:string(@base_elem) return
                    &lt;map &gt;{ ($context-map/@key, $context-map/@title, for $item in
                    util:eval(concat("$data-collection/descendant-or-self::", $base-elem)) let $key
                    := util:eval(concat("$item/", $index-key-xpath )) let $label :=
                    util:eval(concat("$item/", $index-label-xpath )) return &lt;map key="{$key}"
                    title="{$label}" /&gt; )}&lt;/map&gt; :) (: let $mappings :=
                    doc(repo-utils:config-value($config, 'mappings')):) (: use only module-config
                    here - otherwise scripts.path override causes problems :) let $xsl :=
                    repo-utils:xsl-doc('metsdiv-scan', "xml", $config) return
                    transform:transform($metsdivs,$xsl,()) (: return $context-map:) else
                    fcs:do-scan-default($scan-clause, $x-context, $sort, $config) (: if empty
                    result, return the empty result, but don't store to not fill cache with
                    garbage:) (: return $data:) let $dummy := util:log-app("DEBUG",
                    $config:app-name, "generating index "||$index-doc-name) return
                    repo-utils:store-in-cache($index-doc-name , $data, $config,'indexes') (:if
                    (number($data//sru:scanResponse/sru:extraResponseData/fcs:countTerms) &gt; 0)
                    then else $data:) (: extra handling if fcs.resource=root :) let $filterx := if
                    ($index-name= 'fcs.resource' and $filter='root') then '' else $filter (: extract
                    the required subsequence (according to given sort) :) let $res-nodeset :=
                    transform:transform($index-scan,$fcs:indexXsl, &lt;parameters&gt;&lt;param
                    name="scan-clause" value="{$scan-clause}"/&gt; &lt;param name="mode"
                    value="subsequence"/&gt; &lt;param name="x-context" value="{$x-context}"/&gt;
                    &lt;param name="sort" value="{$sort}"/&gt; &lt;param name="filter"
                    value="{$filterx}"/&gt; &lt;param name="start-item" value="{$start-item}"/&gt;
                    &lt;param name="response-position" value="{$response-position}"/&gt; &lt;param
                    name="max-items" value="{$max-items}"/&gt; &lt;/parameters&gt;), $count-items :=
                    count($res-nodeset/sru:term), (: $colls := if (fn:empty($collection)) then ''
                    else fn:string-join($collection, ","), :) $colls := string-join( $x-context, ',
                    ') , $created := fn:current-dateTime() (: $scan-clause := concat($xpath, '=',
                    $filter) :) (: $res := &lt;Terms colls="{$colls}" created="{$created}"
                    count_items="{$count-items}" start-item="{$start-item}" max-items="{$max-items}"
                    sort="{$sort}" scanClause="{$scan-clause}" &gt;{$res-term}&lt;/Terms&gt;
                    count_text="{$count-text}" count_distinct_text="{$distinct-text-count}" :) (:
                    $res := &lt;sru:scanResponse&gt; &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    {$res-nodeset} &lt;sru:echoedScanRequest&gt;
                    &lt;sru:scanClause&gt;{$scan-clause}&lt;/sru:scanClause&gt;
                    &lt;sru:maximumTerms&gt;{ $count-items }&lt;/sru:maximumTerms&gt;
                    &lt;/sru:echoedScanRequest&gt; &lt;/sru:scanResponse&gt; :) (: let $result-count
                    := $doc/Term/@count, $result-seq := fn:subsequence($doc/Term/v, $start-item,
                    $end-item), $result-frag := ($doc/Term, $result-seq), $seq-count :=
                    fn:count($result-seq) :) return $res-nodeset (:return $index-scan DEBUG:) };
                    (:OBSOLETED ! aggregation, sorting and serializing is handled by
                    fcs:term-from-nodes() and fcs:group-by-facet() declare function
                    fcs:do-scan-default($scan-clause as xs:string, $x-context as xs:string, $sort as
                    xs:string, $config) as item()* { let $path :=
                    index:index-as-xpath($scan-clause,$x-context) let $data-collection :=
                    repo-utils:context-to-collection($x-context, $config) let $getnodes :=
                    util:eval(fn:concat("$data-collection//", $path)), $match-path :=
                    index:index-as-xpath($scan-clause,$x-context,'match-only'), $label-path :=
                    index:index-as-xpath($scan-clause,$x-context,'label-only'), $log :=
                    util:log-app("INFO",$config:app-name,$match-path||" "||$label-path), (\: if we
                    collected strings, we have to wrap them in elements to be able to work with them
                    in xsl :\) $prenodes := if ($label-path!='') then for $t in $getnodes return
                    &lt;v
                    displayTerm="{string-join(util:eval("$t/"||$label-path),'')}"&gt;{string-join(util:eval("$t/"||$match-path),'')}&lt;/v&gt;
                    else if ($getnodes[1] instance of xs:string or $getnodes[1] instance of text())
                    then for $t in $getnodes return &lt;v&gt;{$t}&lt;/v&gt; else if ($getnodes[1]
                    instance of attribute()) then for $t in $getnodes return
                    &lt;v&gt;{xs:string($t)}&lt;/v&gt; else for $t in $getnodes return
                    &lt;v&gt;{string-join($t//text()," ")}&lt;/v&gt; let $nodes := &lt;nodes
                    path="{fn:concat('//', $match-path)}" &gt;{$prenodes}&lt;/nodes&gt;, (\: use
                    XSLT-2.0 for-each-group functionality to aggregate the values of a node - much,
                    much faster, than XQuery :\) $data := transform:transform($nodes,$fcs:indexXsl,
                    &lt;parameters&gt; &lt;param name="scan-clause" value="{$scan-clause}"/&gt;
                    &lt;param name="sort" value="{$sort}"/&gt; &lt;/parameters&gt;) return $data
                    };:) declare function fcs:do-scan-default($scan-clause as xs:string, $x-context
                    as xs:string, $sort as xs:string, $config) as item()* { let $project-pid :=
                    repo-utils:context-to-project-pid($x-context,$config) let $facets :=
                    index:facets($scan-clause,$project-pid) let $path :=
                    index:index-as-xpath($scan-clause,$project-pid) (:let $data-collection :=
                    repo-utils:context-to-collection($x-context, $config), $nodes :=
                    util:eval("$data-collection//"||$path):) let $context-parsed :=
                    repo-utils:parse-x-context($x-context,$config) let $data :=
                    repo-utils:context-to-data($context-parsed,$config), (: this limit is introduced
                    due to performance problem &gt;50.000? nodes (100.000 was definitely too much)
                    :) $nodes := subsequence(util:eval("$data//"||$path),1,$fcs:maxScanSize) let
                    $terms := if ($facets/index) then fcs:group-by-facet($nodes, $sort,
                    $facets/index, $project-pid) else fcs:term-from-nodes($nodes, $sort,
                    $scan-clause, $project-pid) return &lt;sru:scanResponse
                    xmlns:fcs="http://clarin.eu/fcs/1.0"&gt;
                    &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    &lt;sru:terms&gt;{$terms}&lt;/sru:terms&gt; &lt;fcs:countTerms
                    level="top"&gt;{count($terms)}&lt;/fcs:countTerms&gt; &lt;fcs:countTerms
                    level="total"&gt;{count($terms//sru:term)}&lt;/fcs:countTerms&gt;
                    &lt;sru:echoedScanRequest&gt;
                    &lt;sru:scanClause&gt;{$scan-clause}&lt;/sru:scanClause&gt;
                    &lt;sru:maximumTerms/&gt; &lt;/sru:echoedScanRequest&gt;
                    &lt;/sru:scanResponse&gt; }; (:%private :) declare function
                    fcs:term-from-nodes($node as item()+, $order-param as xs:string, $index-key as
                    xs:string, $project-pid as xs:string) { let $match-path :=
                    index:index-as-xpath($index-key,$project-pid,'match-only'), $label-path :=
                    index:index-as-xpath($index-key,$project-pid,'label-only') let $data := for $n
                    in $node let $value:=
                    map:entry("value",string-join(util:eval("$n/"||$match-path),'')), $label :=
                    map:entry("label", if ($label-path!='') then
                    util:eval("$n/"||$label-path)/data(.) else $value) return
                    map:new(($value,$label)) let $order-expr := switch ($order-param) case 'text'
                    return "$value" case 'size' return "count($g)" default return "$value" let
                    $order-modifier := switch ($order-param) case 'size' return "descending" default
                    return "ascending" let $terms := for $g at $pos in $data group by $value :=
                    map:get($g,'value') order by if ($order-modifier='ascending') then true() else
                    util:eval($order-expr) descending, if ($order-modifier='descending') then true()
                    else util:eval($order-expr) ascending return let $m-label :=
                    map:entry("label",map:get($g[1],'label')), $m-value :=
                    map:entry("value",$value), $m-count := map:entry("numberOfRecords",count($g))
                    return map:new(($m-label,$m-value,$m-count)) return for $term at $pos in $terms
                    return &lt;sru:term&gt; &lt;sru:value&gt;{$term("value")}&lt;/sru:value&gt;
                    &lt;sru:displayTerm&gt;{$term("label")}&lt;/sru:displayTerm&gt;
                    &lt;sru:numberOfRecords&gt;{$term("numberOfRecords")}&lt;/sru:numberOfRecords&gt;
                    &lt;sru:extraTermData&gt; &lt;fcs:position&gt;{$pos}&lt;/fcs:position&gt;
                    &lt;/sru:extraTermData&gt; &lt;/sru:term&gt; }; declare %private function
                    fcs:group-by-facet($data as node()*,$sort as xs:string, $index as
                    element(index), $project-pid) as item()* { let $key := $index/xs:string(@key),
                    $match:= index:index-as-xpath($key,$project-pid,'match-only') let
                    $order-expression := switch ($sort) case 'text' return "$group-key" case 'size'
                    return "count($entries)" default return "$group-key" let $order-modifier :=
                    switch ($sort) case 'size' return "descending" default return "ascending" let
                    $groups := let $maps := for $x in $data group by $g := util:eval("$x/"||$match)
                    return map:entry($g,$x) let $map := map:new($maps) return $map return for
                    $group-key in map:keys($groups) let $entries := map:get($groups, $group-key)
                    order by if ($order-modifier='ascending') then true() else
                    util:eval($order-expression) descending, if ($order-modifier='descending') then
                    true() else util:eval($order-expression) ascending return &lt;sru:term&gt;
                    &lt;sru:displayTerm&gt;{fcs:term-to-label($group-key,
                    $key,$project-pid)}&lt;/sru:displayTerm&gt;
                    &lt;sru:value&gt;{$group-key}&lt;/sru:value&gt;
                    &lt;sru:numberOfRecords&gt;{count($entries)}&lt;/sru:numberOfRecords&gt;
                    &lt;sru:extraTermData&gt; &lt;cr:type&gt;{$key}&lt;/cr:type&gt; {if
                    ($index/index) then fcs:group-by-facet($entries, $sort, $index/index,
                    $project-pid) else fcs:term-from-nodes($entries, $sort, root($index)/index/@key,
                    $project-pid)} &lt;/sru:extraTermData&gt; &lt;/sru:term&gt; }; declare %private
                    function fcs:term-to-label($term as xs:string, $index as xs:string, $project-pid
                    as xs:string) as xs:string{ let $labels :=
                    doc(project:path($project-pid,"home")||"/termlabels.xml") return
                    ($labels//term[@key=$term][ancestor::*/@key=$index],$term)[1] }; (:declare
                    function fcs:exec-query($data as map(*)*, $xpath-query as xs:string?) as map()+
                    {:) declare function fcs:exec-query($data, $xpath-query){
                    fcs:exec-query($data,$xpath-query,()) }; (:declare function fcs:exec-query($data
                    as map(*)*, $xpath-query as xs:string?, $flags as map()?) as map()* {:) declare
                    function fcs:exec-query($data, $xpath-query, $flags as map()?) { if
                    ($xpath-query!='') then (: if there was a problem with the parsing the query
                    don't evaluate :) if ($xpath-query instance of text() or $xpath-query instance
                    of xs:string) then
                    util:eval(concat("$data",translate($xpath-query,'&amp;amp;','?'))) else () (:for
                    $d in $data("data") return let $matches:= util:eval("$d"||$xpath-query) return
                    map { "resource-id":=$d, "matches" := $matches, "count" := count($matches) }:)
                    else () }; (:~ : Main search function that handles the searchRetrieve-operation
                    request) : : @param $query: The FCS Query as input by the user : @param
                    $x-context: The CR-Context of the query : @param $startRecord: The nth of all
                    results to display : @param $maxmimumRecords: The maximum of records to display
                    : @param $x-dataview: A comma-separated list of keywords for the output viwe on
                    the results. This depends on &lt;code&gt;fcs:format-record-data()&lt;/code&gt;.
                    : @param $config: The project's config : @see fcs:format-record-data() ~:)
                    declare function fcs:search-retrieve($query as xs:string, $x-context as
                    xs:string*, $startRecord as xs:integer, $maximumRecords as xs:integer,
                    $x-dataview as xs:string*, $config) as item()* { let $start-time :=
                    util:system-dateTime() let $project-id :=
                    cr:resolve-id-to-project-pid($x-context) let
                    $context-parsed:=repo-utils:parse-x-context($x-context,$config) (: basically
                    search on workingcopy, just in case of resourcefragment lookup, we have to go to
                    resourcefragments :) (:let $data := if
                    (contains($query,$config:INDEX_INTERNAL_RESOURCEFRAGMENT)) then
                    collection(project:path($project-id, 'resourcefragments')) else
                    repo-utils:context-to-collection($x-context, $config):) (: basically we search
                    on working copies and filter out fragments and resoruces (prefixed with a minus
                    sign, e.g. &amp;x-context=abacus2,-abacus2.1) below :) (: FIXME add support for
                    index 'fcs.resource' :) let $data := if
                    (contains($query,$config:INDEX_INTERNAL_RESOURCEFRAGMENT)) then
                    collection(project:path($project-id, 'resourcefragments')) else
                    repo-utils:context-to-data($context-parsed,$config) let $xpath-query :=
                    cql:cql-to-xpath($query,$project-id) (: ! results are only actual matching
                    elements (no wrapping base_elem, i.e. resourcefragments ! :) let
                    $result-unfiltered:= query:execute-query ($query,$data,$project-id) (: filter
                    excluded resources or fragments unless this is a direct fragment request :) let
                    $result := if (contains($query,$config:INDEX_INTERNAL_RESOURCEFRAGMENT)) then
                    $result-unfiltered else
                    repo-utils:filter-by-context($result-unfiltered,$context-parsed,$config) let
                    $result-count := fn:count($result), $facets := if
                    (contains($x-dataview,'facets') and $result-count &gt; 1) then
                    fcs:generateFacets($result, $query) else (), $ordered-result :=
                    fcs:sort-result($result, $query, $x-context, $config), $result-seq :=
                    fn:subsequence($ordered-result, $startRecord, $maximumRecords), $seq-count :=
                    fn:count($result-seq), $end-time := util:system-dateTime() let $config-param :=
                    if (contains($query,'fcs.toc')) then map{ "config" := $config, "x-highlight" :=
                    "off" } else $config let $result-seq-expanded := util:expand($result-seq) let
                    $records := &lt;sru:records&gt;{ for $rec at $pos in $result-seq-expanded let
                    $rec-data := fcs:format-record-data( $rec, $x-dataview, $x-context,
                    $config-param) return &lt;sru:record&gt;
                    &lt;sru:recordSchema&gt;http://clarin.eu/fcs/1.0/Resource.xsd&lt;/sru:recordSchema&gt;
                    &lt;sru:recordPacking&gt;xml&lt;/sru:recordPacking&gt;
                    &lt;sru:recordData&gt;{$rec-data}&lt;/sru:recordData&gt;
                    &lt;sru:recordPosition&gt;{$pos}&lt;/sru:recordPosition&gt;
                    &lt;sru:recordIdentifier&gt;{xs:string($rec-data/fcs:ResourceFragment[1]/@ref)}&lt;/sru:recordIdentifier&gt;
                    &lt;/sru:record&gt; }&lt;/sru:records&gt;, $end-time2 := util:system-dateTime()
                    return switch (true()) case ($xpath-query instance of element(sru:diagnostics))
                    return &lt;sru:searchRetrieveResponse&gt;
                    &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    &lt;sru:numberOfRecords&gt;{$result-count}&lt;/sru:numberOfRecords&gt;
                    {$xpath-query} &lt;/sru:searchRetrieveResponse&gt; case ($startRecord &gt;
                    $result-count + 1 ) return &lt;sru:searchRetrieveResponse&gt;
                    &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    &lt;sru:numberOfRecords&gt;{$result-count}&lt;/sru:numberOfRecords&gt;
                    {diag:diagnostics('start-out-of-range',concat( $startRecord , ' &gt; ',
                    $result-count))} &lt;/sru:searchRetrieveResponse&gt; default return
                    &lt;sru:searchRetrieveResponse&gt; &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    &lt;sru:numberOfRecords&gt;{$result-count}&lt;/sru:numberOfRecords&gt;
                    &lt;sru:echoedSearchRetrieveRequest&gt;
                    &lt;sru:version&gt;1.2&lt;/sru:version&gt;
                    &lt;sru:query&gt;{$query}&lt;/sru:query&gt;
                    &lt;fcs:x-context&gt;{$x-context}&lt;/fcs:x-context&gt;
                    &lt;fcs:x-dataview&gt;{$x-dataview}&lt;/fcs:x-dataview&gt;
                    &lt;sru:startRecord&gt;{$startRecord}&lt;/sru:startRecord&gt;
                    &lt;sru:maximumRecords&gt;{$maximumRecords}&lt;/sru:maximumRecords&gt;
                    &lt;sru:query&gt;{$query}&lt;/sru:query&gt;
                    &lt;sru:baseUrl&gt;{repo-utils:config-value($config,
                    "base.url")}&lt;/sru:baseUrl&gt; &lt;/sru:echoedSearchRetrieveRequest&gt;
                    &lt;sru:extraResponseData&gt;
                    &lt;fcs:returnedRecords&gt;{$seq-count}&lt;/fcs:returnedRecords&gt;
                    &lt;fcs:numberOfMatches&gt;{ () (: count($match) :)}&lt;/fcs:numberOfMatches&gt;
                    &lt;fcs:duration&gt;{($end-time - $start-time, $end-time2 - $end-time)
                    }&lt;/fcs:duration&gt; &lt;fcs:transformedQuery&gt;{ $xpath-query
                    }&lt;/fcs:transformedQuery&gt; &lt;/sru:extraResponseData&gt; {$records} { if
                    ($xpath-query instance of element(diagnostics)) then
                    &lt;sru:diagnostics&gt;{$xpath-query/*}&lt;/sru:diagnostics&gt; else () }
                    {$facets} &lt;/sru:searchRetrieveResponse&gt; }; (:~ facets are only available
                    in SRU 2.0, but we need them now. For now only for faceting over resources
                    xsi:schemaLocation="http://docs.oasis-open.org/ns/search-ws/facetedResults
                    http://docs.oasis-open.org/search-ws/searchRetrieve/v1.0/os/schemas/facetedResults.xsd"
                    :) declare function fcs:generateFacets($result, $orig-query) { let $project-id
                    := ($result/data(@cr:project-id))[1] return &lt;sru:facetedResults&gt;
                    &lt;sru:facet&gt;
                    &lt;sru:facetDisplayLabel&gt;Resource&lt;/sru:facetDisplayLabel&gt;
                    &lt;sru:index&gt;fcs.resource&lt;/sru:index&gt;
                    &lt;sru:relation&gt;=&lt;/sru:relation&gt; &lt;sru:terms&gt;{ for $hit in
                    $result let $id := $hit/data(@cr:resource-pid) group by $id return
                    &lt;sru:term&gt;
                    &lt;sru:actualTerm&gt;{resource:label($id,$project-id)}&lt;/sru:actualTerm&gt;
                    &lt;sru:query&gt;{$id}&lt;/sru:query&gt;
                    &lt;sru:requestUrl&gt;?operation=searchRetrieve&amp;amp;query={$orig-query}&amp;amp;x-context={$id}&lt;/sru:requestUrl&gt;
                    &lt;sru:count&gt;{count($hit)}&lt;/sru:count&gt; &lt;/sru:term&gt;
                    }&lt;/sru:terms&gt; &lt;/sru:facet&gt; &lt;/sru:facetedResults&gt; }; (:declare
                    function fcs:format-record-data($record-data as node(), $data-view as
                    xs:string*, $x-context as xs:string*, $config as item()*, $resource-data as
                    map(*)?) as item()* {:) declare function fcs:format-record-data($record-data as
                    node(), $data-view as xs:string*, $x-context as xs:string*, $config as item()*)
                    as item()* { fcs:format-record-data($record-data, $record-data, $data-view,
                    $x-context, $config) }; (:~ generates the inside of one record according to
                    fcs/Resource.xsd fcs:Resource, fcs:ResourceFragment, fcs:DataView all based on
                    mappings and parameters (data-view) @param $orig-sequence-record-data - the node
                    from the original not expanded search result, so that we can optionally navigate
                    outside the base_elem (for resource_fragment or so) if not providable, setting
                    the same data as in $record-data-input works mostly (expect, when you want to
                    move out of the base_elem) @param $record-data-input the base-element with the
                    match hits inside (marked with exist:match) :) declare function
                    fcs:format-record-data($orig-sequence-record-data as node(), $record-data-input
                    as node(), $data-view as xs:string*, $x-context as xs:string*, $config as
                    item()*) as item()* { let $title := fcs:apply-index($orig-sequence-record-data,
                    "title",$x-context, $config) (: this is (hopefully) temporary FIX: the
                    resource-pid attribute is in fcs-namespace (or no namespace?) on
                    resourceFragment element! :) let $resource-pid:=
                    $record-data-input/ancestor-or-self::*[1]/data(@*[local-name()=$config:RESOURCE_PID_NAME])
                    (: let $resource-pid:=
                    util:eval("$record-data-input/ancestor-or-self::*[1]/data(@cr:"||$config:RESOURCE_PID_NAME||")"):)
                    let $project-id := cr:resolve-id-to-project-pid($x-context) (: if no
                    exist:match, take the root of the matching snippet :) let $match-ids := if
                    (exists($record-data-input//exist:match/parent::*/data(@cr:id))) then
                    $record-data-input//exist:match/parent::*/data(@cr:id) else
                    $record-data-input/data(@cr:id) (: if the match is a whole resourcefragment we
                    dont need a lookup, its ID is in the attribute :) let $resourcefragment-pid :=
                    if ($record-data-input/ancestor-or-self::*[1]/@*[local-name() =
                    $config:RESOURCEFRAGMENT_PID_NAME]) then
                    $record-data-input/ancestor-or-self::*[1]/data(@*[local-name() =
                    $config:RESOURCEFRAGMENT_PID_NAME]) else
                    rf:lookup-id($match-ids[1],$resource-pid, $project-id)[1] let $rf := if
                    ($record-data-input/@*[local-name()=$config:RESOURCEFRAGMENT_PID_NAME]) then
                    $record-data-input else rf:lookup($match-ids[1],$resource-pid, $project-id) let
                    $rf-entry := rf:record($resourcefragment-pid,$resource-pid, $project-id) let
                    $res-entry :=
                    $rf-entry/parent::mets:div[@TYPE=$config:PROJECT_RESOURCE_DIV_TYPE] let
                    $matches-to-highlight:=
                    (tokenize(request:get-parameter("x-highlight",""),","),$match-ids) let
                    $record-data := if (exists($matches-to-highlight) and
                    request:get-parameter("x-highlight","") != 'off') then (: if
                    ($config("x-highlight")="off"):) if ($config instance of map()) then if
                    ($config("x-highlight") = "off") then $rf else
                    fcs:highlight-matches-in-copy($rf, $matches-to-highlight) else
                    fcs:highlight-matches-in-copy($rf, $matches-to-highlight) else $rf (: to repeat
                    current $x-format param-value in the constructed requested :) let $x-format :=
                    request:get-parameter("x-format", $repo-utils:responseFormatXml) let
                    $resourcefragment-ref := if (exists($resourcefragment-pid)) then
                    concat('?operation=searchRetrieve&amp;amp;query=fcs.rf="',
                    replace(xmldb:encode-uri(replace($resourcefragment-pid[1],'//','__')),'__','//'),
                    '"&amp;amp;x-context=', $x-context, '&amp;amp;x-dataview=full',
                    '&amp;amp;version=1.2', if
                    (exists(util:expand($record-data)//exist:match/ancestor-or-self::*[@cr:id][1]))
                    then
                    '&amp;amp;x-highlight='||string-join(distinct-values(util:expand($record-data)//exist:match/ancestor-or-self::*[@cr:id][1]/@cr:id),',')
                    else () ) else "" let $kwic := if (contains($data-view,'kwic')) then let
                    $kwic-config := &lt;config width="{$fcs:kwicWidth}"/&gt; let $kwic-html :=
                    kwic:summarize($record-data[1], $kwic-config) return if (exists($kwic-html))
                    then for $match in $kwic-html return (&lt;fcs:c
                    type="left"&gt;{$match/span[1]/text()}&lt;/fcs:c&gt;, (: &lt;c
                    type="left"&gt;{kwic:truncate-previous($exp-rec, $matches[1], (), 10, (),
                    ())}&lt;/c&gt; :) &lt;fcs:kw&gt;{$match/span[2]/text()}&lt;/fcs:kw&gt;,
                    &lt;fcs:c type="right"&gt;{$match/span[3]/text()}&lt;/fcs:c&gt;) (: let $summary
                    := kwic:get-summary($exp-rec, $matches[1], $config) :) (: &lt;fcs:DataView
                    type="kwic-html"&gt;{$kwic-html}&lt;/fcs:DataView&gt;:) (: DEBUG:
                    &lt;fcs:DataView&gt;{$kwic-html}&lt;/fcs:DataView&gt;) :) else (: if no
                    kwic-match let's take first 100 characters There c/should be some more
                    sophisticated way to extract most significant info e.g. match on the query-field
                    :) substring($record-data[1],1,(2 * $fcs:kwicWidth)) else () (: prev-next :) let
                    $dv-navigation:= if (contains($data-view,'navigation')) then (:let $context-map
                    := fcs:get-mapping("",$x-context, $config) let $sort-index := if
                    (exists($context-map/@sort)) then $context-map/@sort else "title":) (: WATCHME:
                    this only works if default-sort and title index are the same :) (:important is
                    the $responsePosition=2 :) (: let $prev-next-scan :=
                    fcs:scan(concat($sort-index, '=', $title),$x-context,
                    1,3,2,1,'text','',$config):) (: handle also edge situations expect maximum 3
                    terms, on the edges only 2 terms:) (:let $rf-prev := if
                    (count($prev-next-scan//sru:terms/sru:term) = 3 or
                    not($prev-next-scan//sru:terms/sru:term[1]/sru:value = $title)) then
                    $prev-next-scan//sru:terms/sru:term[1]/sru:value else "" let $rf-next := if
                    (count($prev-next-scan//sru:terms/sru:term) = 3) then
                    $prev-next-scan//sru:terms/sru:term[3]/sru:value else if
                    (not($prev-next-scan//sru:terms/sru:term[2]/sru:value = $title)) then
                    $prev-next-scan//sru:terms/sru:term[2]/sru:value else "" :) let $rf-prev :=
                    $rf-entry/preceding-sibling::mets:div[@TYPE =
                    $config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE][1] let $rf-next :=
                    $rf-entry/following-sibling::mets:div[@TYPE =
                    $config:PROJECT_RESOURCEFRAGMENT_DIV_TYPE][1] let $log:=
                    util:log-app("INFO",$config:app-name,("$rf-entry",$rf-entry)) let $log:=
                    util:log-app("INFO",$config:app-name,("$rf-prev",$rf-prev)) let $log:=
                    util:log-app("INFO",$config:app-name,("$rf-next",$rf-next)) let $rf-prev-ref :=
                    if (exists($rf-prev)) then concat('?operation=searchRetrieve&amp;amp;query=',
                    $config:INDEX_INTERNAL_RESOURCEFRAGMENT, '="',
                    xmldb:encode-uri($rf-prev/data(@ID)),
                    '"&amp;amp;x-dataview=full&amp;amp;x-dataview=navigation&amp;amp;x-context=',
                    $x-context) else "" let $rf-next-ref:= if (exists($rf-next)) then
                    concat('?operation=searchRetrieve&amp;amp;query=',
                    $config:INDEX_INTERNAL_RESOURCEFRAGMENT, '="',
                    xmldb:encode-uri($rf-next/data(@ID)),
                    '"&amp;amp;x-dataview=full&amp;amp;x-dataview=navigation&amp;amp;x-context=',
                    $x-context) else "" return (&lt;fcs:ResourceFragment type="prev"
                    pid="{$rf-prev/data(@ID)}" ref="{$rf-prev-ref}" label="{$rf-prev/data(@LABEL)}"
                    /&gt;, &lt;fcs:ResourceFragment type="next" pid="{$rf-next/data(@ID)}"
                    ref="{$rf-next-ref}" label="{$rf-next/data(@LABEL)}" /&gt;) else () let $dv-facs
                    := if (contains($data-view,'facs')) then (: let $facs-uri:=fcs:apply-index
                    ($record-data-input, "facs-uri",$x-context, $config):) let $facs-uri :=
                    facs:get-url($resourcefragment-pid, $resource-pid, $project-id) return
                    &lt;fcs:DataView type="facs" ref="{$facs-uri[1]}"/&gt; else () let $dv-title :=
                    let $title_ := if (exists($title) and not($title='')) then $title else
                    $res-entry/data(@LABEL)||", "||$rf-entry/data(@LABEL) return &lt;fcs:DataView
                    type="title"&gt;{$title_[1]}&lt;/fcs:DataView&gt; let $dv-xmlescaped := if
                    (contains($data-view,'xmlescaped')) then &lt;fcs:DataView
                    type="xmlescaped"&gt;{util:serialize($record-data,'method=xml,
                    indent=yes')}&lt;/fcs:DataView&gt; else () (:return if ($data-view = 'raw') then
                    $record-data else &lt;fcs:Resource pid="{$resource-pid}"&gt;
                    &lt;fcs:ResourceFragment pid="{$resourcefragment-pid}"
                    ref="{$resourcefragment-ref}"&gt;{ ($dv-title, $kwic, if ('full' = $data-view or
                    not(exists($kwic))) then &lt;fcs:DataView
                    type="full"&gt;{$record-data}&lt;/fcs:DataView&gt; else ()
                    )}&lt;/fcs:ResourceFragment&gt; {$dv-navigation} &lt;/fcs:Resource&gt;:) (: case
                    "full" return util:expand($record-data):) return if ($data-view = "raw") then
                    $record-data else &lt;fcs:Resource pid="{$resource-pid}"&gt;
                    &lt;fcs:ResourceFragment pid="{$resourcefragment-pid}"
                    ref="{$resourcefragment-ref}"&gt;{ for $d in tokenize($data-view,',\s*') return
                    let $data:= switch ($d) (: case "full" return $rf[1]/*:) case "full" return
                    $record-data[1]/* case "facs" return $dv-facs case "title" return $dv-title case
                    "kwic" return $kwic case "navigation" return $dv-navigation case "xmlescaped"
                    return $dv-xmlescaped default return () return if ($data instance of
                    element(fcs:DataView)) then $data else &lt;fcs:DataView
                    type="{$d}"&gt;{$data}&lt;/fcs:DataView&gt; }&lt;/fcs:ResourceFragment&gt;
                    &lt;/fcs:Resource&gt; }; declare function fcs:get-pid($mdRecord as element()) {
                    let $log := util:log("INFO",name($mdRecord)) return switch (name($mdRecord))
                    case "teiHeader" return $mdRecord//(idno|tei:idno)[@type='cr-xq']/xs:string(.)
                    case "cmdi" return () default return () }; (: daniel 2013-06-19 added
                    ignore-base-elem processing :) (:~ This expects a CQL-query that it translates
                    to XPath It relies on the external cqlparser-module, that delivers the query in
                    XCQL-format (parse-tree of the query as XML) and then applies a stylesheet
                    @params $x-context identifier of a resource/collection @returns XPath version of
                    the CQL-query, or diagnostics bubbling up the call-chain if parse-error! :)
                    declare function fcs:transform-query($cql-query as xs:string, $x-context as
                    xs:string, $config, $ignore-base-element as xs:boolean) as item() { let
                    $mappings := config:mappings($x-context), $log := util:log("INFO",$mappings),
                    $xpath-query := cql:cql2xpath($cql-query, $x-context, $mappings), $return_match
                    := let $indexes:= for $key in cql:cql-to-xcql($cql-query)//searchClause/index
                    return if (exists($mappings)) then $mappings//index[@key eq
                    $key]/@return_match='true' else false() let
                    $some_index_requires_existMatch:=some $x in $indexes satisfies $x=true() return
                    $some_index_requires_existMatch (: ignore base_elem if any of the indexes we
                    search in requires this by having @ignore_base_elem='true' on its definition :)
                    let $ignore_base_elem := let $indexes:= for $key in
                    cql:cql-to-xcql($cql-query)//searchClause/index return if (exists($mappings))
                    then $mappings//index[@key eq $key]/(@ignore_base_elem='true' or
                    @return_match='true') else false() let $some_index_requires_ignore:=some $x in
                    $indexes satisfies $x=true() return $some_index_requires_ignore (: if there was
                    a problem with the parsing the query don't evaluate :) let $final-xpath :=
                    switch(true()) case $return_match return
                    "util:expand("||$xpath-query||")//exist:match" case ($ignore-base-element and
                    ($xpath-query instance of text() or $xpath-query instance of xs:string) and
                    not($ignore_base_elem)) return let $context-map :=
                    fcs:get-mapping("",$x-context, $config), $default-mappings :=
                    fcs:get-mapping("", 'default', $config ) (: $index-map :=
                    $context-map/index[xs:string(@key) eq $index], (\: get either a) the specific
                    base-element for the index, b) the default for given map, c) the index itself
                    :\) $base-elem := if (exists($index-map/@base_elem)) then
                    xs:string($index-map/@base_elem) else if (exists($context-map/@base_elem)) then
                    xs:string($context-map/@base_elem) else $index:) (:$base-elem := if
                    (exists($context-map[@base_elem])) then if (not($context-map/@base_elem=''))
                    then concat('ancestor-or-self::', $context-map/@base_elem) else '.' else if
                    (exists($default-mappings[@base_elem])) then concat('ancestor-or-self::',
                    $default-mappings/@base_elem) else '.' return concat($xpath-query,'/',
                    $base-elem):) let
                    $base-elem-xpath:=fcs:base-element-to-xpath($cql-query,$x-context,$config,$ignore-base-element)
                    return $xpath-query||'/'||$base-elem-xpath default return $xpath-query return
                    $final-xpath }; (: daniel 2013-06-19: moved base-element-generation out into its
                    own function :) declare function fcs:base-element-to-xpath($cql-query as
                    xs:string, $x-context as xs:string, $config, $ignore-base-element as xs:boolean)
                    as xs:string? { let $context-map := fcs:get-mapping("",$x-context, $config),
                    $default-mappings := fcs:get-mapping("", 'default', $config ) (: daniel
                    2013-06-12 added parse functionality for map/@base_elem so that we can have -
                    @base_elem='p' - @base_elem='(p|l)' - @base_elem='fn:function(.)' :) let
                    $base-elem := if (exists($context-map[@base_elem])) then if
                    (not($context-map/@base_elem='')) then $context-map/@base_elem else '.' else if
                    (exists($default-mappings[@base_elem])) then $default-mappings/@base_elem else
                    '.' let $relativeStep := 'ancestor-or-self::' let $base-elem-isUnion :=
                    matches($base-elem,'^\(.+\|.+\)$') let $base-elem-isFunction :=
                    matches(replace($base-elem,'\[.*\]',''),'^(\D[\p{L}\p{P}]*:)?(\D[\p{L}\p{P}]+)\(.*\)')
                    let $return:= switch(true()) case $base-elem-isFunction return $base-elem case
                    $base-elem-isUnion return
                    "("||string-join(tokenize(replace($base-elem,'[\(\)]',''),'\|')!concat($relativeStep,.),'|')||")"
                    default return if ($base-elem = '.') then $base-elem else
                    $relativeStep||$base-elem return $return }; (: old version, "manually" parsing
                    the cql-string it accepted/understood: term index=term index relation term :)
                    declare function fcs:transform-query-old($cql-query as xs:string, $x-context as
                    xs:string, $type as xs:string, $config ) as xs:string { let $query-constituents
                    := if (contains($cql-query,'=')) then tokenize($cql-query, "=") else
                    tokenize($cql-query, " ") let $index := if ($type eq 'scan' or
                    count($query-constituents)&gt;1 ) then $query-constituents[1] else
                    "cql.serverChoice" let $searchTerm := if (count($query-constituents)=1) then
                    $cql-query else if (count($query-constituents)=2) then (: tokenized with '=' :)
                    normalize-space($query-constituents[2]) else $query-constituents[3] (: try to
                    get a mapping specific to given context, else take the default :) let
                    $context-map := fcs:get-mapping("",$x-context, $config), (: TODO: for every
                    index in $xcql :) (: try to get a) a mapping for given index within the
                    context-map, b) in any of the mapping (if not found in the context-map) , -
                    potentially dangerous!! c) or else take the index itself :) $mappings :=
                    doc(repo-utils:config-value($config, 'mappings')), $index-map :=
                    $context-map/index[xs:string(@key) eq $index], $resolved-index := if
                    (exists($index-map)) then $index-map/text() else if
                    (exists($mappings//index[xs:string(@key) eq $index])) then
                    $mappings//index[xs:string(@key) eq $index] else $index , (: get either a) the
                    specific base-element for the index, b) the default for given map, c) the index
                    itself :) $base-elem := if (exists($index-map/@base_elem)) then
                    xs:string($index-map/@base_elem) else if (exists($context-map/@base_elem)) then
                    xs:string($context-map/@base_elem) else $index, (: &lt;index
                    status="indexed"&gt; - flag to know if ft-indexes can be used. TODO?: should be
                    checked against the actual index-configuration :) $indexed :=
                    (xs:string($index-map/@status) eq 'indexed'), $match-on := if
                    (exists($index-map/@use) ) then xs:string($index-map/@use) else '.' let $res :=
                    if ($type eq 'scan') then concat("//", $resolved-index, if ($match-on ne '.')
                    then concat("/", $match-on) else '') else concat("//", $resolved-index, "[", if
                    ($indexed) then concat("ft:query(", $match-on,
                    ",&lt;term&gt;",translate($searchTerm,'"',''), "&lt;/term&gt;)") else
                    concat("contains(", $match-on, ",'", translate($searchTerm,'"',''), "')") , "]",
                    "/ancestor-or-self::", $base-elem) return $res }; (:~ gets the mapping-entry for
                    the index first tries a mapping within given context, then tries defaults. if
                    $index-param = "" return the map-element, else - if found - return the
                    index-element :) declare function fcs:get-mapping($index as xs:string,
                    $x-context as xs:string+, $config) { let $mappings := typeswitch($config) case
                    element() return config:param-value(map{"config":=$config}, 'mappings') case
                    map() return config:param-value($config, 'mappings') default return
                    $config[descendant-or-self::map], $context-map := if (exists($mappings//map[@key
                    = $x-context])) then $mappings//map[@key = $x-context] (: else
                    $mappings//map[xs:string(@key) = 'default'],:) (: if not specific mapping found
                    for given context, use whole mappings-file :) else $mappings, $context-index :=
                    $context-map/index[@key eq $index], $default-index := $mappings//map[@key =
                    'default']/index[@key eq $index] return if ($index eq '') then $context-map else
                    if (exists($context-index)) then $context-index else if (exists($default-index))
                    then $default-index else (: if no contextual index, dare to take any index - may
                    be dangerous! :) let $any-index := $mappings//index[xs:string(@key) eq $index]
                    return $any-index }; declare function fcs:indexes-in-query($cql as xs:string,
                    $x-context as xs:string+, $config) as node()* { let $xcql :=
                    cql:cql-to-xcql($cql) let $indexes := for $ix in
                    $xcql//index[not(ancestor::sortKeys)] return fcs:get-mapping($ix, $x-context,
                    $config) return $indexes }; declare function
                    fcs:declare-index-function($x-context, $index-name, $config) as xs:string?{ let
                    $index-as-xpath:=fcs:index-as-xpath($index-name,$x-context, $config) return
                    "declare function "||$x-context||":"||$index-name||"($data) as item()*
                    {&amp;#10;"|| "&amp;#09;$data//"||$index-as-xpath||"&amp;#10;"||
                    "};&amp;#10;&amp;#10;" }; declare function
                    fcs:store-project-index-functions($x-context) { let $preamble:="xquery version
                    '3.0';", $namespace:="module namespace
                    "||$x-context||"="||$fcs:project-index-functions-ns-base-uri||$x-context||"';"
                    let $config:= map{"config":=config:project-config($x-context)}, $mappings:=
                    config:param-value($config,'mappings') let $defs:= for $index in
                    $mappings//index return
                    fcs:declare-index-function($x-context,$index/@key,$config) let $path:=
                    $config:modules-dir||"index-functions/", $resource:= $x-context||".xqm",
                    $store:= xmldb:store($path, $resource,
                    string-join(($preamble,$namespace,$defs),'&amp;#10;&amp;#10;'),
                    'application/xquery'), $chmod:= if ($store!='') then
                    xmldb:set-resource-permissions($path,$resource,$x-context,$x-context,util:base-to-integer(0755,
                    8)) else () return exists($chmod) }; declare function
                    fcs:import-project-index-functions($x-context) {
                    util:import-module(xs:anyURI($fcs:project-index-functions-ns-base-uri||$x-context),$x-context,xs:anyURI($config:modules-dir||"index-functions/"||$x-context||".xqm"))
                    }; (:~ TO BE DEPRECATED BY index:apply-index() evaluate given index on given
                    piece of data used when formatting record-data, to put selected pieces of data
                    (indexes) into the results record @returns result of evaluating given index's
                    path on given data. or empty node if no mapping index was found :) declare
                    function fcs:apply-index($data, $index as xs:string, $x-context as xs:string+,
                    $config) as item()* { let $index-map := fcs:get-mapping($index,$x-context,
                    $config), $index-xpath := fcs:index-as-xpath($index,$x-context, $config) (:
                    $match-on := if (exists($index-map/@use) ) then concat('/',
                    xs:string($index-map[1]/@use)) else '' , $match-on:) return if
                    (exists($index-map/path/text())) then let
                    $plain-eval:=util:eval("$data//"||$index-xpath) return if (exists($plain-eval))
                    then $plain-eval else util:eval("util:expand($data)//"||$index-xpath) else () };
                    declare function fcs:apply-index($data, $index as xs:string, $x-context as
                    xs:string+) as item()* { let $project-config:= project:get($x-context) return
                    fcs:apply-index($data,$index,$x-context,$project-config) }; (:~ TO BE DEPRECATED
                    BY index:index-as-xpath() gets the mapping for the index and creates an xpath
                    (UNION) FIXME: takes just first @use-param - this prevents from creating invalid
                    xpath, but is very unreliable wrt to the returned data also tried to make a
                    union but problems with values like: 'xs:string(@value)' (union operand is not a
                    node sequence [source: String]) @param $index index-key as known to mappings
                    @returns xpath-equivalent of given index as defined in mappings; multiple xpaths
                    are translated to a UNION, value of @use-attribute is also attached; if no
                    mapping found, returns the input-index unchanged :) declare function
                    fcs:index-as-xpath($index as xs:string, $x-context as xs:string+, $config) as
                    xs:string { let $index-map := fcs:get-mapping($index, $x-context, $config)
                    return if (exists($index-map)) then (: let $match-on := if
                    (exists($index-map/@use) ) then if (count($index-map/@use) &gt; 1) then
                    concat('/(', string-join($index-map/@use,'|'),')') else concat('/',
                    xs:string($index-map/@use)) else '' :) let $match-on := if
                    (exists($index-map/@use) ) then concat('/', xs:string($index-map[1]/@use)) else
                    '' let $paths := $index-map/path[not(@type) or xs:string(@type)='key'] (: let
                    $paths := $index-map/path:) let $indexes := if (count($paths) &gt; 1) then
                    translate(concat('(', string-join($paths ,'|'),')', $match-on),'.','/') else
                    translate(concat($paths, $match-on),'.','/') return $indexes else $index }; (:~
                    this is to mark matched-element, even if usual index-matching-mechanism fails
                    (which is when matching on attributes) :) declare function
                    fcs:highlight-result($result as node()*, $match as node()*, $x-context as
                    xs:string+, $config) as item()* { let $default-expand := util:expand($result) (:
                    let $indexes := fcs:indexes-in-query($query, $x-context, $config):) (: if the
                    kwic-module already did its work, just give that back, else use the custom
                    highlighting:) (:problematic performance:) let $processed-result := if
                    (exists($default-expand//exist:match)) then $default-expand else
                    fcs:process-result($result, $match) (: do-nothing pass-through variant :) (: let
                    $processed-result := $default-expand :) (: else :) (:
                    "highlight-matches=elements"):) return $processed-result }; (:~ this is to mark
                    matched element, even if usual index-matching-mechanism fails (which is when
                    matching on attributes) it recursively processes the result and sets a
                    &lt;exist:match&gt; element (-a-r-o-u-n-d) INSIDE the matching elements (because
                    it is important for the further processing to keep the matching element) it
                    still strips the inner elements (descendants) and only leaves the .//text() .
                    @param $result the result containing the matched elements, but somewhere inside
                    the ancestors (base-elem) @param $matching the list of directly matched
                    elements, that are contained in the $result somewhere :) declare function
                    fcs:process-result($result as node()*, $matching as node()*) as item()* { for
                    $node in $result return typeswitch ($node) case text() return $node case
                    comment() return $node (:case element() return if ($node = $matching) then
                    &lt;exist:match&gt;{fcs:process-result-default($node, $matching
                    )}&lt;/exist:match&gt;:) case element() return if ($node = $matching) then
                    element {node-name($node)} {$node/@*,
                    &lt;exist:match&gt;{string-join($node//text(), ' ')}&lt;/exist:match&gt;} else
                    fcs:process-result-default($node, $matching ) default return
                    fcs:process-result-default($node, $matching ) (:namespace
                    prefix-from-QName($node/name()) {$node/namespace-uri()} ,:) }; declare function
                    fcs:process-result-default($node as node(), $matching as node()*) as item()* {
                    element {node-name($node)} {($node/@*, fcs:process-result($node/node(),
                    $matching))} (: namespace {$node/namespace-uri()}, :) (: &lt;div
                    class="default"&gt;{$node/name()} &lt;/div&gt; :) }; (:~ dynamically sort result
                    based on query (CQL: sortBy clause) or default sorting defined in mappings if
                    unable to find any sorting index, return the result as is. &lt;sortKeys&gt;
                    &lt;key&gt; &lt;index&gt;dc.date&lt;/index&gt; &lt;modifiers&gt;
                    &lt;modifier&gt; &lt;type&gt;sort.descending&lt;/type&gt; &lt;/modifier&gt;
                    &lt;/modifiers&gt; &lt;/key&gt; &lt;key&gt; &lt;index&gt;dc.title&lt;/index&gt;
                    &lt;modifiers&gt; &lt;modifier&gt; &lt;type&gt;sort.ascending&lt;/type&gt;
                    &lt;/modifier&gt; &lt;/modifiers&gt; &lt;/key&gt; &lt;/sortKeys&gt; :) declare
                    function fcs:sort-result($result as node()*, $cql as xs:string, $x-context as
                    xs:string+, $config) as item()* { let $xcql := cql:cql-to-xcql($cql) let
                    $indexes := if (exists($xcql//sortKeys/key/index)) then
                    $xcql//sortKeys/key/index else let $context-map :=
                    fcs:get-mapping("",$x-context, $config) return if (exists($context-map/@sort))
                    then $context-map/@sort else () let $xpaths := for $ix in $indexes return
                    fcs:index-as-xpath($ix,$x-context, $config ) let $sorting-expression :=
                    string-join(("for $rec in $result order by ", for $index at $pos in $xpaths let
                    $modifier := substring-after
                    ($indexes[position()=$pos]/following-sibling::modifiers/modifier/type, 'sort.')
                    return ("$rec//", $index, " ", $modifier, if ($pos = count($xpaths)) then ''
                    else ', '), " return $rec" ), '') return if (count($indexes) = 0) then $result
                    else util:eval($sorting-expression) (: else $sorting-expression:) }; declare
                    function fcs:highlight-matches-in-copy($copy as element()+, $ids as xs:string*)
                    as element()+ { let $stylesheet-file := "highlight-matches.xsl", $stylesheet:=
                    doc($stylesheet-file), $params := &lt;parameters&gt;&lt;param name="cr-ids"
                    value="{string-join($ids,',')}"&gt;&lt;/param&gt;&lt;/parameters&gt; return if
                    (exists($stylesheet)) then for $c in $copy return
                    transform:transform($copy,$stylesheet,$params) else util:log("ERROR","stylesheet
                    "||$stylesheet-file||" not available.") }; </f>
                <f n="generate-index-functions.xql">xquery version "3.0";&#xd; &#xd; (:~&#xd; : This
                    is a proof-of-concept script which takes a cr-xq map&#xd; : element and
                    generates a xql module with getter-functions for &#xd; : the indexes declared in
                    it.&#xd; : could be used as a trigger target.&#xd; ~:)&#xd; &#xd; import module
                    namespace config="http://exist-db.org/xquery/apps/config" at
                    "../../core/config.xqm";&#xd; &#xd; import module namespace fcs =
                    "http://clarin.eu/fcs/1.0" at "../fcs/fcs.xqm";&#xd; &#xd; declare variable
                    $PARAMETER_MISSING := QName("http://exist-db.org/xquery/templates", "Parameter
                    was not supplied.");&#xd; &#xd; declare variable $config:app-root external;&#xd;
                    &#xd; declare variable $local:preamble:="xquery version '3.0';";&#xd; &#xd;
                    declare variable
                    $local:prefix:=replace(request:get-parameter("project",""),'','');&#xd; &#xd;
                    declare function local:declare-index-function($index-name, $config) as
                    xs:string?{&#xd; &#xd; "declare function
                    "||$local:prefix||":get-"||$index-name||"($data) as item()* {&amp;#10;"||&#xd;
                    "&amp;#09;$data//"||fcs:index-as-xpath($index-name,$local:prefix,
                    $config)||"&amp;#10;"||&#xd; "};&amp;#10;&amp;#10;"&#xd; };&#xd; &#xd; &#xd; if
                    ($local:prefix!='')&#xd; then&#xd; let $config:=
                    config:config($local:prefix),&#xd; $mappings:= fcs:get-mapping('',
                    $local:prefix,$config)&#xd; let $defs:= for $index in $mappings//index return
                    local:declare-index-function($index/@key,$config),&#xd; $path:=
                    $app:root||'/modules/index-functions/',&#xd; $resource:=
                    $local:prefix||".xqm"&#xd; let $store:= xmldb:store($path, $resource,
                    string-join(($local:preamble,$defs),'&amp;#10;&amp;#10;'),
                    'application/xquery')&#xd; let $exec:= xmldb:set-resource-permissions($path,
                    $resource, 'guest', 'guest', '755')&#xd; return $exec!=''&#xd; else &#xd;
                    error($PREFIX_MISSING,'parameter $project is empty')</f>
            </d>
            <d n="gendocs">
                <f n="dbutils.xql">xquery version "3.0";&#xd; &#xd; module namespace
                    dbutil="http://exist-db.org/xquery/dbutil";&#xd; &#xd; (:~ Scan a collection
                    tree recursively starting at $root. Call $func once for each collection found
                    :)&#xd; declare function dbutil:scan-collections($root as xs:anyURI, $func as
                    function(xs:anyURI) as item()*) {&#xd; $func($root),&#xd; for $child in
                    xmldb:get-child-collections($root)&#xd; return&#xd;
                    dbutil:scan-collections(xs:anyURI($root || "/" || $child), $func)&#xd; };&#xd;
                    &#xd; (:~&#xd; : List all resources contained in a collection and call the
                    supplied function once for each&#xd; : resource with the complete path to the
                    resource as parameter.&#xd; :)&#xd; declare function
                    dbutil:scan-resources($collection as xs:anyURI, $func as function(xs:anyURI) as
                    item()*) {&#xd; for $child in xmldb:get-child-resources($collection)&#xd;
                    return&#xd; $func(xs:anyURI($collection || "/" || $child))&#xd; };&#xd; &#xd;
                    (:~ &#xd; : Scan a collection tree recursively starting at $root. Call the
                    supplied function once for each&#xd; : resource encountered. The first parameter
                    to $func is the collection URI, the second the resource&#xd; : path (including
                    the collection part).&#xd; :)&#xd; declare function dbutil:scan($root as
                    xs:anyURI, $func as function(xs:anyURI, xs:anyURI?) as item()*) {&#xd;
                    dbutil:scan-collections($root, function($collection as xs:anyURI) {&#xd;
                    $func($collection, ()),&#xd; (: scan-resources expects a function with one
                    parameter, so we use a partial application&#xd; to fill in the collection
                    parameter :)&#xd; dbutil:scan-resources($collection, $func($collection, ?))&#xd;
                    })&#xd; };&#xd; &#xd; declare function dbutil:find-by-mimetype($collection as
                    xs:anyURI, $mimeType as xs:string) {&#xd; dbutil:scan($collection,
                    function($collection, $resource) {&#xd; if (exists($resource) and
                    xmldb:get-mime-type($resource) = $mimeType) then&#xd; $resource&#xd; else&#xd;
                    ()&#xd; })&#xd; };</f>
                <f n="gendocs.xql">&#xd; &#xd; import module namespace
                    docs="http://exist-db.org/xquery/docs" at
                    "/db/apps/sade/modules/gendocs/scan.xql";&#xd; &#xd; &#xd;
                    docs:load-fundocs("/db/apps/sade", "/db/apps/sade/modules/gendocs")&#xd; </f>
                <f n="reindex.xql">xquery version "3.0";&#xd; &#xd; import module namespace
                    docs="http://exist-db.org/xquery/docs" at "scan.xql";&#xd; import module
                    namespace config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd;
                    &#xd; declare option exist:serialize "method=json
                    media-type=application/javascript";&#xd; &#xd; let $isDba :=
                    xmldb:is-admin-user(xmldb:get-current-user())&#xd; return&#xd; if ($isDba)
                    then&#xd; &lt;response status="ok"&gt;&#xd; &lt;message&gt;Scan completed!
                    {docs:load-fundocs($config:app-root)}&lt;/message&gt;&#xd;
                    &lt;/response&gt;&#xd; else&#xd; &lt;response status="failed"&gt;&#xd;
                    &lt;message&gt;You have to be a member of the dba group. Please log in using the
                    dashboard and retry.&lt;/message&gt;&#xd; &lt;/response&gt;</f>
                <f n="scan.xql">xquery version "3.0";&#xd; &#xd; (:~&#xd; : This module is taken
                    from the fundocs-app and slightly adapted, &#xd; : to accept source AND target
                    param, and to only process the local modules (in the $source-collection)&#xd;
                    :)&#xd; &#xd; module namespace docs="http://exist-db.org/xquery/docs";&#xd;
                    &#xd; import module namespace xdb="http://exist-db.org/xquery/xmldb";&#xd;
                    import module namespace xqdm="http://exist-db.org/xquery/xqdoc";&#xd; import
                    module namespace dbutil="http://exist-db.org/xquery/dbutil" at
                    "dbutils.xql";&#xd; import module namespace
                    inspect="http://exist-db.org/xquery/inspection" at
                    "java:org.exist.xquery.functions.inspect.InspectionModule";&#xd; &#xd; declare
                    namespace xqdoc="http://www.xqdoc.org/1.0";&#xd; &#xd; declare %private function
                    docs:create-collection($parent as xs:string, $child as xs:string) as empty()
                    {&#xd; let $null := xdb:create-collection($parent, $child)&#xd; return ()&#xd;
                    };&#xd; &#xd; declare %private function docs:load-external($uri as xs:string,
                    $store as function(xs:string, element()) as empty()) {&#xd; let $xml :=
                    xqdm:scan(xs:anyURI($uri))&#xd; let $moduleURI :=
                    $xml//xqdoc:module/xqdoc:uri&#xd; return&#xd; $store($moduleURI, $xml)&#xd;
                    };&#xd; &#xd; declare %private function docs:load-stored($path as xs:anyURI,
                    $store as function(xs:string, element()) as empty()) {&#xd; let $meta :=
                    inspect:inspect-module($path)&#xd; return&#xd; if ($meta) then&#xd; let $xml :=
                    docs:generate-xqdoc($meta)&#xd; let $moduleURI :=
                    $xml//xqdoc:module/xqdoc:uri&#xd; return&#xd; $store($path, $xml)&#xd; else&#xd;
                    ()&#xd; };&#xd; &#xd; declare %private function
                    docs:load-external-modules($source as xs:string, $store as function(xs:string,
                    element()) as empty()) {&#xd; (:for $uri in util:mapped-modules()&#xd;
                    return&#xd; docs:load-external($uri, $store),:)&#xd; for $path in
                    dbutil:find-by-mimetype(xs:anyURI($source), "application/xquery")&#xd;
                    return&#xd; try {&#xd; docs:load-stored($path, $store)&#xd; } catch * {&#xd; (:
                    Expected to fail if XQuery file is not a library module :)&#xd; ()&#xd; }&#xd;
                    };&#xd; &#xd; declare %private function docs:load-internal-modules($store as
                    function(xs:string, element()) as empty()) {&#xd; for $moduleURI in
                    util:registered-modules()&#xd; let $meta :=
                    inspect:inspect-module-uri($moduleURI)&#xd; return&#xd; if ($meta) then&#xd; let
                    $xml := docs:generate-xqdoc($meta)&#xd; return&#xd; $store($moduleURI,
                    $xml)&#xd; else&#xd; util:log("WARN", "Module not found: " || $moduleURI)&#xd;
                    };&#xd; &#xd; declare function docs:load-fundocs($source as xs:string, $target
                    as xs:string) {&#xd; let $dataColl := xdb:create-collection($target,
                    "data")&#xd; let $store := function($moduleURI as xs:string, $data as element())
                    {&#xd; let $name :=
                    encode-for-uri(translate(replace(replace($moduleURI,'http://',''), $source,
                    ''),'/:','_') ) || ".xml"&#xd; return&#xd; (&#xd; xdb:store($dataColl, $name,
                    $data),&#xd; sm:chmod(xs:anyURI($dataColl || "/" || $name), "rw-rw-r--")&#xd;
                    )[2]&#xd; }&#xd; return (&#xd; (: docs:load-internal-modules($store),:)&#xd;
                    docs:load-external-modules($source, $store)&#xd; )&#xd; };&#xd; &#xd; declare
                    function docs:generate-xqdoc($module as element(module)) {&#xd; &lt;xqdoc:xqdoc
                    xmlns:xqdoc="http://www.xqdoc.org/1.0"&gt;&#xd; &lt;xqdoc:control&gt;&#xd;
                    &lt;xqdoc:date&gt;{current-dateTime()}&lt;/xqdoc:date&gt;&#xd;
                    &lt;xqdoc:location&gt;{$module/@location/string()}&lt;/xqdoc:location&gt;&#xd;
                    &lt;/xqdoc:control&gt;&#xd; &lt;xqdoc:module type="library"&gt;&#xd;
                    &lt;xqdoc:uri&gt;{$module/@uri/string()}&lt;/xqdoc:uri&gt;&#xd;
                    &lt;xqdoc:name&gt;{$module/@prefix/string()}&lt;/xqdoc:name&gt;&#xd;
                    &lt;xqdoc:comment&gt;&#xd;
                    &lt;xqdoc:description&gt;{$module/description/string()}&lt;/xqdoc:description&gt;&#xd;
                    {&#xd; if ($module/version) then&#xd;
                    &lt;xqdoc:version&gt;{$module/version/string()}&lt;/xqdoc:version&gt;&#xd;
                    else&#xd; ()&#xd; }&#xd; {&#xd; if ($module/author) then&#xd;
                    &lt;xqdoc:author&gt;{$module/author/string()}&lt;/xqdoc:author&gt;&#xd;
                    else&#xd; ()&#xd; }&#xd; &lt;/xqdoc:comment&gt;&#xd; &lt;/xqdoc:module&gt;&#xd;
                    &lt;xqdoc:functions&gt;&#xd; {&#xd; for $func in $module/function&#xd;
                    return&#xd; &lt;xqdoc:function&gt;&#xd;
                    &lt;xqdoc:name&gt;{$func/@name/string()}&lt;/xqdoc:name&gt;&#xd;
                    &lt;xqdoc:signature&gt;{docs:generate-signature($func)}&lt;/xqdoc:signature&gt;&#xd;
                    &lt;xqdoc:comment&gt;&#xd;
                    &lt;xqdoc:description&gt;{$func/description/string()}&lt;/xqdoc:description&gt;&#xd;
                    {&#xd; for $param in $func/argument&#xd; return&#xd;
                    &lt;xqdoc:param&gt;${$param/@var/string()}{docs:cardinality($param/@cardinality)}{"
                    "}{$param/text()}&lt;/xqdoc:param&gt;&#xd; }&#xd;
                    &lt;xqdoc:return&gt;{$func/returns/@type/string()}{docs:cardinality($func/returns/@cardinality)}
                    - {$func/returns/text()}&lt;/xqdoc:return&gt;&#xd; {&#xd; if ($func/deprecated)
                    then&#xd;
                    &lt;xqdoc:deprecated&gt;{$func/deprecated/string()}&lt;/xqdoc:deprecated&gt;&#xd;
                    else&#xd; ()&#xd; } &#xd; &lt;/xqdoc:comment&gt;&#xd;
                    &lt;/xqdoc:function&gt;&#xd; }&#xd; &lt;/xqdoc:functions&gt;&#xd;
                    &lt;/xqdoc:xqdoc&gt;&#xd; };&#xd; &#xd; declare function
                    docs:cardinality($cardinality as xs:string) {&#xd; switch ($cardinality)&#xd;
                    case "zero or one" return "?"&#xd; case "zero or more" return "*"&#xd; case "one
                    or more" return "+"&#xd; default return ()&#xd; };&#xd; &#xd; declare function
                    docs:generate-signature($func as element(function)) {&#xd; $func/@name/string()
                    || "(" ||&#xd; string-join(&#xd; for $param in $func/argument&#xd; return&#xd;
                    "$" || $param/@var/string() || docs:cardinality($param/@cardinality) || " as "
                    || $param/@type/string(),&#xd; ", "&#xd; ) || &#xd; ")" || " as " ||
                    $func/returns/@type/string() ||
                    docs:cardinality($func/returns/@cardinality)&#xd; };</f>
            </d>
            <d n="get">
                <f n="get.xql">xquery version "3.0";&#xd; &#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace viewer =
                    "http://sade/viewer" at "viewer.xqm" ;&#xd; &#xd; let $project :=
                    request:get-parameter("project","")&#xd; &#xd; let $config-map :=
                    config:config-map($project) &#xd; &#xd; (:~ process the relative path; expecting
                    one or two components:&#xd; first component $id, second optional: $type :)&#xd;
                    let $path := request:get-parameter("rel-path",""),&#xd; $path-components :=
                    tokenize($path,'/')[.!='' and .!="get"]&#xd; &#xd; (:~ $id of a project,
                    resource or resourcefragment :)&#xd; (: if the 1st path component is already a
                    type keyword, the user asks for the whole project:)&#xd; let $id := if
                    ($path-components[1] = ("data","metadata", "entry"))&#xd; then $project&#xd;
                    else $path-components[1]&#xd; &#xd; let $parse-id :=
                    repo-utils:parse-x-context($id,$config-map)&#xd; &#xd; (:~ @param $type 'data' |
                    'entry' | 'metadata' ; default: 'entry' :)&#xd; let $type := &#xd; if ($id =
                    $project)&#xd; then ($path-components[1],'entry')[1]&#xd; else
                    ($path-components[2],'entry')[1],&#xd; $subtype := &#xd; if ($id =
                    $project)&#xd; then $path-components[2]&#xd; else $path-components[3]&#xd; &#xd;
                    (: content negotiation&#xd; text/html -&gt; human readable &#xd;
                    application/x-cmdi+xml -&gt; machine processable &#xd; @seeAlso
                    http://www.clarin.eu/sites/default/files/CE-2013-0106-pid-task-force.pdf&#xd;
                    :)&#xd; let $header-accept := request:get-header("Accept")&#xd; let
                    $accept-format := if (contains($header-accept,'text/html')) then "htmlpage" else
                    "xml" &#xd; let $format := (request:get-parameter("x-format",if ($type = "data")
                    then "xml" else $accept-format))[1]&#xd; (:return
                    &lt;debug&gt;{$header-accept||" -- format: "||$format}&lt;/debug&gt;:)&#xd; let
                    $debug := &lt;a&gt;&#xd; &lt;path-components&gt;{&#xd; for $c at $pos in
                    $path-components &#xd; return &lt;path-component
                    n="{$pos}"&gt;{$path-components[$pos]}&lt;/path-component&gt;&#xd;
                    }&lt;/path-components&gt;&#xd; &lt;project&gt;{$project}&lt;/project&gt;&#xd;
                    &lt;id&gt;{$id}&lt;/id&gt;&#xd; &lt;type&gt;{$type}&lt;/type&gt;&#xd;
                    &lt;subtype&gt;{$subtype}&lt;/subtype&gt;&#xd;
                    &lt;format&gt;{$format}&lt;/format&gt;&#xd; &lt;context-parsed&gt;{for $i in
                    $parse-id return for $k in map:keys($i) return
                    $k||":"||map:get($i,$k)}&lt;/context-parsed&gt; &#xd; &lt;/a&gt;&#xd; let $log
                    := util:log-app("INFO",$config:app-name,$debug)&#xd; return
                    viewer:display($config-map, $id, map:get($parse-id[1],"project-pid"), $type,
                    $subtype, $format)</f>
                <f n="viewer.xqm">xquery version "3.0";&#xd; &#xd; module namespace viewer =
                    "http://sade/viewer" ;&#xd; declare namespace
                    templates="http://exist-db.org/xquery/templates";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace cr =
                    "http://aac.ac.at/content_repository" at "../../core/cr.xqm";&#xd; import module
                    namespace resource = "http://aac.ac.at/content_repository/resource" at
                    "../resource/resource.xqm";&#xd; import module namespace project =
                    "http://aac.ac.at/content_repository/project" at "../resource/project.xqm";&#xd;
                    (:declare namespace tei = "http://www.tei-c.org/ns/1.0" ;:)&#xd; &#xd; (:~
                    default viewer, fetching data, transforming with xslt &#xd; based on text-viewer
                    &#xd; relies to get the data-fragments on (the new) cr or resource modules&#xd;
                    :)&#xd; &#xd; (: moved to resource-module &#xd; declare function viewer:get
                    ($config-map, $id as xs:string) {&#xd; &#xd; let $data-dir :=
                    config:param-value($config-map, 'data-dir'),&#xd; $metadata-dir :=
                    config:param-value($config-map, 'metadata-path'),&#xd; $resource-id :=
                    collection($data-dir)//*[@xml:id eq $id],&#xd; $resource := if
                    (exists($resource-id)) then $resource-id&#xd; else if
                    (doc-available(concat($data-dir, '/', $id))) then&#xd; doc(concat($data-dir,
                    '/', $id))&#xd; else if (doc-available(concat($metadata-dir, '/', $id)))
                    then&#xd; doc(concat($metadata-dir, '/', $id))&#xd; else ()&#xd; &#xd; &#xd;
                    return if (exists($resource)) then $resource &#xd; else
                    &lt;diagnostics&gt;&lt;message&gt;Resource unavailable, id: { ($data-dir, $id) }
                    &lt;/message&gt;&lt;/diagnostics&gt; &#xd; &#xd; };&#xd; :)&#xd; declare
                    function viewer:display($config-map, $id as xs:string, $project as xs:string,
                    $type as xs:string, $format as xs:string) as item()* {&#xd;
                    viewer:display($config-map,$id,$project,$type,(),$format)&#xd; };&#xd; &#xd;
                    declare function viewer:display($config-map, $id as xs:string, $project as
                    xs:string, $type as xs:string, $subtype as xs:string?, $format as xs:string) as
                    item()* { &#xd; (:let $debug := &#xd; let $d :=
                    &lt;debug&gt;&lt;id&gt;{$id}&lt;/id&gt;&lt;project&gt;{$project}&lt;/project&gt;&lt;type&gt;{$type}&lt;/type&gt;&lt;subtype&gt;{$subtype}&lt;/subtype&gt;&lt;format&gt;{$format}&lt;/format&gt;&lt;/debug&gt;&#xd;
                    return util:log-app("INFO",$config:app-name,$d):)&#xd; &#xd; let $data := &#xd;
                    switch ($type)&#xd; case 'data' return &#xd; if ($id = $project)&#xd; then () (:
                    we don't want to return the whole data of a proejct ... :)&#xd; else
                    cr:resolve-id-to-data($id,false())&#xd; case 'metadata' return&#xd; if ($id =
                    $project)&#xd; then project:dmd($project) (: projects currently only have CMDI
                    metadata :)&#xd; else &#xd; if ($subtype!='')&#xd; then
                    resource:dmd-from-id($subtype, $id, $project)&#xd; else
                    resource:dmd-from-id($id, $project)&#xd; default return
                    cr:resolve-id-to-entry($id)&#xd; &#xd; (: let $params := &lt;parameters&gt;&#xd;
                    &lt;param name="format" value="{$format}"/&gt;&#xd; &lt;param name="base_url"
                    value="{config:param-value($config-map,'base-url')}"/&gt;&#xd; &#xd;
                    &lt;/parameters&gt;&#xd; :)(: modules/shared/scripts:)&#xd; (:&lt;param
                    name="base_url" value="{repo-utils:base-url($config)}"/&gt;:)&#xd; &#xd; return
                    if ($format='xml') then&#xd; $data&#xd; else repo-utils:serialise-as($data,
                    $format, $type, $config-map, ()) &#xd; (:&lt;div class="templates:init"&gt;&#xd;
                    &lt;div
                    class="templates:surround?with=page.html&amp;amp;at=content-container"&gt;&#xd;
                    { repo-utils:serialise-as($data, $format, 'cr-data', $config-map, ()) }&#xd;
                    &lt;/div&gt;&#xd; &lt;/div&gt;:)&#xd; &#xd; &#xd; (: let $divID :=
                    $node/xs:string(@id)&#xd; let $config :=
                    local:readConfig()("config")//*[@name="text-viewer"][@container=$divID]&#xd;
                    &#xd; (\: Projektkonfiguration auslesen :\)&#xd; let $collection_path :=
                    $config/param[@name="collection_path"]/xs:string(@value)&#xd; let $xpath :=
                    $config/param[@name="xpath"]/xs:string(@value)&#xd; let $xslt_path :=
                    $config/param[@name="xslt_path"]/xs:string(@value)&#xd; &#xd; (\: Geamtanzahl
                    der referenzierten Elemente feststellen :\)&#xd; let $totalNr :=
                    util:eval(concat("count(collection('",$collection_path,"')",$xpath,")"))&#xd;
                    &#xd; (\: XML-Fragment aus DB holen und transformieren :\)&#xd; let $xsl := if
                    ($xslt_path = () or $xslt_path = "" or $xslt_path = "tei") then
                    doc("resources/tei/stylesheet/xhtml2/tei.xsl")&#xd; else doc($xslt_path)&#xd;
                    let $fragment :=
                    util:eval(concat("collection('",$collection_path,"')",$xpath,"[",$position,"]"))
                    &#xd; let $html := transform:transform($fragment, $xsl, ()) &#xd; &#xd; (\:
                    Navigation bauen :\)&#xd; let $navbar := text-viewer:getNavBar($position, "",
                    $totalNr)&#xd; &#xd; return &lt;div&gt;Brieftext: {$navbar,
                    $html}&lt;/div&gt;&#xd; :)&#xd; &#xd; };&#xd; &#xd; </f>
            </d>
            <d n="index-functions">
                <f n="abacus.xqm">xquery version '3.0';&#xd; &#xd; module namespace
                    abacus=http://aac.ac.at/content-repository/projects-index-functions/abacus';&#xd;
                    &#xd; declare function abacus:resource-pid($data) as item()* {&#xd;
                    $data//'abacus'&#xd; };&#xd; &#xd; &#xd; &#xd; declare function
                    abacus:resourcefragment-pid($data) as item()* {&#xd;
                    $data//(tei:pb|pb)/@facs&#xd; };&#xd; &#xd; &#xd; &#xd; declare function
                    abacus:facs-uri($data) as item()* {&#xd;
                    $data//(tei:pb|pb)/facs:filename-to-path(@facs,'abacus')&#xd; };&#xd; &#xd;
                    &#xd; &#xd; declare function abacus:title($data) as item()* {&#xd;
                    $data//(tei:pb|pb)[1]/(@facs|@n|@xml:id)[1]&#xd; };&#xd; &#xd; &#xd; &#xd;
                    declare function abacus:cql.serverChoice($data) as item()* {&#xd;
                    $data//tei:div[@type='page']&#xd; };&#xd; &#xd; &#xd; &#xd; declare function
                    abacus:ref($data) as item()* {&#xd; $data//rs&#xd; };&#xd; &#xd; &#xd; &#xd;
                    declare function abacus:rs-type($data) as item()* {&#xd; $data//rs/@type&#xd;
                    };&#xd; &#xd; &#xd; &#xd; declare function abacus:rs-subtype($data) as item()*
                    {&#xd; $data//rs/@subtype&#xd; };&#xd; &#xd; &#xd; &#xd; declare function
                    abacus:rs-typesubtype($data) as item()* {&#xd; $data//rs/concat(@type,'-',
                    @subtype)&#xd; };&#xd; &#xd; &#xd; &#xd; declare function abacus:lemma($data) as
                    item()* {&#xd; $data//(tei:w/@lemma|w/@lemma)//&#xd; };&#xd; &#xd; &#xd; &#xd;
                    declare function abacus:pos($data) as item()* {&#xd; $data//w/@type&#xd; };&#xd;
                    &#xd; </f>
            </d>
            <d n="navigation">
                <f n="navigation.xqm">module namespace navi = "http://sade/navigation" ; declare
                    namespace sade = "http://sade"; (: create a navigation :) declare function
                    navi:create($projectname as xs:string, $uri as xs:string, $container as
                    xs:string) as node(){ let $conf := doc(concat("/db/sade/projects/",
                    $projectname, "/config.xml")) let $base-path := $conf//sade:base-path let
                    $naviconf := $conf//sade:container[@ref = $container]/sade:module[@ref =
                    'navigation']/sade:param[@name = 'navi-content'] let $dir :=
                    $naviconf//sade:navigation/@dir let $style := $naviconf//sade:navigation/@style
                    (: go through the levels :) let $nav := &lt;ul class="nav nav-{if ($style =
                    "pills") then data($style) else "tabs"} {if ($dir = "vertical") then
                    "nav-stacked" else ()}"&gt;
                    {navi:createLevel($naviconf//sade:navigation/sade:list/sade:item, $uri)}
                    &lt;/ul&gt; return $nav }; declare function navi:createLevel($navi as node(),
                    $uri as xs:string) as node()+{ for $item in $navi let $link := $item/data(@link)
                    let $path := tokenize($uri, "/") let $last := $path[last()] let $active := if
                    ($link = $last) then "active" else () order by $item/@n ascending return (:
                    dropdown or simple entry :) if ($item/sade:list) then &lt;li
                    class="dropdown"&gt; &lt;a class="dropdown-toggle" data-toggle="dropdown"
                    href="#"&gt; {data($item/@label)} &lt;b class="caret"&gt;&lt;/b&gt; &lt;/a&gt;
                    &lt;ul class="dropdown-menu"&gt; {navi:createLevel($item/sade:list/sade:item,
                    $uri)} &lt;/ul&gt; &lt;/li&gt; else &lt;li&gt; {if ($active) then attribute
                    class {$active} else ()} &lt;a href="{if ($item/@link) then $item/@link else
                    '#'}"&gt;{data($item/@label)}&lt;/a&gt; &lt;/li&gt; }; (: create a breadcrumb :)
                    declare function navi:create-breadcrumb($projectname as xs:string, $uri as
                    xs:string) as node(){ let $conf := doc(concat("/db/sade/projects/",
                    $projectname, "/config.xml")) let $base-path := $conf//sade:base-path let $path
                    := substring-after($uri, concat($base-path, "/")) let $steps := tokenize($path,
                    "/") let $numSteps := count($steps) return &lt;ul class="breadcrumb"&gt;
                    &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt; &lt;span
                    class="divider"&gt;/&lt;/span&gt;&lt;/li&gt; { for $step at $pos in $steps let
                    $active := if ($pos = $numSteps) then "active" else () return &lt;li&gt; {if
                    ($active) then attribute class {$active} else()} &lt;a
                    href="#"&gt;{$step}&lt;/a&gt; {if ($pos != $numSteps) then &lt;span
                    class="divider"&gt;&lt;/span&gt; else ()} &lt;/li&gt; } &lt;/ul&gt; }; </f>
            </d>
            <d n="projectAdmin">
                <f n="get.xql">xquery version "3.0";&#xd; &#xd; declare namespace output =
                    "http://www.w3.org/2010/xslt-xquery-serialization";&#xd; declare option
                    output:method "xml";&#xd; declare option output:media-type "text/xml";&#xd;
                    &#xd; import module namespace
                    project="http://aac.ac.at/content_repository/project" at
                    "../../core/project.xqm";&#xd; import module namespace
                    projectAdmin="http://aac.ac.at/content_repository/projectAdmin" at
                    "projectAdmin.xqm";&#xd; &#xd; let $project-pid :=
                    request:get-parameter("project-pid", ""),&#xd; $entity :=
                    request:get-parameter("entity","")&#xd; &#xd; let $function :=
                    projectAdmin:function-by-form($entity,"getter")&#xd; return &#xd; if
                    (exists($function))&#xd; then $function($project-pid)&#xd; else
                    &lt;false/&gt;</f>
                <f n="projectAdmin.xql">xquery version "3.0"; import module namespace
                    projectAdmin="http://aac.ac.at/content_repository/projectAdmin" at
                    "projectAdmin.xqm"; import module namespace
                    project="http://aac.ac.at/content_repository/project" at
                    "../../core/project.xqm"; declare option exist:serialize "method=xhtml
                    media-type=text/html indent=yes"; let $html-menu := doc("adminMenu.html") let
                    $project-pid := request:get-parameter("project","") let $path :=
                    request:get-parameter("path",""), $path-steps := tokenize($path,'/'), $form-data
                    := projectAdmin:form($path-steps[3]), $form := if (exists($form-data)) then
                    $path-steps[3] else "dmd", $form-data := if (not(exists($form-data))) then
                    projectAdmin:form($form) else $form-data let $lang:=
                    request:get-parameter("lang","en"), $section := $path-steps[4] let $user :=
                    xmldb:get-current-user() (: this variable can be passed to projectAdmin:bind and
                    projectAdmin:form and will be used to replace attribute value templates in curly
                    brackets, like {$project-pid} :) let $vars := map { "user" := $user,
                    "project-pid" := $project-pid, "lang" := $lang, "section" := $section } let
                    $html:= &lt;html xmlns="http://www.w3.org/1999/xhtml"
                    xmlns:mods="http://www.loc.gov/mods/v3" xmlns:mets="http://www.loc.gov/METS/"
                    xmlns:xf="http://www.w3.org/2002/xforms"
                    xmlns:xhtml="http://www.w3.org/1999/xhtml"
                    xmlns:ev="http://www.w3.org/2001/xml-events"&gt; &lt;head&gt; &lt;script
                    type="text/javascript"
                    src="../../shared-resources/resources/scripts/jquery/jquery-1.7.1.min.js"&gt;&lt;/script&gt;
                    &lt;link rel="stylesheet" type="text/css"
                    href="../../shared-resources/resources/css/bootstrap.min.css"/&gt; &lt;script
                    type="text/javascript"
                    src="../../shared-resources/resources/scripts/bootstrap.min.js"&gt;&lt;/script&gt;
                    &lt;style type="text/css"&gt;&lt;![CDATA[ body { background: none; }
                    .xfRepeatIndex { background-color: #DBDBDB; } #help-pane { background-color:
                    #D6D6D6; border: 1px solid #B3B3B3; margin-top: 30px; } #help-pane h5 { margin:
                    0; } thead { background: gray; color: white; border-color: white; } th {
                    font-weight: normal; text-align: left; border-color: white; padding: 2px 4px; }
                    td { border-color: gray; } /*table, th, tr, td { border-style: dotted;
                    border-width: 1px; border-collapse: collapse; } table div { margin: 0!important;
                    } */ .xfFullGroup label { vertical-align: top; } .bf .bfVerticalTable
                    .bfVerticalTableLabel .xfLabel { padding-top: 0; } .bfVerticalTableLabel {
                    padding-right: 15px; } ]]&gt;&lt;/style&gt; &lt;script
                    type="text/javascript"&gt;&lt;![CDATA[ $(document).ready( function(){
                    $(']]&gt;{"#li-"||$form}&lt;![CDATA[').addClass('active'); //
                    $(']]&gt;{$form}&lt;![CDATA[').addClass('active'); } ); ]]&gt;&lt;/script&gt;
                    &lt;xf:model id="model"&gt; &lt;!-- some basic data which resides on the
                    mets:mets element --&gt; &lt;xf:instance id="instance-project-id"&gt;
                    &lt;mets:mets OBJID="{$project-pid}"/&gt; &lt;/xf:instance&gt; &lt;xf:bind
                    id="project-id" ref="instance('instance-project-id')/@OBJID"
                    readonly="true"/&gt; &lt;xf:instance id="instance-project-label"
                    resource="get.xql?entity=project-label&amp;amp;project-pid={$project-pid}"/&gt;
                    &lt;xf:bind id="project-label" ref="instance('instance-project-label')"
                    readonly="false"/&gt; &lt;!-- main form data + submission --&gt;
                    {(projectAdmin:labels($form,$lang), projectAdmin:instancedata($project-pid,
                    $form), projectAdmin:help($form,$lang),
                    projectAdmin:bind($project-pid,$form,$vars))} &lt;xf:submission
                    replace="instance" resource="store.xql?entity={$form}" id="save" method="post"
                    ref="instance('{$form}')"&gt; &lt;xf:message level="ephemeral"
                    ev:event="xforms-submit-error"&gt;Submission failed&lt;/xf:message&gt;
                    &lt;xf:message level="ephemeral" ev:event="xforms-submit-done"&gt;Submission
                    successful&lt;/xf:message&gt; &lt;/xf:submission&gt; &lt;!-- HELP pane --&gt;
                    &lt;xf:instance id="help-output" xmlns=""&gt; &lt;div
                    xmlns="http://www.w3.org/1999/xhtml"/&gt; &lt;/xf:instance&gt; {if ($section!=''
                    and exists($form-data//xf:case[@id = 'tab'||$section])) then &lt;xf:action
                    xmlns:ev="http://www.w3.org/2001/xml-events" ev:event="xforms-ready"&gt;
                    &lt;xf:setvalue ref="instance('help-output')"
                    value="instance('help')/xhtml:div[@id='help-{$form}-{$section}']/xhtml:p"/&gt;
                    &lt;xf:toggle case="tab{$section}" id="tabSwitch"/&gt; &lt;/xf:action&gt; else
                    &lt;xf:action xmlns:ev="http://www.w3.org/2001/xml-events"
                    ev:event="xforms-ready"&gt; &lt;xf:setvalue ref="instance('help-output')"
                    value="instance('help')/self::xhtml:div[@id='help-{$form}']/xhtml:p"/&gt;
                    &lt;/xf:action&gt; } &lt;!-- basic GUI element labels --&gt; &lt;xf:bind
                    id="form-title" ref="instance('labels')//label[@key='form-title']"/&gt;
                    &lt;xf:bind id="label-form-save"
                    ref="instance('labels')//label[@key='form-save']"/&gt; &lt;xf:bind
                    id="label-form-reset" ref="instance('labels')//label[@key='form-reset']"/&gt;
                    &lt;/xf:model&gt; &lt;title&gt;cr-Project Administration: {$project-pid}
                    (&lt;xf:output bind="form-title"/&gt;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt;
                    &lt;div class="container-fluid"&gt; &lt;!-- head --&gt; &lt;div
                    class="row-fluid"&gt; &lt;div class="span12"&gt; &lt;h3
                    class="pull-right"&gt;cr_xq Project Administration
                    &lt;small&gt;{$project-pid}&lt;/small&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt;
                    &lt;div class="row-fluid"&gt; &lt;div class="span2"&gt; &lt;!-- menu --&gt;
                    {$html-menu} &lt;/div&gt; &lt;div class="span7"&gt; &lt;!-- main form --&gt;
                    &lt;h1&gt; &lt;xf:output bind="form-title"/&gt; &lt;/h1&gt; {$form-data}
                    &lt;/div&gt; &lt;!-- help --&gt; &lt;div class="span3"&gt; &lt;div class="well"
                    id="help-pane"&gt; &lt;h5&gt;Help&lt;/h5&gt; &lt;xf:output
                    ref="instance('help-output')"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;
                    &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; return $html</f>
                <f n="projectAdmin.xqm">xquery version "3.0";&#xd; module namespace projectAdmin =
                    "http://aac.ac.at/content_repository/projectAdmin";&#xd; import module namespace
                    project = "http://aac.ac.at/content_repository/project" at
                    "../../core/project.xqm";&#xd; import module namespace resource =
                    "http://aac.ac.at/content_repository/resource" at
                    "../../core/resource.xqm";&#xd; &#xd; declare namespace
                    rest="http://exquery.org/ns/restxq";&#xd; declare namespace
                    output="http://www.w3.org/2010/xslt-xquery-serialization";&#xd; declare
                    namespace xf="http://www.w3.org/2002/xforms";&#xd; declare namespace
                    xhtml="http://www.w3.org/1999/xhtml";&#xd; declare namespace cr =
                    "http://aac.ac.at/content_repository";&#xd; &#xd; declare variable
                    $projectAdmin:config:=doc("config.xml");&#xd; declare variable
                    $projectAdmin:default-language:=$projectAdmin:config//lang[@default='true']/@xml:id;&#xd;
                    &#xd; declare &#xd; %rest:GET&#xd; %rest:path("/projectAdmin/languages")&#xd;
                    function projectAdmin:languages() as element(languages){&#xd;
                    $projectAdmin:config//languages&#xd; };&#xd; &#xd; declare &#xd; %rest:GET&#xd;
                    %rest:path("/projectAdmin/i18n/{$form-id}/{$lang}")&#xd;
                    %output:media-type("text/xml")&#xd; %output:method("xml")&#xd; function
                    projectAdmin:labels($form-id as xs:string?, $lang as xs:string) as
                    element(xf:instance) {&#xd; let $form := $projectAdmin:config//form[@xml:id eq
                    $form-id],&#xd; $labels := ($form/labels[@xml:lang =
                    $lang]|$projectAdmin:config//i18n/common/labels[@xml:lang = $lang])&#xd;
                    return&#xd; &lt;xf:instance id="labels" xmlns=""&gt;&#xd; &lt;labels&gt;{&#xd;
                    switch(true())&#xd; case exists($labels) return $labels/*&#xd; case
                    exists($form/labels[@xml:lang = $projectAdmin:default-language]) return
                    $form/labels[@xml:lang = $projectAdmin:default-language]/*&#xd; case
                    exists($form//labels[@xml:lang = "en"]) return $form/labels[@xml:lang =
                    "en"]/*&#xd; case exists($form[1]/*) return $form[1]/* &#xd; default return
                    &lt;label/&gt;&#xd; }&lt;/labels&gt;&#xd; &lt;/xf:instance&gt;&#xd; };&#xd;
                    &#xd; declare &#xd; %rest:GET&#xd;
                    %rest:path("/projectAdmin/i18n/{$form}/{$form-control}/{$lang}")&#xd;
                    %output:media-type("text/plain")&#xd; %output:method("text")&#xd; function
                    projectAdmin:label($form as xs:string, $form-control as xs:string, $lang as
                    xs:string) as xs:string? {&#xd; let $label:=$projectAdmin:config//(form[@xml:id
                    eq $form]|common)[1]//label[@key eq $form-control]&#xd; return &#xd;
                    switch(true())&#xd; case exists($label[parent::*/@xml:lang = $lang]) return
                    $label[parent::*/@xml:lang = $lang]&#xd; case exists($label[parent::*/@xml:lang
                    = $projectAdmin:default-language]) return $label[parent::*/@xml:lang =
                    $projectAdmin:default-language]&#xd; case exists($label[parent::*/@xml:lang =
                    'en']) return $label[parent::*/@xml:lang = "en"]&#xd; case exists($label) return
                    $label[1]&#xd; default return $form-control &#xd; };&#xd; &#xd; (:~&#xd; : Maps
                    the name of a form to the function in the project.xqm or resource.xqm modules,
                    which&#xd; : provide the data for editing - either by looking it up in
                    config.xml or &#xd; : by looking up the function. &#xd; : I.e. if nothing else
                    was explicitly defined in config.xml a form named &#xd; : "project-dmd" will be
                    mapped to "project:dmd", a form "metsHdr" &#xd; : to "project:metsHdr" (by
                    default the project module is assumed).&#xd; : &#xd; : @param $form the form /
                    data entity to be set or get.&#xd; : @param $type retrieve the setter or getter
                    method (default "getter")&#xd; : @return a map with the keys "arity" and
                    "function"&#xd; ~:)&#xd; declare function projectAdmin:function-by-form($form as
                    xs:string, $type as xs:string) as map()? {&#xd; let $functionName :=&#xd;
                    switch(true())&#xd; case exists($projectAdmin:config//function[@form = $form])
                    return $projectAdmin:config//function[@form = $form]&#xd; case
                    starts-with($form,'project-') return
                    "project:"||substring-after($form,'project-')&#xd; case
                    starts-with($form,'project:') return $form&#xd; case
                    starts-with($form,'resource-') return
                    "resource:"||substring-after($form,'resource-')&#xd; case
                    starts-with($form,'resource:') return $form&#xd; case
                    starts-with($form,'resourcefragment-') return
                    "resourcefragment:"||substring-after($form,'resourcefragment-')&#xd; case
                    starts-with($form,'resourcefragment:') return $form&#xd; default return
                    "project:"||$form &#xd; let $arity as xs:integer :=&#xd; if ($type = "setter")
                    then &#xd; (: project setters have per default at least two parameters: $data
                    and $project-pid,&#xd; resource setters have $resource-pid as third parameter
                    :)&#xd; if (exists($projectAdmin:config//function[@form =
                    $form]/@setter-arity))&#xd; then $projectAdmin:config//function[@form =
                    $form]/@setter-arity&#xd; else &#xd; if (starts-with($functionName,'project:'))
                    &#xd; then 2&#xd; else 3&#xd; else&#xd; (: project getters have per default at
                    least one parameter $project-pid,&#xd; resource getters have $resource-pid as
                    first parameter :)&#xd; if (exists($projectAdmin:config//function[@form =
                    $form]/@getter-arity))&#xd; then $projectAdmin:config//function[@form =
                    $form]/@getter-arity&#xd; else &#xd; if (starts-with($functionName,'project:'))
                    &#xd; then 1&#xd; else 2&#xd; return &#xd; try {&#xd; map {&#xd; "function" :=
                    function-lookup(xs:QName(xs:string($functionName)), $arity),&#xd; "arity" :=
                    $arity&#xd; }&#xd; } catch * {&#xd; let $log := util:log("INFO", "could not
                    lookup getter function for form "||$form||", I tried "||$functionName||" with
                    arity "||$arity)&#xd; return ()&#xd; }&#xd; };&#xd; &#xd; declare function
                    projectAdmin:instancedata($project-pid as xs:string, $form as xs:string) as
                    element(xf:instance)* {&#xd; let $function-found :=
                    exists(projectAdmin:function-by-form($form,"getter")) &#xd; let $function := if
                    ($function-found)&#xd; then
                    map:get(projectAdmin:function-by-form($form,"getter"),"function")&#xd; else
                    ()&#xd; let $data:= if (not($function-found))&#xd; then &lt;empty
                    xmlns=""/&gt;&#xd; else $function($project-pid)&#xd; return &lt;xf:instance
                    id="{$form}" xmlns=""&gt;&#xd; &lt;cr:data entity="{$form}"
                    project-pid="{$project-pid}"&gt;{$data}&lt;/cr:data&gt;&#xd;
                    &lt;/xf:instance&gt;&#xd; };&#xd; &#xd; declare function
                    projectAdmin:data($project-pid as xs:string, $entity as xs:string) as element()?
                    {&#xd; let $function :=
                    map:get(projectAdmin:function-by-form($entity,"getter"),"function")&#xd; let
                    $data:= if ($function instance of xs:boolean)&#xd; then ()&#xd; else
                    $function($project-pid)&#xd; return &lt;cr:data entity="{$entity}"
                    project-pid="{$project-pid}"&gt;{$data}&lt;/cr:data&gt; &#xd; };&#xd; &#xd;
                    declare %private function projectAdmin:expandAVTs($node as node(), $variables as
                    map(*)) {&#xd; typeswitch ($node) &#xd; case attribute() return&#xd; attribute
                    {QName(namespace-uri($node),name($node))} {&#xd; projectAdmin:expandAVTs(&#xd;
                    text { xs:string($node) },&#xd; $variables&#xd; )&#xd; }&#xd; case element()
                    return &#xd; element {QName(namespace-uri($node),name($node))} { &#xd; for $n in
                    ($node/@*,$node/node())&#xd; return projectAdmin:expandAVTs($n,$variables)&#xd;
                    }&#xd; case text() return &#xd; let $matches :=
                    fn:analyze-string($node,"\{\$(.*?)\}")&#xd; return&#xd; string-join(&#xd; for $i
                    in $matches/* return&#xd; if ($i/self::fn:match and
                    map:contains($variables,$i/fn:group))&#xd; then
                    map:get($variables,$i/fn:group)&#xd; else $i&#xd; , ""&#xd; ) &#xd; case
                    document-node() return&#xd;
                    projectAdmin:expandAVTs($node/root(),$variables)&#xd; default return $node&#xd;
                    };&#xd; &#xd; declare function projectAdmin:bind($project-pid as xs:string,
                    $form as xs:string, $variables as map()) as element()* {&#xd; if
                    (doc-available($form||".xml"))&#xd; then&#xd; let $doc := doc($form||".xml")
                    &#xd; let $elts := $doc//(xf:bind|xf:instance|xf:submission)&#xd; return &#xd;
                    for $elt in $elts&#xd; let $exp :=
                    projectAdmin:expandAVTs($elt,map:new((map:entry("project-pid",$project-pid),$variables)))&#xd;
                    return $exp&#xd; else ()&#xd; };&#xd; &#xd; declare function
                    projectAdmin:form($form as xs:string?) {&#xd; if
                    (doc-available($form||".html"))&#xd; then doc($form||".html")/*&#xd; else
                    util:log("INFO", "Error: unknown form "||$form||".")&#xd; };&#xd; &#xd; declare
                    function projectAdmin:help($form as xs:string, $lang as xs:string) as
                    element(xhtml:div)?{&#xd; let $data :=
                    doc("help-"||$lang||".html")//xhtml:div[@id eq "help-"||$form]&#xd; return &#xd;
                    &lt;xf:instance id="help" xmlns=""&gt;{&#xd; if (exists($data))&#xd; then
                    $data&#xd; else &#xd; &lt;xhtml:div&gt;&#xd; &lt;xhtml:p&gt;No help available
                    for this context.&lt;/xhtml:p&gt;&#xd; &lt;/xhtml:div&gt;&#xd;
                    }&lt;/xf:instance&gt;&#xd; };&#xd; &#xd; declare function
                    projectAdmin:store($data as document-node(), $parameters as map()) {&#xd; let
                    $entity := $data/cr:data/xs:string(@entity)&#xd; let $log := util:log("INFO",
                    util:serialize($data,"method=xml indent=yes"))&#xd; let $log := util:log("INFO",
                    "$entity: "||$entity)&#xd; return &#xd; switch ($entity)&#xd; case
                    "project-label" return&#xd; let $project-pid := $parameters("project-pid"),&#xd;
                    $log := util:log("INFO", $project-pid)&#xd; return &#xd; if ($project-pid != '')
                    &#xd; then &#xd; let $store := project:label($project-pid, document
                    {($data/node())})&#xd; return &#xd; if ($store)&#xd; then $data&#xd; else
                    ()&#xd; else ()&#xd; case "uploadResource" return &#xd; let $project-pid :=
                    $parameters("project-pid"),&#xd; $resource-label :=
                    $parameters("resource-label")&#xd; let $new :=
                    resource:new-with-label($data,$project-pid,$resource-label)&#xd; return
                    &lt;data/&gt;&#xd; case "start" return $data&#xd; default return ()&#xd; };</f>
                <f n="projectAdmin_via_mets.xql">xquery version "3.0"; import module namespace
                    projectAdmin="http://aac.ac.at/content_repository/projectAdmin" at
                    "projectAdmin.xqm"; import module namespace
                    project="http://aac.ac.at/content_repository/project" at
                    "../../core/project.xqm"; declare namespace output =
                    "http://www.w3.org/2010/xslt-xquery-serialization"; declare option output:method
                    "xhtml"; declare option output:media-type "text/html"; declare option
                    output:indent "no"; let $html-menu := doc("adminMenu.html") let $project-pid :=
                    request:get-parameter("project","") let $path :=
                    request:get-parameter("path",""), $path-steps := tokenize($path,'/'), $form-data
                    := projectAdmin:form($path-steps[3]), $form := if (exists($form-data)) then
                    $path-steps[3] else "dmd", $form-data := if (not(exists($form-data))) then
                    projectAdmin:form($form) else $form-data let $lang:=
                    request:get-parameter("lang","en"), $section := $path-steps[4] return &lt;html
                    xmlns="http://www.w3.org/1999/xhtml" xmlns:mods="http://www.loc.gov/mods/v3"
                    xmlns:mets="http://www.loc.gov/METS/" xmlns:xf="http://www.w3.org/2002/xforms"
                    xmlns:xhtml="http://www.w3.org/1999/xhtml"
                    xmlns:ev="http://www.w3.org/2001/xml-events"&gt; &lt;head&gt; &lt;script
                    type="text/javascript"
                    src="../../shared-resources/resources/scripts/jquery/jquery-1.7.1.min.js"&gt;&lt;/script&gt;
                    &lt;link rel="stylesheet"
                    href="../../shared-resources/resources/css/bootstrap.min.css"/&gt; &lt;script
                    type="text/javascript"
                    src="../../shared-resources/resources/scripts/bootstrap.min.js"&gt;&lt;/script&gt;
                    &lt;style type="text/css"&gt;&lt;![CDATA[ /* body { background: none; }
                    .xfRepeatIndex { background-color: #DBDBDB; } #help-pane { background-color:
                    #D6D6D6; border: 1px solid #B3B3B3; margin-top: 30px; } #help-pane h5 { margin:
                    0; } thead { background: gray; color: white; border-color: white; } th {
                    font-weight: normal; text-align: left; border-color: white; padding: 2px 4px; }
                    td { border-color: gray; } /*table, th, tr, td { border-style: dotted;
                    border-width: 1px; border-collapse: collapse; } table div { margin: 0!important;
                    } */ .xfFullGroup label { vertical-align: top; } .bf .bfVerticalTable
                    .bfVerticalTableLabel .xfLabel { padding-top: 0; } .bfVerticalTableLabel {
                    padding-right: 15px; } */ ]]&gt;&lt;/style&gt; &lt;xf:model&gt;
                    &lt;xf:submission id="store"
                    resource="exist:{base-uri(project:get($project-pid))}" method="post"
                    replace="instance" ref="instance('mets')"/&gt; &lt;xf:instance
                    id="mods.personTemplate"&gt; &lt;mods:name&gt; &lt;mods:namePart
                    type="family"/&gt; &lt;mods:namePart type="given"/&gt; &lt;mods:role&gt;
                    &lt;mods:roleTerm type="text"/&gt; &lt;/mods:role&gt; &lt;/mods:name&gt;
                    &lt;/xf:instance&gt; &lt;xf:instance id="mods.languageTemplate"&gt;
                    &lt;mods:language&gt; &lt;mods:languageTerm type="text"/&gt;
                    &lt;/mods:language&gt; &lt;/xf:instance&gt; &lt;xf:instance id="languages"
                    xmlns=""
                    src="exist:/db/apps/cr-xq-dev0913/modules/projectAdmin/languages.xml"&gt;
                    &lt;/xf:instance&gt; &lt;xf:instance id="selectedLanguage" xmlns=""&gt;
                    &lt;data&gt;&lt;/data&gt; &lt;/xf:instance&gt; &lt;xf:instance
                    src="exist:{base-uri(project:get($project-pid))}" id="mets"/&gt; &lt;xf:bind
                    id="project.pid" ref="@OBJID"/&gt; &lt;xf:bind id="project.label"
                    ref="@LABEL"/&gt; &lt;xf:bind id="project.status"
                    ref="mets:metsHdr/@RECORDSTATUS"/&gt; &lt;xf:bind id="project.createdate"
                    ref="mets:metsHdr/@CREATEDATE"/&gt; &lt;xf:bind id="project.dmd"
                    ref="mets:dmdSec[@ID='projectDMD']/mets:mdWrap[@MDTYPE='MODS']/mets:xmlData/mods:mods"&gt;
                    &lt;xf:bind ref="mods:language/mods:languageTerm" type="xsd:string"
                    relevant="false()"/&gt; &lt;/xf:bind&gt; &lt;/xf:model&gt; &lt;/head&gt;
                    &lt;body&gt; &lt;h1&gt;Project Admin "{$project-pid}"&lt;/h1&gt; &lt;xf:switch
                    ref="instance('mets')"&gt; &lt;xf:case id="start"&gt; &lt;xf:group
                    appearance="bf:verticalTable"&gt; &lt;xf:output bind="project.pid"&gt;
                    &lt;xf:label&gt;Project PID&lt;/xf:label&gt; &lt;/xf:output&gt; &lt;xf:output
                    bind="project.createdate"&gt; &lt;xf:label&gt;Created: &lt;/xf:label&gt;
                    &lt;/xf:output&gt; &lt;xf:input bind="project.label"&gt; &lt;xf:label&gt;Project
                    Label&lt;/xf:label&gt; &lt;/xf:input&gt; &lt;xf:select1
                    bind="project.status"&gt; &lt;xf:label&gt;Project Status&lt;/xf:label&gt;
                    &lt;xf:item&gt; &lt;xf:label&gt;available&lt;/xf:label&gt;
                    &lt;xf:value&gt;available&lt;/xf:value&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:label&gt;under revision&lt;/xf:label&gt; &lt;xf:value&gt;under
                    revision&lt;/xf:value&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:label&gt;restricted&lt;/xf:label&gt;
                    &lt;xf:value&gt;restricted&lt;/xf:value&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:label&gt;removed&lt;/xf:label&gt;
                    &lt;xf:value&gt;removed&lt;/xf:value&gt; &lt;/xf:item&gt; &lt;/xf:select1&gt;
                    &lt;xf:group bind="project.dmd" appearance="bf:verticalTable"&gt; &lt;xf:input
                    ref="mods:titleInfo/mods:title"&gt; &lt;xf:label&gt;Title&lt;/xf:label&gt;
                    &lt;/xf:input&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Family
                    Name&lt;/th&gt; &lt;th&gt;Given Name&lt;/th&gt; &lt;th&gt;Role&lt;/th&gt;
                    &lt;th/&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody xf:repeat-nodeset="mods:name"
                    id="modsNames-repeat"&gt; &lt;tr&gt; &lt;td&gt;&lt;xf:input
                    ref="mods:namePart[@type='family']"/&gt;&lt;/td&gt; &lt;td&gt;&lt;xf:input
                    ref="mods:namePart[@type='given']"/&gt;&lt;/td&gt; &lt;td&gt;&lt;xf:input
                    ref="mods:role/mods:roleTerm[@type='text']"/&gt;&lt;/td&gt; &lt;td&gt;
                    &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;xf:trigger&gt;
                    &lt;xf:label&gt;Remove Person&lt;/xf:label&gt; &lt;xf:action&gt; &lt;xf:delete
                    ref="mods:name" at="index('modsNames-repeat')"/&gt; &lt;/xf:action&gt;
                    &lt;/xf:trigger&gt; &lt;xf:trigger&gt; &lt;xf:label&gt;Add
                    Person&lt;/xf:label&gt; &lt;xf:action&gt; &lt;xf:insert context="." nodeset="*"
                    origin="instance('mods.personTemplate')"&gt; &lt;/xf:insert&gt;
                    &lt;/xf:action&gt; &lt;/xf:trigger&gt; &lt;xf:select1 ref="mods:typeOfResource"
                    required="true" selection="closed"&gt; &lt;xf:label&gt;Type of
                    Resource&lt;/xf:label&gt; &lt;xf:alert&gt;Type of Resource must not be
                    empty.&lt;/xf:alert&gt; &lt;xf:item&gt; &lt;xf:value&gt;text&lt;/xf:value&gt;
                    &lt;xf:label&gt;text&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:value&gt;cartographic&lt;/xf:value&gt;
                    &lt;xf:label&gt;cartographic&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:value&gt;notated music&lt;/xf:value&gt; &lt;xf:label&gt;notated
                    music&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt; &lt;xf:value&gt;sound
                    recording&lt;/xf:value&gt; &lt;xf:label&gt;sound recording&lt;/xf:label&gt;
                    &lt;/xf:item&gt; &lt;xf:item&gt; &lt;xf:value&gt;sound
                    recording-musical&lt;/xf:value&gt; &lt;xf:label&gt;sound
                    recording-musical&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:value&gt;sound recording-nonmusical&lt;/xf:value&gt;
                    &lt;xf:label&gt;sound recording-nonmusical&lt;/xf:label&gt; &lt;/xf:item&gt;
                    &lt;xf:item&gt; &lt;xf:value&gt;still image&lt;/xf:value&gt;
                    &lt;xf:label&gt;still image&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:value&gt;moving image&lt;/xf:value&gt; &lt;xf:label&gt;moving
                    image&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt; &lt;xf:value&gt;three
                    dimensional object&lt;/xf:value&gt; &lt;xf:label&gt;three dimensional
                    object&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:value&gt;software, multimedia&lt;/xf:value&gt; &lt;xf:label&gt;software,
                    multimedia&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;xf:item&gt;
                    &lt;xf:value&gt;mixed material&lt;/xf:value&gt; &lt;xf:label&gt;mixed
                    material&lt;/xf:label&gt; &lt;/xf:item&gt; &lt;/xf:select1&gt; &lt;xf:output
                    value="string-join(mods:language/mods:languageTerm,', ')"&gt;
                    &lt;xf:label&gt;Language(s): &lt;/xf:label&gt; &lt;/xf:output&gt; &lt;xf:select1
                    ref="instance('selectedLanguage')" selection="closed" appearance="compact"&gt;
                    &lt;xf:label&gt;Language&lt;/xf:label&gt; &lt;xf:itemset
                    nodeset="instance('languages')/language"&gt; &lt;xf:value ref="@code"/&gt;
                    &lt;xf:label ref="@label"/&gt; &lt;/xf:itemset&gt; &lt;xf:action
                    ev:event="xforms-select"&gt; &lt;xf:insert context="instance('mets')//mods:mods"
                    nodeset="*" origin="instance('mods.languageTemplate')"/&gt; &lt;xf:setvalue
                    ref="instance('mets')//mods:mods/mods:language/mods:languageTerm[.='']"
                    value="instance('selectedLanguage')"/&gt; &lt;/xf:action&gt; &lt;/xf:select1&gt;
                    &lt;xf:trigger&gt; &lt;xf:label&gt;Remove Language&lt;/xf:label&gt;
                    &lt;xf:action&gt; &lt;xf:delete ref="mods:language[mods:languageTerm =
                    instance('selectedLanguage')]"/&gt; &lt;/xf:action&gt; &lt;/xf:trigger&gt;
                    &lt;xf:trigger&gt; &lt;xf:label&gt;Add Language&lt;/xf:label&gt;
                    &lt;xf:action&gt; &lt;xf:insert context="." nodeset="*"
                    origin="instance('mods.languageTemplate')"/&gt; &lt;xf:setvalue
                    ref="mods:language/mods:languageTerm[.='']"
                    value="instance('selectedLanguage')"/&gt; &lt;/xf:action&gt; &lt;/xf:trigger&gt;
                    &lt;xf:textarea ref="mods:abstract"&gt;
                    &lt;xf:label&gt;Abstract&lt;/xf:label&gt; &lt;/xf:textarea&gt; &lt;/xf:group&gt;
                    &lt;/xf:group&gt; &lt;/xf:case&gt; &lt;xf:case id="empty"/&gt;
                    &lt;/xf:switch&gt; &lt;xf:trigger&gt; &lt;xf:label&gt;save&lt;/xf:label&gt;
                    &lt;xf:action&gt; &lt;xf:send submission="store"/&gt; &lt;xf:message
                    ev:event="xforms-submit-done" level="ephemeral"&gt;Project
                    saved.&lt;/xf:message&gt; &lt;xf:message ev:event="xforms-submit-error"
                    level="ephemeral"&gt;An error occurred.&lt;/xf:message&gt; &lt;/xf:action&gt;
                    &lt;/xf:trigger&gt; &lt;/body&gt; &lt;/html&gt; </f>
                <f n="store.xql">xquery version "3.0";&#xd; &#xd; import module namespace
                    project="http://aac.ac.at/content_repository/project" at
                    "../../core/project.xqm";&#xd; &#xd; declare option exist:serialize "method=xml
                    media-type=text/xml";&#xd; &#xd; let $project-pid :=
                    request:get-header("project-pid"),&#xd; $form :=
                    request:get-header("form"),&#xd; $user-id := request:get-header("user-id")&#xd;
                    let $data := request:get-data()&#xd; &#xd; let $log := util:log("INFO", "***
                    store.xql ***")&#xd; let $data-log := util:log("INFO", name($data/*))&#xd; (:let
                    $log2 := &#xd; for $i in ("$data","$project-pid", "$user-id")&#xd; return &#xd;
                    (util:log("INFO", "*** "||$i||" ***"),&#xd; util:log("INFO",
                    util:eval($i)))&#xd; :)&#xd; let $update := &#xd; switch ($form)&#xd; case "dmd"
                    return project:dmd($project-pid, $data/*)&#xd; case "start" return
                    project:metsHdr($project-pid, $data/*)&#xd; case "data" return
                    project:mappings($project-pid, $data/*)&#xd; default return ()&#xd; return
                    $data</f>
            </d>
            <d n="query">
                <f n="cql-tests.xql">xquery version "3.0";&#xd; &#xd; import module namespace cql =
                    "http://exist-db.org/xquery/cql" at "cqlparser.xqm";&#xd; import module
                    namespace index = "http://aac.ac.at/content_repository/index" at
                    "../../core/index.xqm";&#xd; &#xd; import module namespace
                    request="http://exist-db.org/xquery/request";&#xd; &#xd; (:~ cql-tests :)&#xd;
                    &#xd; (:let $cql := request:get-parameter("cql", "title any Wien and date &lt;
                    1950"):)&#xd; let $map := &lt;map xmlns=""&gt;&#xd; &lt;namespaces&gt;&#xd;
                    &lt;ns prefix="tei" uri="http://www.tei-c.org/ns/1.0"/&gt;&#xd;
                    &lt;/namespaces&gt;&#xd; &lt;map key="" path="" title=""&gt;&#xd; &lt;index
                    key="rf"&gt;&#xd; &lt;path match="@xml:id" label="@n"&gt;pb&lt;/path&gt;&#xd;
                    &lt;/index&gt;&#xd; &lt;index key="fcs.rf" type="ft" &gt;&#xd; &lt;path
                    match="@rf-pid" label="@rf-label"&gt;resourceFragment&lt;/path&gt;&#xd;
                    &lt;/index&gt;&#xd; &lt;index key="cql.serverChoice" type="ft"&gt;&#xd;
                    &lt;path&gt;p&lt;/path&gt;&#xd; &lt;/index&gt;&#xd; &lt;/map&gt;&#xd;
                    &lt;/map&gt;&#xd; &#xd; let $queries := &lt;qs&gt;&#xd; &lt;q cql="term1"
                    expected-xpath='p[ft:query(.,"term1")]' /&gt;&#xd; &lt;q cql="rf = pb1"
                    expected-xpath="pb[@xml:id='pb1']" /&gt;&#xd; &lt;q cql="fcs.rf = rf1"
                    expected-xpath='resourceFragment[ft:query(@rf-pid,"rf1")]' /&gt;&#xd;
                    &lt;/qs&gt;&#xd; &#xd; for $q at $pos in $queries/q&#xd; let $cql :=
                    $q/xs:string(@cql)&#xd; let $expected-xpath :=
                    $q/xs:string(@expected-xpath)&#xd; let $xcql := cql:cql-to-xcql($cql)&#xd; let
                    $resolved-xpath := cql:process-xcql($xcql, $map)&#xd; return if ($expected-xpath
                    eq $resolved-xpath) then () else $expected-xpath||' != '||$resolved-xpath&#xd;
                    (: return ( $resolved-xpath):)&#xd; &#xd; </f>
                <f n="cql.xql">xquery version "3.0";&#xd; &#xd; import module namespace cql =
                    "http://exist-db.org/xquery/cql" at "cql.xqm";&#xd; import module namespace
                    query = "http://aac.ac.at/content_repository/query" at "query.xqm";&#xd; import
                    module namespace index = "http://aac.ac.at/content_repository/index" at
                    "../../core/index.xqm";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";
                    &#xd; import module namespace
                    repo-utils="http://aac.ac.at/content_repository/utils" at
                    "../../core/repo-utils.xqm";&#xd; &#xd; import module namespace
                    request="http://exist-db.org/xquery/request";&#xd; &#xd; (:let $cql :=
                    request:get-parameter("cql", "title any Wien and date &lt; 1950"):)&#xd; &#xd;
                    let $cql := 'term1'&#xd; let $xcql := cql:cql-to-xcql($cql)&#xd; let
                    $project-pid := 'abacus2'&#xd; let $config := config:config($project-pid) &#xd;
                    let $model := map { "config" := $config, "project" := $project-pid }&#xd; let
                    $map := index:map($project-pid)&#xd; let $xpath := cql:cql-to-xpath($xcql,
                    $project-pid)&#xd; (:return $xcql:)&#xd; let $index-key := $xcql//index/text(),
                    &#xd; $index := index:index-from-map($index-key ,$map),&#xd; $index-type :=
                    ($index/xs:string(@type),'')[1]&#xd; (: return $index-key:)&#xd; &#xd; let
                    $data-collection := repo-utils:context-to-collection($project-pid, $config)&#xd;
                    &#xd; (:return query:execute-query($xpath,$data-collection, $project-pid
                    ):)&#xd; return util:eval(concat("($data)//", $xpath))&#xd; &#xd; &#xd; &#xd; </f>
                <f n="cql.xqm">xquery version "3.0";&#xd; (:~ This module provides methods to
                    transform CQL query to XPath &#xd; : @see http://clarin.eu/fcs &#xd; : @author
                    Matej Durco&#xd; : @since 2012-03-01&#xd; : @version 1.1 &#xd; :)&#xd; module
                    namespace cql = "http://exist-db.org/xquery/cql";&#xd; &#xd; import module
                    namespace cqlparser = "http://exist-db.org/xquery/cqlparser";&#xd; import module
                    namespace repo-utils = "http://aac.ac.at/content_repository/utils" at
                    "/db/apps/cr-xq-dev0913/core/repo-utils.xqm";&#xd; import module namespace diag
                    = "http://www.loc.gov/zing/srw/diagnostic/" at
                    "/db/apps/cr-xq-dev0913/modules/cql/diagnostics/diagnostics.xqm";&#xd; import
                    module namespace index = "http://aac.ac.at/content_repository/index" at
                    "/db/apps/cr-xq-dev0913/core/index.xqm";&#xd; &#xd; (:declare variable
                    $cql:transform-doc := doc("XCQL2Xpath.xsl");:)&#xd; declare variable
                    $cql:transform-doc :=
                    doc(concat(system:get-module-load-path(),"/XCQL2Xpath.xsl"));&#xd; declare
                    variable $cql:log := util:log("INFO",$cql:transform-doc);&#xd; (:~ use the
                    extension module CQLParser (using cql-java library)&#xd; to parse the expression
                    and return the xml version of the parse-tree&#xd; or a diagnostic, on parsing
                    error&#xd; :)&#xd; declare function cql:cql-to-xcql($cql-expression as
                    xs:string) {&#xd; try {&#xd; (: util:parse(cqlparser:parse-cql($cql-expression,
                    "XCQL")) :)&#xd; cqlparser:parse-cql($cql-expression, "XCQL")&#xd; }&#xd; catch
                    err:XPTY0004 &#xd; {&#xd; diag:diagnostics("query-syntax-error", ($err:code ,
                    $err:description, $err:value))&#xd; } &#xd; catch *&#xd; { &#xd;
                    diag:diagnostics("query-syntax-error", $cql-expression)&#xd; }&#xd; };&#xd;
                    &#xd; (:~ translate a query in CQL-syntax to a corresponding XPath &#xd; :
                    &lt;ol&gt;&#xd; : &lt;li&gt;1. parsing into XCQL (XML-representation of the
                    parsed query&lt;/li&gt;&#xd; : &lt;li&gt;2. and transform via
                    XCQL2Xpath.xsl-stylesheet&lt;/li&gt;&#xd; : &lt;/ol&gt;&#xd; : @returns
                    xpath-string, or if not a string, whatever came from the parsing (if not a
                    string, it must be a diagnostic) &#xd; :)&#xd; declare function
                    cql:cql2xpath_old($cql-expression as xs:string, $x-context as xs:string) as
                    item() {&#xd; let $xcql := cql:cql-to-xcql($cql-expression)&#xd; (: return
                    transform:transform ($xcql, $cql:transform-doc, &lt;parameters&gt;&lt;param
                    name="mappings-file" value="{repo-utils:config-value('mappings')}"
                    /&gt;&lt;/parameters&gt;):)&#xd; return &#xd; if (not($xcql instance of
                    element(diagnostics))) &#xd; then&#xd; let
                    $parameters:=&lt;parameters&gt;&lt;param name="x-context" value="{$x-context}"
                    /&gt;&lt;/parameters&gt;&#xd; return transform:transform ($xcql,
                    $cql:transform-doc, $parameters)&#xd; else $xcql&#xd; };&#xd; &#xd; declare
                    function cql:cql-to-xpath($cql-expression as xs:string, $context) as item()*
                    {&#xd; let $xcql := cql:cql-to-xcql($cql-expression)&#xd; (: return
                    transform:transform ($xcql, $cql:transform-doc, &lt;parameters&gt;&lt;param
                    name="mappings-file" value="{repo-utils:config-value('mappings')}"
                    /&gt;&lt;/parameters&gt;):)&#xd; return &#xd; if (not($xcql instance of
                    element(diagnostics))) &#xd; then cql:xcql-to-xpath($xcql, $context) &#xd; else
                    $xcql&#xd; };&#xd; &#xd; (:~ a version that accepts mappings-element(s) as
                    param&#xd; :)&#xd; declare function cql:cql2xpath($cql-expression as xs:string,
                    $x-context as xs:string, $mappings as element(map)*) as item() {&#xd; let $xcql
                    := if (exists($mappings)) &#xd; then cql:cql-to-xcql($cql-expression)&#xd; else
                    diag:diagnostics("mappings-missing", $mappings)&#xd; return &#xd; if ($xcql[1]
                    instance of element(diagnostics))&#xd; then $xcql&#xd; else &#xd; let $input:=
                    &lt;wrapper&gt;&#xd; &lt;query&gt;{$xcql}&lt;/query&gt;&#xd;
                    &lt;mappings&gt;{$mappings}&lt;/mappings&gt;&#xd; &lt;/wrapper&gt; &#xd; let
                    $parameters:= &lt;parameters&gt;&#xd; &lt;param name="x-context"
                    value="{$x-context}"/&gt;&#xd; &lt;/parameters&gt; &#xd; return
                    transform:transform($input, $cql:transform-doc,$parameters)&#xd; };&#xd; &#xd;
                    declare function cql:xcql-to-xpath ($xcql as node(), $context) as xs:string
                    {&#xd; let $map := index:map($context) &#xd; let $xpath := &#xd; if ($xcql
                    instance of document-node())&#xd; then cql:process-xcql($xcql/*, $map)&#xd; else
                    cql:process-xcql($xcql, $map)&#xd; return string-join($xpath,'') &#xd; };&#xd;
                    &#xd; &#xd; declare function cql:process-xcql($xcql as element(),$map) as
                    xs:string {&#xd; let $return := &#xd; typeswitch ($xcql)&#xd; case text() return
                    normalize-space($xcql)&#xd; case element(triple) return
                    cql:boolean($xcql/boolean/value, $xcql/leftOperand, $xcql/rightOperand,
                    $map)&#xd; case element(searchClause) return cql:searchClause($xcql, $map)&#xd;
                    case element(boolean) return cql:boolean($xcql/value,
                    $xcql/following-sibling::leftOperand, $xcql/following-sibling::rightOperand,
                    $map)&#xd; default return cql:process-xcql($xcql/*, $map)&#xd; return
                    $return&#xd; };&#xd; (:&#xd; declare function cql:process-xcql-default($node as
                    node(), $map) as item()* {&#xd; cql:process-xcql($node/node(), $map))&#xd; &#xd;
                    };:) &#xd; &#xd; declare function cql:boolean($value as element(value),
                    $leftOperand as element(leftOperand), $rightOperand as
                    element(rightOperand),$map) as xs:string {&#xd; let $parts :=&#xd;
                    switch($value)&#xd; case "OR" return cql:union($leftOperand, $rightOperand,
                    $map) &#xd; case "NOT" return cql:except($leftOperand, $rightOperand, $map)&#xd;
                    (: default operator AND :)&#xd; default return cql:intersect($leftOperand,
                    $rightOperand, $map) &#xd; (:"("||string-join(&#xd; for $i in
                    $boolean/following-sibling::*/searchClause&#xd; return
                    cql:searchClause($i,$map),&#xd; ' intersect '&#xd; )||")":)&#xd; return
                    string-join($parts,"")&#xd; };&#xd; &#xd; declare function
                    cql:searchClause($clause as element(searchClause), $map) {&#xd; let $index-key
                    := $clause//index/text(), &#xd; $index := index:index-from-map($index-key
                    ,$map),&#xd; $index-type := ($index/xs:string(@type),'')[1],&#xd; $index-xpath
                    := index:index-as-xpath-from-map($index-key,$map,''), &#xd; $match-on :=
                    index:index-as-xpath-from-map($index-key,$map,'match-only'), &#xd; $relation :=
                    $clause/relation/value/text(),&#xd; $sanitized-term :=
                    cql:sanitize-term($clause/term),&#xd; (:$predicate := '' :)&#xd; $predicate :=
                    switch (true())&#xd; case ($index-type eq $index:INDEX_TYPE_FT) return
                    'ft:query('||$match-on||',&lt;query&gt;&lt;phrase&gt;'||$sanitized-term||'&lt;/phrase&gt;&lt;/query&gt;)'
                    &#xd; default return $match-on||"='"||$sanitized-term||"'"&#xd; &#xd; &#xd;
                    return $index-xpath||'['||$predicate||']'&#xd; &#xd; };&#xd; (:&#xd; declare
                    function cql:predicate($index-type as xs:string?, $relation as xs:string, $term
                    as xs:string) {&#xd; &#xd; };:)&#xd; &#xd; &#xd; declare function
                    cql:predicate($clause,$map) as xs:string {&#xd; let $clause :=
                    cql:searchClause($clause,$map)&#xd; return &#xd; if
                    (starts-with($clause,'('))&#xd; then "["||$clause||"]"&#xd; else
                    "[self::"||$clause||"]"&#xd; };&#xd; &#xd; declare function
                    cql:intersect($leftOperand as element(leftOperand), $rightOperand as
                    element(rightOperand), $map) as xs:string {&#xd; let $operands :=
                    (cql:process-xcql($leftOperand, $map), cql:process-xcql($rightOperand,
                    $map))&#xd; let $return := "("||string-join($operands,' intersect ')||")"&#xd;
                    return $return&#xd; };&#xd; &#xd; declare function cql:except($leftOperand as
                    element(leftOperand), $rightOperand as element(rightOperand), $map) as xs:string
                    {&#xd; let $operands :=
                    (cql:process-xcql($leftOperand,$map),cql:process-xcql($rightOperand,$map))&#xd;
                    return "("||string-join($operands,' except ')||")"&#xd; };&#xd; &#xd; declare
                    function cql:union($leftOperand as element(leftOperand), $rightOperand as
                    element(rightOperand), $map) as xs:string {&#xd; let $operands :=
                    (cql:process-xcql($leftOperand,$map),cql:process-xcql($rightOperand,$map))&#xd;
                    return "("||string-join($operands,' union ')||")"&#xd; };&#xd; &#xd; &#xd; (:~
                    remove quotes :)&#xd; declare function cql:sanitize-term($term) {&#xd;
                    $term&#xd; (:switch (true())&#xd; case (starts-with($term, '''')) return
                    translate($term,'''','')&#xd; case (starts-with($term, '%22')) return
                    translate($term,'%22','')&#xd; default return $term:)&#xd; };</f>
                <f n="query.xqm">xquery version "3.0";&#xd; (:~ This module provides methods to
                    transform process (CQL) query&#xd; : @see http://clarin.eu/fcs &#xd; : @author
                    Matej Durco&#xd; : @since 2014-02-06&#xd; : @version 1.1 &#xd; :)&#xd; module
                    namespace query = "http://aac.ac.at/content_repository/query";&#xd; &#xd; import
                    module namespace cql = "http://exist-db.org/xquery/cql" at "cql.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "../diagnostics/diagnostics.xqm";&#xd; import module namespace index =
                    "http://aac.ac.at/content_repository/index" at "../../core/index.xqm";&#xd;
                    declare namespace tei = "http://www.tei-c.org/ns/1.0";&#xd; declare namespace
                    cr="http://aac.ac.at/content_repository";&#xd; declare namespace fcs =
                    "http://clarin.eu/fcs/1.0";&#xd; &#xd; &#xd; &#xd; declare function
                    query:execute-query($cql as xs:string, $data as node()*, $project) as node()*
                    {&#xd; &#xd; let $xpath := cql:cql-to-xpath($cql, $project)&#xd; return
                    util:eval("($data)//"||$xpath)&#xd; (: return $xpath:)&#xd; &#xd; };</f>
            </d>
            <d n="resource">
                <f n="handle.xqm">xquery version "3.0";&#xd; module namespace handle =
                    "http://aac.ac.at/content_repository/handle";&#xd; &#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace repo-utils="http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace
                    project="http://aac.ac.at/content_repository/project" at
                    "../../core/project.xqm";&#xd; import module namespace
                    resource="http://aac.ac.at/content_repository/resource" at
                    "../../core/resource.xqm";&#xd; &#xd; declare namespace cmd =
                    "http://www.clarin.eu/cmd/";&#xd; &#xd; declare function
                    handle:credentials($project-pid) as map() {&#xd; let $params : =
                    config:config($project-pid)//module[@key='resource']/param,&#xd; $service :=
                    $params[@key = 'pid-service'],&#xd; $username := $params[@key =
                    'pid-username'],&#xd; $password := $params[@key = 'pid-pwd']&#xd; return &#xd;
                    map{&#xd; "service-url" := $service,&#xd; "username" := $username,&#xd;
                    "password" := $password&#xd; }&#xd; };&#xd; &#xd; (:~&#xd; : Registers a new
                    handle for the given uri.&#xd; : @param $uri the URI to register&#xd; : @param
                    $project-pid The PID of the current project &#xd; :)&#xd; declare function
                    handle:create($url as xs:string, $project-pid as xs:string) as xs:string {&#xd;
                    let $data := concat('[{"type":"URL","parsed_data":"', $url , '"}]')&#xd; return
                    handle:send($data,"create",(),$project-pid)&#xd; };&#xd; &#xd; &#xd; (:~&#xd; :
                    Updates the target URI of a given handle.&#xd; : @param $url the new URL&#xd; :
                    @param $handle-url the URL of the handle&#xd; : @param $project-pid The PID of
                    the current project &#xd; :)&#xd; declare function handle:update($url as
                    xs:anyURI, $handle-url as xs:anyURI, $project-pid as xs:string) {&#xd; let $data
                    := concat('[{"type":"URL","parsed_data":"', $url , '"}]')&#xd; return
                    handle:send($data,"update",$handle-url,$project-pid)&#xd; };&#xd; &#xd; (:~&#xd;
                    : Removes a given handle.&#xd; : @param $handle-url the URL of the handle&#xd; :
                    @param $project-pid The PID of the current project &#xd; :)&#xd; declare
                    function handle:remove($handle-url as xs:anyURI, $project-pid as xs:string)
                    {&#xd; let $data := concat('[{"type":"URL","parsed_data":"', $url , '"}]')&#xd;
                    return handle:send((),"remove",$handle-url,$project-pid)&#xd; };&#xd; &#xd;
                    &#xd; declare %private function handle:send($data as xs:string?, $action as
                    xs:string, $handle-url as xs:string?, $project-pid as xs:string) {&#xd; let
                    $creds := handle:credentials($project-pid)&#xd; let $auth := concat("Basic ",
                    util:string-to-binary(concat($creds("username"), ':', $creds("password"))))&#xd;
                    let $headers := &lt;headers&gt;&#xd; &lt;header name="Authorization"
                    value="{$auth}"/&gt;&#xd; &lt;header name="Content-Type"
                    value="application/json"/&gt; &#xd; &lt;/headers&gt;&#xd; return &#xd; switch
                    ($action)&#xd; case "update" return &#xd;
                    httpclient:put(xs:anyURI($handle-url),&#xd; $data,&#xd; true(),&#xd;
                    $headers)&#xd; case "create" return&#xd;
                    httpclient:post(xs:anyURI($handle-url),&#xd; $data,&#xd; true(),&#xd;
                    $headers)&#xd; default return
                    util:log-app("INFO",$config:app-name,"resource:register-handle(): method
                    '"||$method||"' is not implemented.")&#xd; };&#xd; &#xd; &#xd; </f>
                <f n="resource.xql">xquery version "3.0";&#xd; import module namespace
                    request="http://exist-db.org/xquery/request";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "../diagnostics/diagnostics.xqm";&#xd; import module namespace crday =
                    "http://aac.ac.at/content_repository/data-ay" at "../aqay/crday.xqm";&#xd;
                    import module namespace resource = "http://cr-xq/resource" at
                    "resource.xqm";&#xd; (:import module namespace fcs-tests =
                    "http://clarin.eu/fcs/1.0/tests" at "tests.xqm";:)&#xd; &#xd; (:~
                    action-list:&#xd; resources-overview - default&#xd; ay-xml-run&#xd;
                    ay-xml-view&#xd; :)&#xd; &#xd; let $action := request:get-parameter("action",
                    ""),&#xd; (: $config := doc($config-path),&#xd; $config :=
                    repo-utils:config($config-path), :) &#xd; $project :=
                    request:get-parameter("project",""),&#xd; $config :=
                    config:config($project),&#xd; $x-context := request:get-parameter("x-context",
                    $project),&#xd; &#xd; $result := if ($action eq '' or $action eq
                    'resources-overview' ) then&#xd; let $format :=
                    request:get-parameter("x-format",'htmlpage')&#xd; return
                    resource:display-overview($config, $x-context, $format)&#xd; &#xd; else if
                    (contains ($action, 'ay-xml')) then&#xd; let $format :=
                    request:get-parameter("x-format",'terms2htmldetail'),&#xd; $init-path :=
                    request:get-parameter("init-path", ""), &#xd; $max-depth :=
                    request:get-parameter("x-maximumDepth", $crday:defaultMaxDepth)&#xd; return
                    crday:get-ay-xml($config, $x-context, $init-path, $max-depth, (contains($action,
                    'run')), $format)&#xd; &#xd; else &#xd;
                    diag:diagnostics("unsupported-operation", $action)&#xd; &#xd; let $opt :=
                    util:declare-option("exist:serialize", "media-type=text/html method=xhtml")
                    &#xd; return &lt;html&gt;&#xd; &lt;head&gt;&#xd; &lt;title&gt;Project
                    overview&lt;/title&gt;&#xd; &lt;meta http-equiv="Content-Type"
                    content="text/html; charset=UTF-8"/&gt;&#xd; &lt;link rel="stylesheet"
                    type="text/css"
                    href="/exist/apps/cr-xq/modules/shared/scripts/style/cmds-ui.css" /&gt;&#xd;
                    &lt;/head&gt;&#xd; &lt;body&gt; &#xd; &lt;div id="header"&gt;&#xd; &lt;!--
                    &lt;ul id="menu"&gt; &#xd; &lt;li&gt;&lt;a
                    href="collectresults.xql"&gt;Results&lt;/a&gt;&lt;/li&gt;&#xd; &lt;/ul&gt;--&gt;
                    &#xd; &lt;h1&gt;Project data overview&lt;/h1&gt;&#xd; &lt;a
                    href="resource?action=resources-overview"&gt;resources &lt;/a&gt; &lt;a
                    href="aqay?action=queryset-overview"&gt; querysets&lt;/a&gt;&#xd;
                    &lt;/div&gt;&#xd; &lt;div id="content-wrapper"&gt; {$result }&lt;/div&gt;&#xd;
                    &lt;/body&gt;&#xd; &lt;/html&gt; &#xd; &#xd; </f>
                <f n="resource.xqm">xquery version "3.0";&#xd; &#xd; (:~ a module to handle
                    resources and their corresponding metadata&#xd; &#xd; provide a common
                    getter&#xd; pid-handling&#xd; &#xd; not TESTED yet!&#xd; especially
                    PID-assignement&#xd; :)&#xd; &#xd; module namespace resource =
                    "http://cr-xq/resource" ;&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace
                    httpclient="http://exist-db.org/xquery/httpclient";&#xd; import module namespace
                    util="http://exist-db.org/xquery/util";&#xd; import module namespace fcs =
                    "http://clarin.eu/fcs/1.0" at "../fcs/fcs.xqm";&#xd; import module namespace
                    crday = "http://aac.ac.at/content_repository/data-ay" at
                    "../aqay/crday.xqm";&#xd; &#xd; &#xd; (:declare namespace tei =
                    "http://www.tei-c.org/ns/1.0" ;:)&#xd; declare namespace
                    templates="http://exist-db.org/xquery/templates";&#xd; declare namespace cmd=
                    "http://www.clarin.eu/cmd/"; &#xd; declare namespace cr =
                    "http://aac.ac.at/content-repository";&#xd; declare namespace xhtml =
                    "http://www.w3.org/1999/xhtml";&#xd; &#xd; &#xd; (:~ default viewer, fetching
                    data, transforming with xslt &#xd; based on text-viewer &#xd; tries to get the
                    resources matching the @xml:id, then the filename (in the data- and
                    metadata-path)&#xd; &#xd; @param $id id can be @xml:id or file-name&#xd; :)&#xd;
                    &#xd; declare function resource:get ($config-map, $id as xs:string) {&#xd; &#xd;
                    let $sanitized-id := repo-utils:sanitize-name($id),&#xd; $data-dir :=
                    config:param-value($config-map, 'data-dir'),&#xd; $data-coll := if ($data-dir eq
                    "" ) then ()&#xd; else collection($data-dir),&#xd; $resource-by-id :=
                    $data-coll//*[@xml:id eq $id],&#xd; $resource := if (exists($resource-by-id))
                    then $resource-by-id&#xd; else if ($data-dir ne "" ) then&#xd; if
                    (doc-available(concat($data-dir, '/', $sanitized-id))) then&#xd;
                    doc(concat($data-dir, '/', $sanitized-id))&#xd; (: if not resource found, try to
                    get a metadata-record :)&#xd; else resource:getMD($config-map,$id)&#xd; else
                    resource:getMD($config-map,$id)&#xd; &#xd; &#xd; &#xd; return if
                    (exists($resource)) then $resource &#xd; else
                    &lt;diagnostics&gt;&lt;message&gt;Resource unavailable, id: { ($id, ' in ',
                    data-dir) } &lt;/message&gt;&lt;/diagnostics&gt; &#xd; &#xd; };&#xd; &#xd; &#xd;
                    (:~ tries to get the metadata-record to a resource, based on ID &#xd; but this
                    is not clean yet &#xd; &#xd; TODO: make the query (@xml:id) to use index!&#xd;
                    &#xd; :)&#xd; declare function resource:getMD ($config-map, $id as xs:string)
                    {&#xd; &#xd; let $metadata-dir := config:param-value($config-map,
                    'metadata-path'),&#xd; $id-cmd := concat($id, '.cmd'),&#xd; $sanitized-id :=
                    repo-utils:sanitize-name($id-cmd),&#xd; (: if no metadata-dir specified (or
                    empty) dont search! (otherwise `collection('')`would go through whole db!!
                    :)&#xd; $md-coll := if ($metadata-dir eq "" ) then ()&#xd; else
                    collection($metadata-dir),&#xd; $md-record-by-id := $md-coll//*[@xml:id =
                    ($id,$id-cmd)],&#xd; (:$md-record := if (exists($md-record-by-id)) then
                    $md-record-by-id &#xd; else if (doc-available(concat($metadata-dir, '/',
                    $sanitized-id))) then&#xd; doc(concat($metadata-dir, '/', $sanitized-id))&#xd;
                    else ():)&#xd; $md-record := if (exists($md-record-by-id)) then $md-record-by-id
                    &#xd; else if ($metadata-dir ne "" ) then &#xd; if
                    (doc-available(concat($metadata-dir, '/', $sanitized-id))) then&#xd;
                    doc(concat($metadata-dir, '/', $sanitized-id))&#xd; else ()&#xd; else ()&#xd;
                    &#xd; return if (exists($md-record)) then $md-record &#xd; else
                    &lt;diagnostics&gt;&lt;message&gt;MD-record unavailable, id: { ($id, ' in ',
                    $metadata-dir) } &lt;/message&gt;&lt;/diagnostics&gt; &#xd; &#xd; };&#xd; &#xd;
                    &#xd; (:~ overload function with default format-param = htmlpage:)&#xd;
                    (:declare function crday:display-overview($config-path as xs:string) as item()*
                    {&#xd; crday:display-overview($config-path, 'htmlpage')&#xd; };:)&#xd; &#xd;
                    declare function resource:display-overview($config) as item()* {&#xd;
                    resource:display-overview($config, '', 'htmlpage')&#xd; };&#xd; &#xd; &#xd; (:~
                    creates a html-overview of the datasets based on the defined mappings (as linked
                    to from config)&#xd; &#xd; @param config config-object (not map)&#xd; @param
                    format [raw, htmlpage, html] - raw: return only the produced table, html* :
                    serialize as html &#xd; @returns a html-table with overview of the datasets&#xd;
                    :)&#xd; declare function resource:display-overview($config, $x-context as
                    xs:string, $format as xs:string ) as item()* {&#xd; &#xd; (: let $config :=
                    doc($config-path), &#xd; let $config := repo-utils:config($config-path),:)&#xd;
                    (: let $mappings := doc(repo-utils:config-value($config, 'mappings')),:)&#xd;
                    let $context-mapping := fcs:get-mapping('',$x-context, $config),&#xd; (: if not
                    specific mapping found for given context, use whole mappings-file :)&#xd;
                    $mappings := if ($context-mapping/xs:string(@key) = $x-context) then
                    $context-mapping &#xd; else doc(repo-utils:config-value($config, 'mappings')),
                    &#xd; $baseadminurl := repo-utils:config-value($config, 'admin.url') &#xd; &#xd;
                    let $opt := util:declare-option("exist:serialize", "media-type=text/html
                    method=xhtml")&#xd; &#xd; let $coll-overview := &lt;div
                    id="collections-overview"&gt;&#xd; &lt;h2&gt;Collections
                    overview&lt;/h2&gt;&#xd; &lt;table
                    class="show"&gt;&lt;tr&gt;&lt;th&gt;collection&lt;/th&gt;&lt;th&gt;path&lt;/th&gt;&lt;th&gt;file&lt;/th&gt;&lt;th&gt;resources&lt;/th&gt;&lt;th
                    colspan="2"&gt;base-elem&lt;/th&gt;&#xd;
                    &lt;th&gt;indexes&lt;/th&gt;&lt;th&gt;struct&lt;/th&gt;&lt;th&gt;md&lt;/th&gt;&lt;/tr&gt;&#xd;
                    { for $map in $mappings/descendant-or-self::map[@key]&#xd; let $map-key :=
                    $map/xs:string(@key),&#xd; $map-dbcoll-path := $map/xs:string(@path),&#xd; (:
                    $map-dbcoll:= if ($map-dbcoll-path ne '' and xmldb:collection-available
                    (($map-dbcoll-path,"")[1])) then collection($map-dbcoll-path) else (), :)&#xd;
                    $map-dbcoll:= repo-utils:context-to-collection($map-key, $config),&#xd;
                    $resources:= fcs:apply-index($map-dbcoll,'fcs.resource',$map-key,$config),&#xd;
                    $base-elems:=
                    fcs:apply-index($map-dbcoll,'cql.serverChoice',$map-key,$config),&#xd; &#xd; (:
                    $queries-doc-name := crday:check-queries-doc-name($config, $map-key),:)&#xd;
                    $sturct-doc-name := repo-utils:gen-cache-id("structure", ($map-key,""),
                    xs:string($crday:defaultMaxDepth)),&#xd; $invoke-href :=
                    concat($baseadminurl,'?x-context=', $map-key ,'&amp;amp;action=' ), &#xd;
                    (:$queries := if (repo-utils:is-in-cache($queries-doc-name, $config)) then &#xd;
                    &lt;a href="{concat($invoke-href,'xpath-queryset-view')}" &gt;view&lt;/a&gt;
                    &#xd; else (),:) &#xd; $structure := if
                    (repo-utils:is-in-cache($sturct-doc-name, $config)) then &#xd; &lt;a
                    href="{concat($invoke-href,'ay-xml-view')}" &gt;view&lt;/a&gt; &#xd; else
                    (),&#xd; $md := resource:getMD(map { "config" := $config},
                    $map-key)//cmd:MdSelfLink/text()&#xd; return &lt;tr&gt;&#xd;
                    &lt;td&gt;{$map-key}&lt;/td&gt;&#xd;
                    &lt;td&gt;{$map-dbcoll-path}&lt;/td&gt;&#xd; &lt;td
                    align="right"&gt;{count($map-dbcoll)}&lt;/td&gt;&#xd; &lt;td
                    align="right"&gt;&lt;a
                    href="fcs?x-context={$map-key}&amp;amp;operation=scan&amp;amp;scanClause=fcs.resource&amp;amp;x-format={$format}"&gt;{count($resources)}&lt;/a&gt;&lt;/td&gt;&#xd;
                    &lt;td&gt;{$map/xs:string(@base_elem)}&lt;/td&gt;&#xd;
                    &lt;td&gt;{count($base-elems)}&lt;/td&gt;&#xd; &lt;td align="right"&gt;&lt;a
                    href="fcs?x-context={$map-key}&amp;amp;operation=explain&amp;amp;x-format={$format}"&gt;{count($map/index)}&lt;/a&gt;&lt;/td&gt;&#xd;
                    &lt;td&gt;{$structure} [&lt;a href="{concat($invoke-href,'ay-xml-run')}"
                    &gt;run&lt;/a&gt;]&lt;/td&gt;&#xd; &lt;td&gt;&lt;a
                    href="{$md}"&gt;{$md}&lt;/a&gt;&lt;/td&gt;&#xd; &lt;/tr&gt;&#xd; }&#xd;
                    &lt;/table&gt;&lt;/div&gt;&#xd; &#xd; (: &lt;td align="right"&gt;&lt;a
                    href="fcs?x-context={$map-key}&amp;amp;operation=explain&amp;amp;x-format={$format}"&gt;{count($map/index)}&lt;/a&gt;&lt;/td&gt;&#xd;
                    &lt;td&gt;&lt;a href="{$md}"&gt;{$md}&lt;/a&gt;&lt;/td&gt;&#xd; let
                    $base-elems:=
                    fcs:apply-index($resource,'cql.serverChoice',$x-context,$config)&#xd;
                    &lt;td&gt;{count($base-elems)}&lt;/td&gt;&#xd; :) &#xd; let $dbcoll :=
                    repo-utils:context-to-collection($x-context, $config),&#xd; $resource-ids:=
                    fcs:apply-index($dbcoll,'fcs.resource',$x-context,$config)&#xd; &#xd; let
                    $resources-overview := &lt;div id="resources-overview"&gt;&#xd;
                    &lt;h2&gt;Resources overview&lt;/h2&gt;&#xd; &lt;table
                    class="show"&gt;&lt;tr&gt;&lt;th&gt;resources&lt;/th&gt;&lt;th&gt;file&lt;/th&gt;&#xd;
                    &lt;th&gt;base-elem&lt;/th&gt;&lt;th&gt;md-id /
                    md-selflink&lt;/th&gt;&lt;/tr&gt;&#xd; { &#xd; for $resource-id in
                    $resource-ids&#xd; let $resource := resource:get(map { "config" := $config},
                    $resource-id),&#xd; $pid := $resource/xs:string(@cr:pid),&#xd; $base-elems:=
                    fcs:apply-index($resource,'cql.serverChoice',$x-context,$config),&#xd; $md :=
                    resource:getMD(map { "config" := $config}, $resource-id),&#xd; $md-id :=
                    $md/xs:string(@xml:id),&#xd; $md-selflink:= $md//cmd:MdSelfLink/text()&#xd;
                    &#xd; return &lt;tr&gt;&#xd; &lt;td&gt;&lt;a
                    href="get/{$resource-id}?format=html"&gt;{$resource-id}&lt;/a&gt;&lt;br/&gt;&#xd;
                    &lt;a href="{$pid}"&gt;{$pid}&lt;/a&gt;&#xd; &lt;/td&gt;&#xd;
                    &lt;td&gt;{util:document-name($resource)}&lt;/td&gt;&#xd; &#xd;
                    &lt;td&gt;{count($base-elems)}&lt;/td&gt;&#xd; &lt;td&gt;&lt;a
                    href="get/{$md-id}?format=html"&gt;{$md-id}&lt;/a&gt;&lt;br/&gt;&#xd; &lt;a
                    href="{$md-selflink}"&gt;{$md-selflink}&lt;/a&gt;&lt;/td&gt;&#xd;
                    &lt;/tr&gt;&#xd; }&#xd; &#xd; &lt;/table&gt;&lt;/div&gt;&#xd; &#xd; let $indexes
                    := distinct-values($mappings//index/xs:string(@key))&#xd; let $indexes-overview
                    := &lt;div&gt;&lt;h2&gt;Indexes overview&lt;/h2&gt;&#xd; &lt;table
                    class="show"&gt;&#xd; &lt;tr&gt;&lt;th&gt;collection&lt;/th&gt;{ for $map in
                    $mappings/descendant-or-self::map[@key]&#xd; return &lt;th&gt;{
                    $map/xs:string(@key)} &lt;/th&gt;}&lt;/tr&gt;&#xd; &lt;tbody&gt;{&#xd; for
                    $index in $indexes &#xd; (:let $map-key:=
                    $index/parent::map/xs:string(@key),&#xd; $map-dbcoll:=
                    repo-utils:context-to-collection($map-key, $config),&#xd; $resources:=
                    fcs:apply-index($map-dbcoll,'fcs.resource',$x-context,$config),&#xd; &#xd;
                    $invoke-href := concat($baseadminurl,'?x-context=', $map-key ,'&amp;amp;action='
                    ):) &#xd; &#xd; return &lt;tr&gt;&#xd; &lt;td&gt;{$index}&lt;/td&gt;&#xd; { for
                    $map in $mappings/descendant-or-self::map[@key]&#xd; let $context-key :=
                    $map/xs:string(@key)&#xd; (: fetch scan from cache - if available :) &#xd; let
                    $sanitized-xcontext := repo-utils:sanitize-name($context-key) &#xd; let
                    $index-doc-name := repo-utils:gen-cache-id("index", ($sanitized-xcontext,
                    $index, 'text', 1 ))&#xd; let $index-scan := if
                    (repo-utils:is-in-cache($index-doc-name, $config)) then&#xd;
                    repo-utils:get-from-cache($index-doc-name, $config)&#xd; else ()&#xd; let
                    $index-size := $index-scan//fcs:countTerms/text()&#xd; let $context-index := if
                    ($index-size) then $index-size else 'run'&#xd; (: let $context-index :=
                    'x':)&#xd; let $href :=
                    concat("fcs?operation=scan&amp;amp;scanClause=",$index,"&amp;amp;x-context=",$context-key,
                    "&amp;amp;x-format=", $format)&#xd; return &lt;td&gt;{if
                    ($map/index[xs:string(@key)=$index]) then &lt;a href="{$href}"
                    &gt;{$context-index}&lt;/a&gt; else '' }&lt;/td&gt; }&#xd; &lt;/tr&gt;&#xd;
                    }&lt;/tbody&gt;&#xd; &lt;/table&gt;&#xd; &lt;/div&gt;&#xd; &#xd; return
                    ($coll-overview, $resources-overview, $indexes-overview)&#xd; (:return if
                    ($format eq 'raw') then&#xd; $overview&#xd; else &#xd;
                    repo-utils:serialise-as($overview, $format, 'html', $config, ()):)&#xd; };&#xd;
                    &#xd; &#xd; declare function resource:get-fcs-resource-scan($config, $run-flag
                    as xs:boolean, $format as xs:string ) as item()* {&#xd; &#xd; (:$config :=
                    doc($config-path),:)&#xd; let $name := repo-utils:gen-cache-id("index", ('',
                    'fcs.resource', 'text'), xs:string(1)),&#xd; $result := &#xd; if
                    (repo-utils:is-in-cache($name, $config) and not($run-flag)) then&#xd;
                    repo-utils:get-from-cache($name, $config)&#xd; else&#xd; let $data :=
                    resource:gen-fcs-resource-scan($config)&#xd; return
                    repo-utils:store-in-cache($name, $data,$config)&#xd; &#xd; return if ($format eq
                    'raw') then&#xd; $result&#xd; else &#xd; repo-utils:serialise-as($result,
                    $format, 'scan', $config, ()) &#xd; };&#xd; &#xd; (:~ gen fcs-resource scan out
                    of mappings &#xd; not sure if and where currently used &#xd; :)&#xd; declare
                    function resource:gen-fcs-resource-scan($config as node()) as item()* {&#xd;
                    &#xd; let $mappings := doc(repo-utils:config-value($config, 'mappings'))&#xd;
                    &#xd; (: let $opt := util:declare-option("exist:serialize",
                    "media-type=text/html method=xhtml"):)&#xd; &#xd; let $map2terms := for $map in
                    $mappings//map[@key]&#xd; let $context-key := $map/xs:string(@key),&#xd;
                    $context-label := if ($map/@label) then $map/xs:string(@label) else
                    $map/xs:string(@key), &#xd; $map-dbcoll-path := $map/xs:string(@path),&#xd; (:
                    $map-dbcoll:= if ($map-dbcoll-path ne '' and xmldb:collection-available
                    (($map-dbcoll-path,"")[1])) then collection($map-dbcoll-path) else (), :)&#xd;
                    $map-dbcoll:= repo-utils:context-to-collection($context-key, $config) &#xd;
                    return &lt;sru:term&gt;&#xd; &lt;sru:value&gt;{ $context-key
                    }&lt;/sru:value&gt;&#xd;
                    &lt;sru:numberOfRecords&gt;{count($map-dbcoll)}&lt;/sru:numberOfRecords&gt;&#xd;
                    &lt;sru:displayTerm&gt;{$context-label}&lt;/sru:displayTerm&gt; &#xd;
                    &lt;/sru:term&gt;&#xd; &#xd; let $count-all := count($map2terms) &#xd;
                    return&#xd; &lt;sru:scanResponse xmlns:sru="http://www.loc.gov/zing/srw/"
                    xmlns:fcs="http://clarin.eu/fcs/1.0"&gt;&#xd;
                    &lt;sru:version&gt;1.2&lt;/sru:version&gt; &#xd; &lt;sru:terms&gt; &#xd;
                    {$map2terms }&#xd; &lt;/sru:terms&gt;&#xd; &lt;sru:extraResponseData&gt;&#xd;
                    &lt;fcs:countTerms&gt;{$count-all}&lt;/fcs:countTerms&gt;&#xd;
                    &lt;/sru:extraResponseData&gt;&#xd; &lt;sru:echoedScanRequest&gt; &#xd;
                    &lt;sru:scanClause&gt;fcs.resource&lt;/sru:scanClause&gt;&#xd;
                    &lt;/sru:echoedScanRequest&gt;&#xd; &lt;/sru:scanResponse&gt; &#xd; &#xd;
                    };&#xd; &#xd; &#xd; &#xd; &#xd; (:~ add an id to given resources (expect one per
                    file, or per given element?)&#xd; @param $path (relative) xpath to the
                    resource-nodes, if empty or '' root-elements of files in project-data-directory
                    are assumed&#xd; always evaluated in the context of project-data-dir,
                    path-separators ('/' or '//') will be added&#xd; @param $mode add-only, replace,
                    dry-run &#xd; @prefix for the id&#xd; @return number of processed resources :)
                    &#xd; declare function resource:addID($config-map, $path as xs:string?, $mode as
                    xs:string?, $prefix as xs:string, $log-doc as node()*) as item()* {&#xd; &#xd;
                    let $resolved-path := if ($path='' or not(exists($path ))) then '/*' else
                    concat('//', $path) &#xd; &#xd; let $data-dir := config:param-value($config-map,
                    'data-dir'), &#xd; $resources := util:eval(concat("collection($data-dir)",
                    $resolved-path))&#xd; &#xd; let $result :=count($resources) &#xd; &#xd; let
                    $update := if ($mode='replace') then &#xd; &#xd; for $resource at $pos in
                    $resources&#xd; return update insert attribute xml:id {concat($prefix, $pos)}
                    into $resource&#xd; else ()&#xd; &#xd; return ($result, $update)&#xd; &#xd;
                    };&#xd; &#xd; (:~ add PID to given resources (expect one per file, or per given
                    element?)&#xd; @param $path (relative) xpath to the resource-nodes, if empty or
                    '' root-elements of files in project-data-directory are assumed&#xd; always
                    evaluated in the context of project-data-dir, path-separators ('/' or '//') will
                    be added&#xd; @param $mode add-only, replace, dry-run &#xd; @prefix for the
                    id&#xd; @return number of processed resources :) &#xd; declare function
                    resource:addPID($config-map, $path as xs:string?, $mode as xs:string?, $prefix
                    as xs:string, $log-doc as node()*) as item()* {&#xd; &#xd; let $resolved-path :=
                    if ($path='' or not(exists($path ))) then '/*[@xml:id]' else concat('//', $path)
                    &#xd; &#xd; let $data-dir := config:param-value($config-map, 'data-dir'), &#xd;
                    $resources := util:eval(concat("collection($data-dir)", $resolved-path))&#xd;
                    &#xd; let $result :=count($resources) &#xd; &#xd; let $update := if
                    ($mode='replace') then &#xd; &#xd; for $resource at $pos in $resources&#xd; let
                    $pid := resource:getPID($config-map, $resource/@xml:id)&#xd; return update
                    insert attribute cr:pid {$pid} into $resource&#xd; else ()&#xd; &#xd; return
                    ($result, $update)&#xd; &#xd; };&#xd; &#xd; (:~ send a request to PID-service,
                    to receive a new PID for given resource, &#xd; send target-url as param&#xd;
                    http://clarin.aac.ac.at/cr/get?id=$id&#xd; &#xd; corresponds to:&#xd; curl -o
                    create-output.html -v -u 'USERNAME:PASSWORD' -H "Accept:application/json" -H
                    "Content-Type:application/json" -X POST --data
                    '[{"type":"URL","parsed_data":"http://www.gwdg.de/TEST/1234"}]'
                    "http://pid.gwdg.de/handles/11022/"&#xd; &#xd; requires credentials to be set in
                    the config&#xd; &lt;param
                    key="pid-service"&gt;http://pid-test.gwdg.de/handles/11022/&lt;/param&gt;&#xd;
                    &lt;param key="pid-resolver"&gt;http://&lt;/param&gt;&#xd; &lt;param
                    key="pid-username"&gt;1013-01&lt;/param&gt;&#xd; &lt;param
                    key="pid-pwd"&gt;pwd&lt;/param&gt;&#xd; &#xd; :)&#xd; declare function
                    resource:getPID($config-map, $id as xs:string) as xs:anyURI? {&#xd; &#xd; (:
                    xs:anyURI(concat( 'pid:icltt:', $id)):)&#xd; &#xd; (: PID-service :)&#xd; let
                    $pid-service := config:param-value($config-map, 'pid-service'),&#xd;
                    $pid-resolver := config:param-value($config-map, 'pid-resolver'),&#xd; $username
                    := config:param-value($config-map, 'pid-username'),&#xd; $password :=
                    config:param-value($config-map, 'pid-pwd')&#xd; &#xd; (: declare variable
                    $baseurl := 'http://clarin.aac.ac.at/cr/get/';:)&#xd; let $baseurl :=
                    config:param-value($config-map, 'base-url'),&#xd; $target-url :=
                    concat($baseurl, $id)&#xd; &#xd; let $auth := concat("Basic ",
                    util:string-to-binary(concat($username, ':', $password)))&#xd; let $headers :=
                    &lt;headers&gt;&lt;header name="Authorization" value="{$auth}"/&gt;&#xd;
                    &lt;header name="Content-Type" value="application/json"/&gt; &#xd;
                    &lt;/headers&gt;&#xd; &#xd; let $post-data :=
                    concat('[{"type":"URL","parsed_data":"', $url , '"}]')&#xd; let $result :=
                    httpclient:post(xs:anyURI($rest), $data, true(), $headers),&#xd; (: fish the new
                    pid out of the html-result:&#xd; &lt;dl
                    class="rackful-object"&gt;&lt;dt&gt;location&lt;/dt&gt;&lt;dd&gt;&lt;a
                    href="0000-0000-0028-3"&gt;0000-0000-0028-3&lt;/a&gt;&lt;/dd&gt; :)&#xd;
                    $new-pid := $result//xhtml:dl/xhtml:dd/xhtml:a/text() &#xd; &#xd; return if
                    (exists($new-pid)) then &#xd; concat($pid-resolver, $new-pid)&#xd; else ()&#xd;
                    &#xd; };&#xd; &#xd; (:~ match resource and metadata &#xd; based on
                    resource-filename or -id&#xd; &#xd; stub - NOT FINISHED!&#xd; &#xd; @param $mode
                    add-only, replace, dry-run &#xd; @prefix for the id&#xd; @return number of
                    processed resources :) &#xd; declare function resource:mapMD($config-map, $path
                    as xs:string?, $mode as xs:string?, $prefix as xs:string, $log-doc as node()*)
                    as item()* {&#xd; &#xd; let $resolved-path := if ($path='' or not(exists($path
                    ))) then '/*[@xml:id]' else concat('//', $path) &#xd; &#xd; let $data-dir :=
                    config:param-value($config-map, 'data-dir'), &#xd; $metadata-path :=
                    config:param-value($config-map, 'metadata-path'),&#xd; $resources :=
                    util:eval(concat("collection($data-dir)", $resolved-path)),&#xd; $resource-ids
                    := $resources/xs:string(@xml:id), &#xd; $metadata :=
                    collection($metadata-path)&#xd; &#xd; let $result :=count($resources) &#xd;
                    &#xd; let $map :=
                    $metadata/cmd:CMD[.//cmd:ResourceProxy/xs:string(@id)=$resource-ids]/cmd:Header/cmd:MdSelfLink/text()&#xd;
                    (: let $map := $metadata/cmd:CMD//cmd:ResourceProxy/xs:string(@id):)&#xd; &#xd;
                    return ($result, $resource-ids, $map)&#xd; &#xd; };&#xd; </f>
            </d>
            <d n="shared">
                <d n="scripts">
                    <d n="css">
                        <d n="jquery">
                            <d n="images"/>
                        </d>
                        <d n="jquery-ui-1.10.4.custom-smoothness">
                            <d n="images"/>
                        </d>
                    </d>
                    <d n="js">
                        <d n="jquery"/>
                        <d n="query_input"/>
                    </d>
                    <d n="style">
                        <d n="img"/>
                        <d n="imgs"/>
                        <d n="jquery">
                            <d n="base">
                                <d n="images"/>
                            </d>
                            <d n="clarindotblue">
                                <d n="images"/>
                            </d>
                            <d n="treetable">
                                <d n="images"/>
                            </d>
                        </d>
                    </d>
                </d>
            </d>
            <d n="smc">
                <f n="smc.xql">xquery version "1.0";&#xd; &#xd; import module namespace smc =
                    "http://clarin.eu/smc" at "smc.xqm";&#xd; import module namespace crday =
                    "http://aac.ac.at/content_repository/data-ay" at "../aqay/crday.xqm";&#xd;
                    import module namespace repo-utils = "http://aac.ac.at/content_repository/utils"
                    at "../../core/repo-utils.xqm";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at
                    "/db/apps/cr-xq/core/config.xqm";&#xd; import module namespace diag =
                    "http://www.loc.gov/zing/srw/diagnostic/" at
                    "modules/diagnostics/diagnostics.xqm";&#xd; (: import module namespace cmdcheck
                    = "http://clarin.eu/cmd/check" at "/db/cr/modules/cmd/cmd-check.xqm"; :)&#xd;
                    &#xd; declare namespace cmd = "http://www.clarin.eu/cmd/";&#xd; &#xd; let
                    $dcr-cmd-map := doc("/db/apps/cr-xq/modules/smc/data/dcr-cmd-map.xml")&#xd; let
                    $xsl-smc-op := doc("/db/apps/cr-xq/modules/smc/xsl/smc_op.xsl")&#xd; &#xd; let
                    $format := request:get-parameter("x-format",'htmlpage'),&#xd; $op :=
                    request:get-parameter("operation", "")&#xd; &#xd; let $x-context :=
                    "mdrepo",&#xd; $config := config:config($x-context)&#xd; &#xd; &#xd; let $result
                    := if ($op eq '' or contains ($op, 'mappings-overview')) then &#xd;
                    smc:mappings-overview($config, $format)&#xd; else if ($op = 'gen-mappings') then
                    &#xd; smc:gen-mappings($config, $x-context, true(), 'raw') &#xd; else if
                    (contains ($op, 'gen-graph')) then &#xd; smc:gen-graph($config, $x-context)&#xd;
                    else &#xd; diag:diagnostics("unsupported-operation", $op)&#xd; &#xd; &#xd;
                    return $result</f>
                <f n="smc.xqm">xquery version "1.0";&#xd; module namespace smc =
                    "http://clarin.eu/smc";&#xd; &#xd; import module namespace repo-utils =
                    "http://aac.ac.at/content_repository/utils" at "../../core/repo-utils.xqm";&#xd;
                    import module namespace crday = "http://aac.ac.at/content_repository/data-ay" at
                    "../aqay/crday.xqm";&#xd; import module namespace fcs =
                    "http://clarin.eu/fcs/1.0" at "../fcs/fcs.xqm";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    declare namespace sru = "http://www.loc.gov/zing/srw/";&#xd; &#xd; declare
                    variable $smc:termsets := doc("data/termsets.xml");&#xd; declare variable
                    $smc:dcr-terms := doc("data/dcr-terms.xml");&#xd; declare variable
                    $smc:cmd-terms := doc("data/cmd-terms.xml");&#xd; declare variable
                    $smc:xsl-terms2graph := doc("xsl/terms2graph.xsl");&#xd; declare variable
                    $smc:xsl-graph2json := doc("xsl/graph2json-d3.xsl");&#xd; declare variable
                    $smc:structure-file := '_structure';&#xd; &#xd; &#xd; &#xd; &#xd; (:~ mappings
                    overview&#xd; only process already created maps (i.e. (for now) don't run
                    mappings on demand, &#xd; because that would induce ay-xml - which takes very
                    long time and is not safe &#xd; :)&#xd; declare function
                    smc:mappings-overview($config, $format as xs:string) as item()* {&#xd; &#xd; let
                    $cache_path := repo-utils:config-value($config, 'cache.path'),&#xd; $mappings :=
                    collection($cache_path)/map[*]&#xd; &#xd; &#xd; &#xd; let $overview := if
                    (contains($format, "table")) then&#xd; &lt;table
                    class="show"&gt;&lt;tr&gt;&lt;th&gt;index
                    |{count(distinct-values($mappings//index/xs:string(@key)))}|&lt;/th&gt;&#xd;
                    {for $map in $mappings return &lt;th&gt;{concat($map/@profile-name, ' ',
                    $map/@context, ' |', count($map/index), '/', count($map/index/path),
                    '|')}&lt;/th&gt; } &#xd; &lt;/tr&gt; &#xd; { for $ix in
                    distinct-values($mappings//index/xs:string(@key))&#xd; let $datcat :=
                    $smc:dcr-terms//Concept[Term[@type='id']/concat(@set,':',text()) = $ix],&#xd;
                    $datcat-label := $datcat/Term[@type='mnemonic'],&#xd; $datcat-type :=
                    $datcat/@datcat-type,&#xd; $index-paths :=
                    $mappings//index[xs:string(@key)=$ix]/path&#xd; return &lt;tr&gt;&lt;td
                    valign="top"&gt;{(&lt;b&gt;{$datcat-label}&lt;/b&gt;, concat(' |',
                    count($index-paths/ancestor::map), '/', count($index-paths), '|'), &lt;br/&gt;,
                    concat($ix, ' ', $datcat-type))}&lt;/td&gt;&#xd; {for $map in $mappings&#xd; let
                    $paths := $map/index[xs:string(@key)=$ix]/path&#xd; return &lt;td
                    valign="top"&gt;&lt;ul&gt;{for $path in $paths&#xd; return &lt;li
                    title="{$path/text()}" &gt;{tokenize($path/text(),
                    '\.')[last()]}&lt;/li&gt;&#xd; }&lt;/ul&gt;&lt;/td&gt; &#xd; }&#xd;
                    &lt;/tr&gt;&#xd; }&#xd; &lt;/table&gt;&#xd; else &#xd; &lt;ul&gt; &#xd; { for
                    $ix in distinct-values($mappings//index/xs:string(@key))&#xd; let $datcat :=
                    $smc:dcr-terms//Concept[Term[@type='id']/concat(@set,':',text()) = $ix],&#xd;
                    $datcat-label := $datcat/Term[@type='mnemonic'],&#xd; $datcat-type :=
                    $datcat/@datcat-type&#xd; return
                    &lt;li&gt;&lt;span&gt;{(&lt;b&gt;{$datcat-label}&lt;/b&gt;, &lt;br/&gt;,
                    concat($ix, ' ', $datcat-type))}&lt;/span&gt;&#xd; {for $map in $mappings&#xd;
                    let $paths := $map/index[xs:string(@key)=$ix]/path&#xd; return &lt;td
                    valign="top"&gt;&lt;ul&gt;{for $path in $paths&#xd; return
                    &lt;li&gt;{$path/text()}&lt;/li&gt;&#xd; }&lt;/ul&gt;&lt;/td&gt; &#xd; }&#xd;
                    &lt;/li&gt;&#xd; }&#xd; &lt;/ul&gt; &#xd; &#xd; return if ($format eq 'raw')
                    then&#xd; $overview&#xd; else &#xd; repo-utils:serialise-as($overview, $format,
                    'html', $config, ()) &#xd; };&#xd; &#xd; &#xd; (:~&#xd; generates mappings for
                    individual collections, &#xd; by invoking get-mappings for each collection
                    individually (as x-context)&#xd; &#xd; @returns a summary of generated
                    stuff&#xd; :)&#xd; declare function smc:gen-mappings($config, $x-context as
                    xs:string+, $run-flag as xs:boolean, $format as xs:string) as item()* {&#xd;
                    &#xd; (: let $mappings := doc(repo-utils:config-value($config,
                    'mappings')),:)&#xd; let $context-mapping := fcs:get-mapping('',$x-context,
                    $config),&#xd; (: if not specific mapping found for given context, use whole
                    mappings-file :)&#xd; $mappings := if ($context-mapping/xs:string(@key) =
                    $x-context) then $context-mapping &#xd; else
                    doc(repo-utils:config-value($config, 'mappings')) &#xd; &#xd; &#xd; let
                    $mapsummaries := for $map in $mappings/descendant-or-self::map[@key]&#xd; let
                    $map := smc:get-mappings($config, $map/xs:string(@key), true(), 'raw')&#xd;
                    return &lt;map count_profiles="{count($map/map)}"
                    count_indexes="{count($map//index)}" &gt;{($map/@*,&#xd; for $profile-map in
                    $map/map &#xd; return &lt;map count_indexes="{count($profile-map/index)}"
                    count_paths="{count($profile-map/index/path)}"&gt;{$profile-map/@*}&lt;/map&gt;)}&lt;/map&gt;&#xd;
                    (: return $map:)&#xd; &#xd; return &lt;map
                    empty_maps="{count($mapsummaries[xs:integer(@count_indexes)=0])}"&gt;{$mapsummaries}&lt;/map&gt;&#xd;
                    &#xd; };&#xd; &#xd; (:~ create and store mapping for every profile in given
                    nodeset &#xd; expects the CMD-format&#xd; &#xd; calls crday:get-ay-xml which may
                    be very time-consuming&#xd; &#xd; @param $format [raw, htmlpage, html] - raw:
                    return only the produced table, html* : serialize as html&#xd; @param $run-flag
                    if true - re-run even if in cache&#xd; :)&#xd; declare function
                    smc:get-mappings($config, $x-context as xs:string+, $run-flag as xs:boolean,
                    $format as xs:string) as item()* {&#xd; &#xd; let $scan-profiles :=
                    fcs:scan('cmd.profile', $x-context, 1, 50, 1, 1, "text", '', $config),&#xd;
                    $target_path := repo-utils:config-value($config, 'cache.path')&#xd; &#xd; (: for
                    every profile in the data-set :)&#xd; let $result := for $profile in
                    $scan-profiles//sru:term&#xd; let $profile-name :=
                    xs:string($profile/sru:displayTerm) &#xd; let $map-doc-name :=
                    repo-utils:gen-cache-id("map", ($x-context, $profile-name), '')&#xd; &#xd;
                    return &#xd; if (repo-utils:is-in-cache($map-doc-name, $config) and
                    not($run-flag)) then &#xd; repo-utils:get-from-cache($map-doc-name,
                    $config)&#xd; else&#xd; let $ay-data := crday:get-ay-xml($config, $x-context,
                    $profile-name, $crday:defaultMaxDepth, $run-flag, 'raw') &#xd; let $mappings :=
                    &lt;map profile-id="{$profile/sru:value}" profile-name="{$profile-name}"
                    context="{$x-context}"&gt; &#xd; {smc:match-paths($ay-data, $profile)}&#xd;
                    &lt;/map&gt;&#xd; return repo-utils:store-in-cache($map-doc-name, $mappings,
                    $config)&#xd; &#xd; return if ($format eq 'raw') then&#xd; &lt;map
                    context="{$x-context}" &gt;{$result}&lt;/map&gt;&#xd; else &#xd;
                    repo-utils:serialise-as(&lt;map context="{$x-context}"
                    &gt;{$result}&lt;/map&gt;, $format, 'default', $config, ()) &#xd; };&#xd; &#xd;
                    (:~ expects a summary of data, matches the resulting paths with paths in
                    cmd-terms&#xd; and returns dcr-indexes, that have a path in the input-data&#xd;
                    &#xd; be kind and try to map on profile-name if profile-id not available (or did
                    not match) &#xd; :)&#xd; declare function smc:match-paths($ay-data as item(),
                    $profile as node()) as item()* {&#xd; &#xd; let $data-paths :=
                    $ay-data//Term/replace(replace(xs:string(@path),'//',''),'/','.')&#xd; &#xd; let
                    $profile-id := xs:string($profile/sru:value)&#xd; let $profile-name :=
                    xs:string($profile/sru:displayTerm) &#xd; &#xd; let $match-by-id := if
                    ($profile-id ne '') then $smc:cmd-terms//Termset[@id=$profile-id and
                    @type="CMD_Profile"]/Term[xs:string(@path) = $data-paths ] else ()&#xd; let
                    $match := if (exists($match-by-id)) then $match-by-id&#xd; else
                    $smc:cmd-terms//Termset[xs:string(@name)=$profile-name and
                    @type="CMD_Profile"]/Term[xs:string(@path) = $data-paths ] &#xd; &#xd; let
                    $mapping := for $datcat in distinct-values($match//xs:string(@datcat))&#xd; let
                    $key := smc:shorten-uri($datcat) &#xd; return &lt;index key="{$key}" &gt;&#xd; {
                    for $path in $match[xs:string(@datcat) = $datcat]/xs:string(@path) &#xd; return
                    &lt;path count=""&gt;{$path}&lt;/path&gt;&#xd; }&#xd; &lt;/index&gt;&#xd; return
                    $mapping&#xd; };&#xd; &#xd; (:~ replace url_prefix in the url by the short
                    key&#xd; based on definitions in $smc:termsets&#xd; :)&#xd; declare function
                    smc:shorten-uri($url as xs:string) as xs:string { &#xd; let $termset :=
                    $smc:termsets//Termset[url_prefix][starts-with($url, url_prefix)][$url ne
                    '']&#xd; let $url-suffix := substring-after ($url, $termset/url_prefix) &#xd;
                    return if (exists($termset)) then concat($termset/key, ':', $url-suffix) else
                    $url&#xd; };&#xd; &#xd; (:~ &#xd; :)&#xd; declare function
                    smc:gen-graph($config, $x-context as xs:string+) as item()* {&#xd; &#xd; let
                    $model := map { "config" := $config}&#xd; let $cache-path :=
                    config:param-value($model, 'cache.path')&#xd; let $smc-browser-path :=
                    config:param-value($model, 'smc-browser.path')&#xd; (: beware of mixing in the
                    already result (doc()/Termsets/Termset vs. doc()/Termset :)&#xd; let $termsets
                    := &lt;Termsets&gt;{collection($cache-path)/Termset}&lt;/Termsets&gt;&#xd; &#xd;
                    &#xd; &#xd; (: let $termsets-doc := doc(concat($cache-path,
                    $termsets-file)):)&#xd; let $termsets-doc :=
                    repo-utils:store-in-cache(concat($smc:structure-file,".xml"), $termsets,
                    $config)&#xd; &#xd; let $graph := transform:transform($termsets,
                    $smc:xsl-terms2graph,&lt;parameters&gt;&lt;param name="base-uri"
                    value="/db/apps/cr-xq/modules/smc/data/" /&gt;&lt;/parameters&gt; ),&#xd;
                    $graph-file := concat($smc:structure-file, "-graph"),&#xd; $graph-doc :=
                    repo-utils:store-in-cache (concat($graph-file,".xml"), $graph,$config), &#xd;
                    $graph-json := transform:transform($graph,
                    $smc:xsl-graph2json,&lt;parameters&gt;&lt;param name="base-uri"
                    value="/db/apps/cr-xq/modules/smc/data/" /&gt;&lt;/parameters&gt; ),&#xd;
                    $graph-json-doc := repo-utils:store-in-cache(concat($graph-file,".json"),
                    $graph-json, $config) &#xd; let $graph-copy := if ($smc-browser-path ne '') then
                    repo-utils:store($smc-browser-path,concat($graph-file,".json"), $graph-json,
                    true(),$config) else ()&#xd; return
                    &lt;gen-graph&gt;{string-join((document-uri($termsets-doc),
                    document-uri($graph-doc), concat($graph-file,".json"), $smc-browser-path),',
                    ')}&lt;/gen-graph&gt; &#xd; &#xd; (:&#xd; let $graph-termsets := for $t in
                    $graph-doc//Termset/Term&#xd; return &lt;term&gt;{$t/@*}&lt;/term&gt;&#xd;
                    return ($cache-path, count($termsets//Termset),count($termsets-doc//Termset),
                    count(distinct-values($termsets-doc//Termset/Term/@name)),
                    count($graph-doc//node[@type='Profile']),&#xd;
                    &lt;profiles&gt;{distinct-values($termsets-doc//Termset/Term/@name)}&lt;/profiles&gt;,&#xd;
                    &lt;graph-termsets&gt;{$graph-termsets}&lt;/graph-termsets&gt;, &#xd;
                    &lt;nodes&gt;{distinct-values($graph-doc//node[@type='Profile']/xs:string(@name))}&lt;/nodes&gt;)&#xd;
                    :)&#xd; &#xd; };</f>
            </d>
            <d n="test">
                <f n="test.xqm">xquery version "3.0";&#xd; &#xd; module namespace
                    test="http://sade/test";&#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "config.xqm";&#xd; &#xd;
                    declare variable $test:id := "test";&#xd; &#xd; declare function test:main
                    ($node as node(), $model as map(*)) {&#xd; &#xd; config:app-info($node,
                    $model)&#xd; (:
                    &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;{&#xd;
                    for $key in config:param-keys($model)&#xd; return
                    &lt;tr&gt;&lt;td&gt;{$key}&lt;/td&gt;&lt;td&gt;{config:param-value($node,
                    $model,$test:id,'main',$key)}&lt;/td&gt;&lt;/tr&gt;&#xd; }&#xd;
                    &lt;/table&gt;:)&#xd; &#xd; };&#xd; &#xd; &#xd; &#xd; declare function
                    test:params ($node as node(), $model as map(*), $param1 as xs:string, $param2 as
                    xs:string) {&#xd; &#xd; &#xd;
                    &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&#xd;
                    &lt;tr&gt;&lt;td&gt;param1&lt;/td&gt;&lt;td&gt;{$param1}&lt;/td&gt;&lt;/tr&gt;&#xd;
                    &lt;tr&gt;&lt;td&gt;param2&lt;/td&gt;&lt;td&gt;{$param2}&lt;/td&gt;&lt;/tr&gt;&#xd;
                    &lt;/table&gt;&#xd; &#xd; };&#xd; </f>
            </d>
            <d n="text-viewer">
                <d n="resources">
                    <d n="tei">
                        <d n="stylesheet">
                            <d n="common2"/>
                            <d n="docx">
                                <d n="from">
                                    <d n="dynamic">
                                        <d n="tests">
                                            <d n="xspec"/>
                                        </d>
                                    </d>
                                    <d n="graphics"/>
                                    <d n="lists"/>
                                    <d n="marginals"/>
                                    <d n="maths"/>
                                    <d n="paragraphs"/>
                                    <d n="pass0"/>
                                    <d n="pass2"/>
                                    <d n="tables"/>
                                    <d n="templates"/>
                                    <d n="textruns"/>
                                    <d n="utils"/>
                                    <d n="wordsections"/>
                                </d>
                                <d n="misc"/>
                                <d n="to">
                                    <d n="docxfiles"/>
                                    <d n="drama"/>
                                    <d n="dynamic"/>
                                    <d n="graphics"/>
                                    <d n="lists"/>
                                    <d n="maths"/>
                                    <d n="odds"/>
                                    <d n="templates"/>
                                    <d n="wordsections"/>
                                </d>
                                <d n="utils">
                                    <d n="graphics"/>
                                    <d n="identity"/>
                                    <d n="maths"/>
                                    <d n="verbatim"/>
                                </d>
                            </d>
                            <d n="dtd"/>
                            <d n="epub"/>
                            <d n="fo2"/>
                            <d n="html"/>
                            <d n="latex2"/>
                            <d n="nlm"/>
                            <d n="odds2"/>
                            <d n="odt"/>
                            <d n="profiles">
                                <d n="agora">
                                    <d n="docx"/>
                                    <d n="html"/>
                                    <d n="html5"/>
                                    <d n="latex"/>
                                </d>
                                <d n="bodley">
                                    <d n="epub"/>
                                </d>
                                <d n="default">
                                    <d n="csv"/>
                                    <d n="docbook"/>
                                    <d n="docx"/>
                                    <d n="dtd"/>
                                    <d n="epub"/>
                                    <d n="epub3"/>
                                    <d n="fo"/>
                                    <d n="html"/>
                                    <d n="html5"/>
                                    <d n="latex"/>
                                    <d n="lite"/>
                                    <d n="oddhtml"/>
                                    <d n="odt"/>
                                    <d n="p4"/>
                                    <d n="rdf"/>
                                    <d n="relaxng"/>
                                </d>
                                <d n="ecco">
                                    <d n="epub"/>
                                </d>
                                <d n="enrich">
                                    <d n="docx"/>
                                    <d n="fo"/>
                                    <d n="html"/>
                                    <d n="latex"/>
                                </d>
                                <d n="godwindiaries">
                                    <d n="epub"/>
                                </d>
                                <d n="iso">
                                    <d n="docx">
                                        <d n="model"/>
                                    </d>
                                    <d n="epub"/>
                                    <d n="fo"/>
                                    <d n="html"/>
                                    <d n="latex"/>
                                    <d n="schema"/>
                                    <d n="tbx"/>
                                </d>
                                <d n="minimal">
                                    <d n="html"/>
                                </d>
                                <d n="oepack">
                                    <d n="epub"/>
                                    <d n="html"/>
                                </d>
                                <d n="ota">
                                    <d n="epub"/>
                                    <d n="html"/>
                                </d>
                                <d n="otapages">
                                    <d n="epub"/>
                                </d>
                                <d n="oucs">
                                    <d n="docx"/>
                                    <d n="epub"/>
                                    <d n="p4"/>
                                </d>
                                <d n="oucscourses">
                                    <d n="docx"/>
                                </d>
                                <d n="podcasts">
                                    <d n="docx"/>
                                    <d n="epub"/>
                                </d>
                                <d n="tei">
                                    <d n="epub"/>
                                    <d n="html"/>
                                </d>
                            </d>
                            <d n="rdf"/>
                            <d n="relaxng"/>
                            <d n="slides"/>
                            <d n="tite"/>
                            <d n="tools">
                                <d n="docx-templates-twiddling"/>
                                <d n="ImageInfo">
                                    <d n="src"/>
                                </d>
                            </d>
                            <d n="xhtml2"/>
                        </d>
                    </d>
                </d>
                <f n="text-viewer.xqm">module namespace text-viewer = "http://sade/text-viewer"
                    ;&#xd; declare namespace templates="http://exist-db.org/xquery/templates";&#xd;
                    declare namespace sade = "http://sade" ;&#xd; declare namespace tei =
                    "http://www.tei-c.org/ns/1.0" ;&#xd; &#xd; declare
                    %templates:default("position", 1) &#xd; function text-viewer:showText($node as
                    node(), $model as map(*), $position as xs:integer) as element() { &#xd; &#xd;
                    let $divID := $node/xs:string(@id)&#xd; let $config :=
                    local:readConfig()("config")//*[@name="text-viewer"][@container=$divID]&#xd;
                    &#xd; (: Projektkonfiguration auslesen :)&#xd; let $collection_path :=
                    $config/param[@name="collection_path"]/xs:string(@value)&#xd; let $xpath :=
                    $config/param[@name="xpath"]/xs:string(@value)&#xd; let $xslt_path :=
                    $config/param[@name="xslt_path"]/xs:string(@value)&#xd; &#xd; (: Geamtanzahl der
                    referenzierten Elemente feststellen :)&#xd; let $totalNr :=
                    util:eval(concat("count(collection('",$collection_path,"')",$xpath,")"))&#xd;
                    &#xd; (: XML-Fragment aus DB holen und transformieren :)&#xd; let $xsl := if
                    ($xslt_path = () or $xslt_path = "" or $xslt_path = "tei") then
                    doc("resources/tei/stylesheet/xhtml2/tei.xsl")&#xd; else doc($xslt_path)&#xd;
                    let $fragment :=
                    util:eval(concat("collection('",$collection_path,"')",$xpath,"[",$position,"]"))
                    &#xd; let $html := transform:transform($fragment, $xsl, ()) &#xd; &#xd; (:
                    Navigation bauen :)&#xd; let $navbar := text-viewer:getNavBar($position, "",
                    $totalNr)&#xd; &#xd; return &lt;div&gt;Brieftext: {$navbar,
                    $html}&lt;/div&gt;&#xd; };&#xd; &#xd; &#xd; declare function
                    text-viewer:getNavBar($position as xs:string, $script_url as xs:string, $last as
                    xs:string){&#xd; let $next := if ($position = "last()" or $position = $last)
                    then $position else xs:integer($position)+1&#xd; let $prev := if ($position =
                    "1") then $position else if ($position = "last()") then "last()-1" else
                    xs:integer($position)-1&#xd; &#xd; return&#xd; &lt;div
                    class="btn-toolbar"&gt;&#xd; &lt;div class="btn-group"&gt; &#xd; &lt;a
                    class="btn" href="{$script_url}?position=1"&gt;&lt;i
                    class="icon-fast-backward"&gt;|-&lt;/i&gt;&lt;/a&gt;&#xd; &lt;a class="btn"
                    href="{$script_url}?position={$prev}"&gt;&lt;i
                    class="icon-chevron-left"&gt;-&lt;/i&gt;&lt;/a&gt;&#xd; &lt;a class="btn"
                    href="{$script_url}?position={$next}"&gt;&lt;i
                    class="icon-chevron-right"&gt;+&lt;/i&gt;&lt;/a&gt;&#xd; &lt;a class="btn"
                    href="{$script_url}?position={$last}"&gt;&lt;i
                    class="icon-fast-forward"&gt;+|&lt;/i&gt;&lt;/a&gt;&#xd; &lt;/div&gt;&#xd;
                    &lt;/div&gt;&#xd; };&#xd; &#xd; &#xd; declare function local:readConfig() as
                    map(*) {&#xd; &#xd; let $config :=
                    doc("/db/apps/sade/projects/neu1/config.xml")&#xd; &#xd; return map { "config"
                    := $config }&#xd; &#xd; };</f>
            </d>
            <d n="viewer">
                <f n="get.xql">xquery version "3.0";&#xd; &#xd; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";&#xd;
                    import module namespace viewer = "http://sade/viewer" at "viewer.xqm" ;&#xd;
                    &#xd; let $project := request:get-parameter("project","")&#xd; &#xd; let $config
                    := map { "config" := config:config($project)}&#xd; (:~ internal resource
                    identfier :)&#xd; let $id := request:get-parameter("resource-id","")&#xd; let
                    $format := request:get-parameter("format","xml")&#xd; &#xd; return
                    viewer:display($config, $id, $format)&#xd; &#xd; &#xd; </f>
                <f n="viewer.xqm">module namespace viewer = "http://sade/viewer" ;&#xd; declare
                    namespace templates="http://exist-db.org/xquery/templates";&#xd; import module
                    namespace config="http://exist-db.org/xquery/apps/config" at
                    "../../core/config.xqm";&#xd; import module namespace repo-utils =
                    "http://aac.ac.at/content_repository/utils" at "../../core/repo-utils.xqm";&#xd;
                    import module namespace resource = "http://cr-xq/resource" at
                    "../resource/resource.xqm";&#xd; (:declare namespace tei =
                    "http://www.tei-c.org/ns/1.0" ;:)&#xd; &#xd; (:~ default viewer, fetching data,
                    transforming with xslt &#xd; based on text-viewer &#xd; tries to get the
                    resources matching the @xml:id, then the filename (in the data- and
                    metadata-path)&#xd; :)&#xd; &#xd; (: moved to resource-module &#xd; declare
                    function viewer:get ($config-map, $id as xs:string) {&#xd; &#xd; let $data-dir
                    := config:param-value($config-map, 'data-dir'),&#xd; $metadata-dir :=
                    config:param-value($config-map, 'metadata-path'),&#xd; $resource-id :=
                    collection($data-dir)//*[@xml:id eq $id],&#xd; $resource := if
                    (exists($resource-id)) then $resource-id&#xd; else if
                    (doc-available(concat($data-dir, '/', $id))) then&#xd; doc(concat($data-dir,
                    '/', $id))&#xd; else if (doc-available(concat($metadata-dir, '/', $id)))
                    then&#xd; doc(concat($metadata-dir, '/', $id))&#xd; else ()&#xd; &#xd; &#xd;
                    return if (exists($resource)) then $resource &#xd; else
                    &lt;diagnostics&gt;&lt;message&gt;Resource unavailable, id: { ($data-dir, $id) }
                    &lt;/message&gt;&lt;/diagnostics&gt; &#xd; &#xd; };&#xd; :)&#xd; &#xd; declare
                    function viewer:display($config-map, $id as xs:string, $format as xs:string) as
                    item()* { &#xd; &#xd; let $data := resource:get($config-map, $id)&#xd; &#xd; let
                    $params := &lt;parameters&gt;&#xd; &lt;param name="format"
                    value="{$format}"/&gt;&#xd; &lt;param name="base_url"
                    value="{config:param-value($config-map,'base-url')}"/&gt;&#xd; &#xd;
                    &lt;/parameters&gt;&#xd; (: modules/shared/scripts:)&#xd; (:&lt;param
                    name="base_url" value="{repo-utils:base-url($config)}"/&gt;:)&#xd; &#xd; return
                    if ($format='xml') then&#xd; $data&#xd; else &#xd; &lt;div
                    class="templates:init"&gt;&#xd; &lt;div
                    class="templates:surround?with=page.html&amp;amp;at=content-container"&gt;&#xd;
                    { repo-utils:serialise-as($data, $format, 'xml', $config-map("config"), $params)
                    }&#xd; &lt;/div&gt;&#xd; &lt;/div&gt;&#xd; &#xd; &#xd; (: let $divID :=
                    $node/xs:string(@id)&#xd; let $config :=
                    local:readConfig()("config")//*[@name="text-viewer"][@container=$divID]&#xd;
                    &#xd; (\: Projektkonfiguration auslesen :\)&#xd; let $collection_path :=
                    $config/param[@name="collection_path"]/xs:string(@value)&#xd; let $xpath :=
                    $config/param[@name="xpath"]/xs:string(@value)&#xd; let $xslt_path :=
                    $config/param[@name="xslt_path"]/xs:string(@value)&#xd; &#xd; (\: Geamtanzahl
                    der referenzierten Elemente feststellen :\)&#xd; let $totalNr :=
                    util:eval(concat("count(collection('",$collection_path,"')",$xpath,")"))&#xd;
                    &#xd; (\: XML-Fragment aus DB holen und transformieren :\)&#xd; let $xsl := if
                    ($xslt_path = () or $xslt_path = "" or $xslt_path = "tei") then
                    doc("resources/tei/stylesheet/xhtml2/tei.xsl")&#xd; else doc($xslt_path)&#xd;
                    let $fragment :=
                    util:eval(concat("collection('",$collection_path,"')",$xpath,"[",$position,"]"))
                    &#xd; let $html := transform:transform($fragment, $xsl, ()) &#xd; &#xd; (\:
                    Navigation bauen :\)&#xd; let $navbar := text-viewer:getNavBar($position, "",
                    $totalNr)&#xd; &#xd; return &lt;div&gt;Brieftext: {$navbar,
                    $html}&lt;/div&gt;&#xd; :)&#xd; &#xd; };&#xd; &#xd; </f>
            </d>
            <d n="xfedora">
                <f n="xfedora.xqm">xquery version "3.0"; module namespace xfedora =
                    "http://aac.ac.at/content_repository/xfedora"; import module namespace resource
                    = "http://aac.ac.at/content_repository/resource" at "../../core/resource.xqm";
                    import module namespace project = "http://aac.ac.at/content_repository/project"
                    at "../../core/project.xqm"; import module namespace
                    config="http://exist-db.org/xquery/apps/config" at "../../core/config.xqm";
                    import module namespace cmd="http://www.clarin.eu/cmd/" at "../cmd/cmdi.xqm";
                    declare namespace foxml = "info:fedora/fedora-system:def/foxml#"; declare
                    namespace dc = "http://purl.org/dc/elements/1.1/"; declare function
                    xfedora:project2foxml($project-pid as xs:string) as element(foxml:digitalObject)
                    { xfedora:project2foxml(("CMDI"),$project-pid) }; declare function
                    xfedora:project2foxml($datastreams as xs:string*, $project-pid as xs:string) as
                    element(foxml:digitalObject) { let $fedora-pid :=
                    replace(config:param-value(config:module-config(),"fedora-pid-namespace-prefix"),':$','')||":"||$project-pid,
                    $fedora-get-url :=
                    replace(config:param-value(config:module-config(),"fedora-get-url"),'/$','') let
                    $label := project:label($project-pid), $owner :=
                    project:adminsaccountname($project-pid), $MdSelfLink :=
                    project:get-handle("CMDI",$project-pid), $dc := project:dmd2dc($project-pid),
                    $title := $dc//dc:title, $dmd := project:dmd($project-pid), $dmd-created :=
                    xmldb:created(util:collection-name($dmd),util:document-name($dmd)) return (:
                    &lt;foxml:digitalObject PID="{$fedora-pid}" VERSION="1.1"
                    xmlns:foxml="info:fedora/fedora-system:def/foxml#"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="info:fedora/fedora-system:def/foxml#
                    http://www.fedora.info/definitions/1/0/foxml1-1.xsd"&gt;:)
                    &lt;foxml:digitalObject PID="{$fedora-pid}" VERSION="1.1"
                    xmlns:foxml="info:fedora/fedora-system:def/foxml#"&gt;
                    &lt;foxml:objectProperties&gt; &lt;foxml:property
                    NAME="info:fedora/fedora-system:def/model#state" VALUE="Active"/&gt;
                    &lt;foxml:property NAME="info:fedora/fedora-system:def/model#label"
                    VALUE="{$label}"/&gt; &lt;foxml:property
                    NAME="info:fedora/fedora-system:def/model#ownerId" VALUE="{$owner}"/&gt;
                    &lt;foxml:property NAME="info:fedora/fedora-system:def/model#createdDate"
                    VALUE="{fn:current-dateTime()}"/&gt; &lt;foxml:property
                    NAME="info:fedora/fedora-system:def/view#lastModifiedDate"
                    VALUE="{fn:current-dateTime()}"/&gt; &lt;/foxml:objectProperties&gt;
                    &lt;foxml:datastream CONTROL_GROUP="X" ID="AUDIT" STATE="A"
                    VERSIONABLE="false"&gt; &lt;foxml:datastreamVersion
                    CREATED="{fn:current-dateTime()}"
                    FORMAT_URI="info:fedora/fedora-system:format/xml.fedora.audit" ID="AUDIT.0"
                    LABEL="Audit Trail for this object" MIMETYPE="text/xml"&gt;
                    &lt;foxml:xmlContent&gt; &lt;audit:auditTrail
                    xmlns:audit="info:fedora/fedora-system:def/audit#"/&gt;
                    &lt;/foxml:xmlContent&gt; &lt;/foxml:datastreamVersion&gt;
                    &lt;/foxml:datastream&gt; &lt;foxml:datastream CONTROL_GROUP="X" ID="DC"
                    STATE="A" VERSIONABLE="true"&gt; &lt;foxml:datastreamVersion
                    CREATED="{fn:current-dateTime()}"
                    FORMAT_URI="http://www.openarchives.org/OAI/2.0/oai_dc/" ID="DC1.0"
                    LABEL="Dublin Core Record for this object" MIMETYPE="text/xml"&gt;
                    &lt;foxml:xmlContent&gt;{$dc}&lt;/foxml:xmlContent&gt;
                    &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt; {if ($datastreams =
                    "CMDI") then (&lt;foxml:datastream CONTROL_GROUP="X" ID="CMDI" STATE="A"
                    VERSIONABLE="true"&gt; &lt;foxml:datastreamVersion ALT_IDS="{$MdSelfLink}"
                    CREATED="{$dmd-created}" ID="CMDI.0" LABEL="CMD record for {$label}"
                    MIMETYPE="text/xml"&gt; &lt;foxml:xmlContent&gt;{$dmd}&lt;/foxml:xmlContent&gt;
                    &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt;, if($datastreams =
                    "CMDI-PROFILED") then &lt;foxml:datastream CONTROL_GROUP="R"
                    ID="CMDI-COLLECTION" STATE="A" VERSIONABLE="true"&gt;
                    &lt;foxml:datastreamVersion CREATED="{current-dateTime()}"
                    ID="CMDI-COLLECTION.0" LABEL="CMD record for {$label}" MIMETYPE="text/xml"&gt;
                    &lt;foxml:contentLocation REF="{$fedora-get-url}/{$fedora-pid}/CMDI"
                    TYPE="URL"/&gt; &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt; else
                    ()) else ()} &lt;foxml:datastream CONTROL_GROUP="X" ID="RELS-EXT" STATE="A"
                    VERSIONABLE="true"&gt; &lt;foxml:datastreamVersion
                    CREATED="2013-09-20T10:44:46.262Z"
                    FORMAT_URI="info:fedora/fedora-system:FedoraRELSExt-1.0" ID="RELS-EXT.0"
                    LABEL="RDF Statements about this object" MIMETYPE="application/rdf+xml"&gt;
                    &lt;foxml:xmlContent&gt; &lt;rdf:RDF
                    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description
                    rdf:about="info:fedora/{$fedora-pid}"&gt; &lt;itemID
                    rdf:resource="info:fedora/{$fedora-pid}"
                    xmlns="http://www.openarchives.org/OAI/2.0/"/&gt; &lt;/rdf:Description&gt;
                    &lt;/rdf:RDF&gt; &lt;/foxml:xmlContent&gt; &lt;/foxml:datastreamVersion&gt;
                    &lt;/foxml:datastream&gt; &lt;/foxml:digitalObject&gt; }; declare function
                    xfedora:resource2foxml($resource-pid as xs:string, $project-pid as xs:string) as
                    element(foxml:digitalObject) {
                    xfedora:resource2foxml(("CMDI","DATA"),$resource-pid,$project-pid) }; declare
                    function xfedora:resource2foxml($datastreams as xs:string*, $resource-pid as
                    xs:string, $project-pid as xs:string) as element(foxml:digitalObject) { let
                    $fedora-pid :=
                    replace(config:param-value(config:module-config(),"fedora-pid-namespace-prefix"),':$','')||":"||$resource-pid,
                    $fedora-collection-pid :=
                    replace(config:param-value(config:module-config(),"fedora-pid-namespace-prefix"),':$','')||":"||$project-pid
                    let $label := resource:label($resource-pid,$project-pid), $owner :=
                    project:adminsaccountname($project-pid), $MdSelfLink :=
                    resource:get-handle("CMDI",$resource-pid,$project-pid), $dc :=
                    resource:dmd2dc($resource-pid, $project-pid), $title := $dc//dc:title, $dmd :=
                    resource:dmd($resource-pid, $project-pid), $cmd-profilename :=
                    cmd:profile-id-to-name($dmd//cmd:MdProfile), $parentCollection-handle :=
                    resource:get-handle("project",$resource-pid,$project-pid)[. =
                    project:get-handle("CMDI",$project-pid)], $dmd-created :=
                    xmldb:created(util:collection-name($dmd),util:document-name($dmd)), $master :=
                    resource:master($resource-pid,$project-pid) return (:&lt;foxml:digitalObject
                    PID="{$fedora-pid}" VERSION="1.1"
                    xmlns:foxml="info:fedora/fedora-system:def/foxml#"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="info:fedora/fedora-system:def/foxml#
                    http://www.fedora.info/definitions/1/0/foxml1-1.xsd"&gt;:)
                    &lt;foxml:digitalObject PID="{$fedora-pid}" VERSION="1.1"
                    xmlns:foxml="info:fedora/fedora-system:def/foxml#"&gt;
                    &lt;foxml:objectProperties&gt; &lt;foxml:property
                    NAME="info:fedora/fedora-system:def/model#state" VALUE="Active"/&gt;
                    &lt;foxml:property NAME="info:fedora/fedora-system:def/model#label"
                    VALUE="{$label}"/&gt; &lt;foxml:property
                    NAME="info:fedora/fedora-system:def/model#ownerId" VALUE="{$owner}"/&gt;
                    &lt;foxml:property NAME="info:fedora/fedora-system:def/model#createdDate"
                    VALUE="{fn:current-dateTime()}"/&gt; &lt;foxml:property
                    NAME="info:fedora/fedora-system:def/view#lastModifiedDate"
                    VALUE="{fn:current-dateTime()}"/&gt; &lt;/foxml:objectProperties&gt;
                    &lt;foxml:datastream CONTROL_GROUP="X" ID="AUDIT" STATE="A"
                    VERSIONABLE="false"&gt; &lt;foxml:datastreamVersion
                    CREATED="{fn:current-dateTime()}"
                    FORMAT_URI="info:fedora/fedora-system:format/xml.fedora.audit" ID="AUDIT.0"
                    LABEL="Audit Trail for this object" MIMETYPE="text/xml"&gt;
                    &lt;foxml:xmlContent&gt; &lt;audit:auditTrail
                    xmlns:audit="info:fedora/fedora-system:def/audit#"/&gt;
                    &lt;/foxml:xmlContent&gt; &lt;/foxml:datastreamVersion&gt;
                    &lt;/foxml:datastream&gt; &lt;foxml:datastream CONTROL_GROUP="X" ID="DC"
                    STATE="A" VERSIONABLE="true"&gt; &lt;foxml:datastreamVersion
                    CREATED="{fn:current-dateTime()}"
                    FORMAT_URI="http://www.openarchives.org/OAI/2.0/oai_dc/" ID="DC1.0"
                    LABEL="Dublin Core Record for this object" MIMETYPE="text/xml"&gt;
                    &lt;foxml:xmlContent&gt;{$dc}&lt;/foxml:xmlContent&gt;
                    &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt; &lt;foxml:datastream
                    CONTROL_GROUP="X" ID="RELS-EXT" STATE="A" VERSIONABLE="true"&gt;
                    &lt;foxml:datastreamVersion CREATED="{fn:current-dateTime()}"
                    FORMAT_URI="info:fedora/fedora-system:FedoraRELSExt-1.0" ID="RELS-EXT.0"
                    LABEL="RDF Statements about this object" MIMETYPE="application/rdf+xml"&gt;
                    &lt;foxml:xmlContent&gt; &lt;rdf:RDF
                    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description
                    rdf:about="info:fedora/{$fedora-pid}"&gt; &lt;itemID
                    rdf:resource="{$fedora-pid}" xmlns="http://www.openarchives.org/OAI/2.0/"/&gt;
                    {if (exists($parentCollection-handle)) then &lt;isMemberOf
                    rdf:resource="{$fedora-collection-pid}"
                    xmlns="info:fedora/fedora-system:def/relations-external"/&gt; else ()}
                    &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt; &lt;/foxml:xmlContent&gt;
                    &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt; {if ($datastreams =
                    "CMDI") then (&lt;foxml:datastream CONTROL_GROUP="X" ID="CMDI" STATE="A"
                    VERSIONABLE="true"&gt; &lt;foxml:datastreamVersion ALT_IDS="{$MdSelfLink}"
                    CREATED="{$dmd-created}" ID="CMDI.0" LABEL="CMD record for {$label}"
                    MIMETYPE="text/xml"&gt; &lt;foxml:xmlContent&gt;{$dmd}&lt;/foxml:xmlContent&gt;
                    &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt;, if ($cmd-profilename
                    != "" and $datastreams = "CMDI-PROFILED") then &lt;foxml:datastream
                    CONTROL_GROUP="R" ID="{$cmd-profilename}" STATE="A" VERSIONABLE="true"&gt;
                    &lt;foxml:datastreamVersion CREATED="{current-dateTime()}"
                    ID="{$cmd-profilename}.0" LABEL="CMD record for {$label}"
                    MIMETYPE="text/xml"&gt; &lt;foxml:contentLocation
                    REF="{$fedora-get-url}/{$fedora-pid}/CMDI" TYPE="URL"/&gt;
                    &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt; else ()) else ()} {if
                    ($datastreams = "DATA") then &lt;foxml:datastream CONTROL_GROUP="X" ID="DATA"
                    STATE="A" VERSIONABLE="true"&gt; &lt;foxml:datastreamVersion
                    CREATED="{fn:current-dateTime()}"
                    ALT_IDS="{resource:get-handle("data",$resource-pid,$project-pid)}" ID="DATA.0"
                    LABEL="Original Data of this resource" MIMETYPE="text/xml"&gt;
                    &lt;foxml:xmlContent&gt;{$master}&lt;/foxml:xmlContent&gt;
                    &lt;/foxml:datastreamVersion&gt; &lt;/foxml:datastream&gt; else ()}
                    &lt;/foxml:digitalObject&gt; }; </f>
            </d>
        </d>
        <d n="project.template">
            <d n="data"/>
            <d n="static">
                <d n="content"/>
            </d>
        </d>
        <d n="templates">
            <d n="bootstrap">
                <d n="css"/>
                <d n="img"/>
                <d n="js"/>
            </d>
            <d n="default">
                <d n="css">
                    <d n="images"/>
                </d>
                <d n="images">
                    <d n="icons"/>
                </d>
                <d n="scripts">
                    <d n="jquery"/>
                </d>
            </d>
            <d n="minimal">
                <d n="css">
                    <d n="clarindotblue"/>
                    <d n="dotred"/>
                    <d n="imgs"/>
                </d>
                <d n="js">
                    <d n="mode"/>
                </d>
            </d>
        </d>
        <f n="controller.xql">xquery version "3.0";&#xd; (:~&#xd; : Main rewrite controller for the
            cr-xq content repository.&#xd; : &#xd; : @author Daniel Schopper &#xd; : @author
            vronk&#xd; ~:)&#xd; &#xd; import module namespace
            config="http://exist-db.org/xquery/apps/config" at "core/config.xqm";&#xd; import module
            namespace login="http://exist-db.org/xquery/login" at
            "resource:org/exist/xquery/modules/persistentlogin/login.xql";&#xd; import module
            namespace projectAdmin="http://aac.ac.at/content_repository/projectAdmin" at
            "modules/projectAdmin/projectAdmin.xqm";&#xd; &#xd; declare variable $exist:path
            external;&#xd; declare variable $exist:resource external;&#xd; declare variable
            $exist:controller external;&#xd; declare variable $exist:prefix external;&#xd; declare
            variable $exist:root external;&#xd; &#xd; &#xd; &#xd; (:~ if debug=controller - divert
            to debugging controller&#xd; if debug set at all (possible config:app-info() is
            activated in the UI (depends on the template)&#xd; :)&#xd; let $debug :=
            request:get-parameter("debug", '')&#xd; (:~&#xd; : The variable
            &lt;code&gt;$params&lt;/code&gt; holds contextual request parameters. &#xd; : Tokenizing
            the $exist:path by slashes we expect the following structure: &#xd; : request =
            "http://host/exist/apps/cr-xq/abacus/fcs?query=string"&#xd; : $exist:path =
            "/cr-xq/abacus/fcs?query=string"&#xd; : $params[1] = ""&#xd; : $params[2] = ID of
            cr-project&#xd; : $params[3] = optionally: name of a core module to operate in the
            current project's scope, &#xd; for example the 'resource' module, which summarizes the
            structure of a project's resources. &#xd; ~:)&#xd; let $params := tokenize($exist:path,
            '/')&#xd; &#xd; (:~&#xd; : The variable &lt;code&gt;$cr-instance&lt;/code&gt; holds the
            base path of the current content repository instance.&#xd; : &#xd; : This allows to
            differentiat between logins to concurrent cr-instances by setting unique login
            domains.&#xd; : &#xd; : @see $domain &#xd; ~:)&#xd; let $cr-instance := $params[1] &#xd;
            &#xd; (:~&#xd; : The variable &lt;code&gt;$project&lt;/code&gt; holds the ID of the
            current project. &#xd; : Its value is determined by:&#xd; : &lt;ul&gt;&#xd; :
            &lt;li&gt;the request path&lt;/li&gt;&#xd; : &lt;li&gt;a explicit request parameter
            named 'project'&lt;/li&gt;&#xd; : &lt;/ul&gt;&#xd; : If none of these two is set or the
            requested project does not exist, it falls back on the 'default' project.&#xd; ~:)&#xd;
            let $project := &#xd; if (config:project-exists($params[2])) &#xd; then $params[2]&#xd;
            else &#xd; if
            (config:project-exists(request:get-parameter('project',$config:DEFAULT_PROJECT_ID)))
            &#xd; then request:get-parameter('project',$config:DEFAULT_PROJECT_ID)&#xd; else
            $config:DEFAULT_PROJECT_ID&#xd; &#xd; (:~ if x-context parameter not set, set project-id
            as x-context :)&#xd; let $x-context := request:get-parameter("x-context", $project)&#xd;
            &#xd; (:~&#xd; : The variable &lt;code&gt;$project-config&lt;/code&gt; holds the current
            project's configuration, &#xd; : i.e. it's &lt;code&gt;project.xml&lt;/code&gt; setup.
            &#xd; ~:)&#xd; let $project-config := config:project-config($project)&#xd; &#xd;
            (:~&#xd; : The variable &lt;code&gt;$project-config-map&lt;/code&gt; holds a map
            containing the &#xd; : current project's &lt;code&gt;project.xml&lt;/code&gt; setup at
            under one single &lt;code&gt;config&lt;/code&gt; key.&#xd; : This map is passed into the
            templating framework and is queried by most subsequent &#xd; : functions. &#xd; ~:)&#xd;
            let $project-config-map := map { "config" := $project-config}&#xd; &#xd; (:~&#xd; : The
            variables &lt;code&gt;$full-config&lt;/code&gt; and
            &lt;code&gt;$full-config-map&lt;/code&gt; hold: &#xd; : &lt;ol&gt;&#xd; : &lt;li&gt;the
            current project's catalog&lt;/li&gt;&#xd; : &lt;li&gt;the configuration files
            (&lt;code&gt;conf.xml&lt;/code&gt;) of all available cr-xq modules located in
            $app-root/modules&lt;/li&gt;&#xd; : &lt;/ol&gt;&#xd; ~:)&#xd; let $full-config :=
            config:config($project), &#xd; $full-config-map := map { "config" := $full-config}&#xd;
            &#xd; &#xd; (:~ &#xd; : The variable &lt;code&gt;$module&lt;/code&gt; contains the name
            of a cr-xq module which is &#xd; : requested to work in the current project's scope.
            &#xd; : &#xd; : Will be an empty string if the name does not refer to an available
            module. &#xd; ~:)&#xd; let $module := &#xd; if ($params[3] = config:list-modules())
            &#xd; then $params[3] &#xd; else if ($project = $config:DEFAULT_PROJECT_ID) then
            $params[2]&#xd; else ''&#xd; &#xd; (:~&#xd; : The variable
            &lt;code&gt;$module-protected&lt;/code&gt; holds a boolean value determining &#xd; :
            whether the requested cr-xq module may only be used by a closed list of &#xd; : users
            (&lt;code&gt;true()&lt;/code&gt;) or by any user
            (&lt;code&gt;false()&lt;/code&gt;).&#xd; :&#xd; : Defaults to
            &lt;code&gt;false()&lt;/code&gt; when the parameter 'visibility' in the modules's &#xd;
            : configuration file (&lt;code&gt;config.xml&lt;/code&gt;) is not set or has a value
            other than 'protected'. &#xd; ~:)&#xd; let $module-protected :=
            config:param-value((),$full-config-map,$module,'','visibility',true())='protected'&#xd;
            &#xd; (:~&#xd; : The varible &lt;code&gt;$module-users&lt;/code&gt; holds a sequence of
            user names which &#xd; : have rights to use the requested cr-xq module. This is set as
            comma separated values&#xd; : in the module's &lt;code&gt;conf.xml&lt;/code&gt;. &#xd;
            ~:)&#xd; let $module-users :=
            tokenize(config:param-value((),$full-config-map,$module,'','users',true()),'\s*,\s*')&#xd;
            &#xd; &#xd; &#xd; (:~&#xd; : The variable &lt;code&gt;$template-id&lt;/code&gt; holds
            the name of the set of HTML templates &#xd; : the current project is using. This is set
            in the project's configuration. &#xd; ~:)&#xd; let $template-id :=
            config:param-value($project-config-map,'template')&#xd; &#xd; &#xd; (:~&#xd; : The
            variable &lt;code&gt;$file-type&lt;/code&gt; holds the requested resource's filename
            suffix. &#xd; ~:)&#xd; let $file-type := tokenize($exist:resource,'\.')[last()]&#xd;
            &#xd; (:~&#xd; : The variable &lt;code&gt;$web-resources&lt;/code&gt; contains filename
            suffixes of thos file types whose&#xd; : actual location in the database should be
            autogmagically resolved by config:resolve-template-to-uri().&#xd; : This is used to
            serve files which reside in 'templates'. &#xd; ~:)&#xd; let $web-resources := ('js',
            'css', 'png', 'jpg', 'gif', 'pdf', 'ttf', 'woff', 'eot')&#xd; &#xd; (: remove project
            from the path to the resource needed for web-resources (css, js, ...) :)&#xd; let
            $rel-path := &#xd; if (contains($exist:path,$project)) &#xd; then
            substring-after($exist:path, $project) &#xd; else $exist:path&#xd; &#xd; &#xd; (:~&#xd;
            : The variable &lt;code&gt;$protected&lt;/code&gt; holds a boolean value determining
            &#xd; : whether the current project is to be accessed only by a closed list of
            users&#xd; : (&lt;code&gt;true()&lt;/code&gt;) or by all users
            (&lt;code&gt;false()&lt;/code&gt;).&#xd; :&#xd; : Defaults to
            &lt;code&gt;false()&lt;/code&gt; when the parameter 'visibility' in the projects's &#xd;
            : configuration file (&lt;code&gt;project.xml&lt;/code&gt;) is not set or has a value
            other than 'protected'.&#xd; &#xd; FIXME: this is inconsistent with the implementation
            in config:param:value that operates on security-manager information&#xd; ~:)&#xd; let
            $protected := config:param-value($project-config-map,'visibility')='protected'&#xd;
            &#xd; (:~&#xd; : The varible &lt;code&gt;$allowed-users&lt;/code&gt; holds a sequence of
            user names which &#xd; : have rights to accses the requested project. These are set as
            comma separated values&#xd; : in the project's configuration file
            (&lt;code&gt;project.xml&lt;/code&gt;).&#xd; : FIXME: this is inconsistent with the
            implementation in config:param:value that operates on security-manager information&#xd;
            ~:)&#xd; (:let $allowed-users := 'guest' :)&#xd; let $user-may := &#xd; if ($file-type =
            $web-resources) then true()&#xd; else if (not($protected)) then true()&#xd; else &#xd;
            let $allowed-users :=
            tokenize(config:param-value($full-config-map,'users'),'\s*,\s*')&#xd; &#xd; let
            $project-dir := config:param-value($project-config-map,'project-dir')&#xd; (:let
            $domain:= "at.ac.aac.exist."||$cr-instance:)&#xd; let $domain:= "org.exist.login"&#xd;
            &#xd; (: login:set-user() must go before checking the user :) &#xd; let
            $login:=login:set-user($domain, (), false())&#xd; &#xd; let $db-user :=
            request:get-attribute($domain||".user")&#xd; (:let $db-current-user :=
            xmldb:get-current-user():)&#xd; let $shib-user := config:shib-user()&#xd; let $user :=
            if ((not(exists($db-user)) or $db-user='guest') and $shib-user) then &#xd; let $login :=
            xmldb:login($project-dir, 'shib',
            config:param-value($project-config-map,'shib-user-pwd'))&#xd; return 'shib'&#xd; else
            $db-user&#xd; return ($user=$allowed-users)&#xd; (:~&#xd; : The variable
            &lt;code&gt;$domain&lt;/code&gt; holds the name of the login domain to which the users
            &#xd; : of the current cr-xq instance will be logged into.&#xd; : &#xd; : This allows to
            differentiate between logins to different concurrent cr-instances.&#xd; :&#xd; : @see
            call to login:set-user() below. &#xd; ~:)&#xd; &#xd; let $exist-resource-index := if
            ($exist:path eq "/" or $rel-path eq "/") &#xd; then 'index.html' &#xd; else
            $exist:resource &#xd; &#xd; return &#xd; &#xd; switch (true())&#xd; (:~&#xd; : Requests
            for the bases of the cr-xq instance or a cr-project are redirected &#xd; : to the
            'index.html' view. &#xd; ~:)&#xd; case ($debug='controller') return&#xd; let
            $allowed-users := tokenize(config:param-value($full-config-map,'users'),'\s*,\s*')&#xd;
            &#xd; let $project-dir := config:param-value($project-config-map,'project-dir')&#xd;
            (:let $domain:= "at.ac.aac.exist."||$cr-instance:)&#xd; let $domain:=
            "org.exist.login"&#xd; &#xd; (: login:set-user() must go before checking the user :)
            &#xd; let $login:=login:set-user($domain, (), false())&#xd; &#xd; let $db-user :=
            request:get-attribute($domain||".user")&#xd; (:let $db-current-user :=
            xmldb:get-current-user():)&#xd; let $shib-user := config:shib-user()&#xd; let $user :=
            if ((not(exists($db-user)) or $db-user='guest') and $shib-user) then &#xd; let $login :=
            xmldb:login($project-dir, 'shib',
            config:param-value($project-config-map,'shib-user-pwd'))&#xd; return 'shib'&#xd; else
            $db-user&#xd; return&#xd; (: &lt;DEBUG&gt;{$exist-resource-index, '-', $exist:resource
            }&lt;/DEBUG&gt;:)&#xd; &lt;DEBUG &gt;USER exists db-user: {exists($db-user)};
            project-dir: {$project-dir}; usermay: {$user-may}; user:{$user};
            shib-user:{$shib-user}&#xd;
            &lt;allowed-users&gt;{$allowed-users}&lt;/allowed-users&gt;&#xd; &lt;current-user
            &gt;{($db-user,'-',xmldb:get-current-user())}&lt;/current-user&gt;&#xd;
            &lt;attrs&gt;{string-join(request:attribute-names(),', ')}&lt;/attrs&gt;&#xd;
            &lt;/DEBUG&gt;&#xd; &#xd; (: &lt;DEBUG&gt;module: {$module}, project: {$project}
            &lt;/DEBUG&gt;:)&#xd; (:case (($exist:path eq "/" or $rel-path eq "/" ) return &#xd; (\:
            forward root (project) path to index.html :\)&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;redirect
            url="index.html"/&gt; &#xd; &lt;/dispatch&gt;&#xd; :) (:let $path :=
            config:resolve-template-to-uri($project-config-map, "index.html")&#xd; return
            &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;forward
            url="{$path}" /&gt; &#xd; &lt;view&gt;&#xd; &lt;forward
            url="{$exist:controller}/core/view.xql" &gt;&#xd; &lt;add-parameter name="project"
            value="{$project}"/&gt;&#xd; &lt;add-parameter name="x-context"
            value="{$x-context}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist:resource}"/&gt;&#xd; &lt;add-parameter name="exist-controller"
            value="{$exist:controller}"/&gt;&#xd; &lt;add-parameter name="exist-root"
            value="{$exist:root}"/&gt;&#xd; &lt;add-parameter name="exist-prefix"
            value="{$exist:prefix}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;error-handler&gt;&#xd;
            &lt;forward url="{$exist:controller}/error-page.html" method="get"/&gt;&#xd; &lt;forward
            url="{$exist:controller}/core/view.xql"/&gt;&#xd; &lt;/error-handler&gt;&#xd;
            &lt;/view&gt;&#xd; &lt;/dispatch&gt;:)&#xd; &#xd; (:~&#xd; : Requests that should be
            proxied &#xd; ~:)&#xd; case ($exist:resource eq "proxy.xql") return &#xd; let $url :=
            request:get-parameter("url",""),&#xd; $token := util:random()&#xd; let $session :=
            session:set-attribute($url||"-token",$token)&#xd; return&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;forward
            url="{$exist:controller}/proxy.xql"&gt;&#xd; &lt;add-parameter name="{$url}-token"
            value="{$token}"/&gt;&#xd; &lt;set-header name="Cache-Control"
            value="no-cache"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/dispatch&gt;&#xd; &#xd; (:~&#xd; :
            Requests for HTML views are handled by the templating system after check for user
            authorization. &#xd; ~:)&#xd; case (ends-with($exist-resource-index, ".html"))
            return&#xd; (: this is a sequence of two steps, delivering result XOR (either one or the
            other) :)&#xd; (: step 1: only delivers a result if the project's visibility is
            protected :)&#xd; (if ($protected) &#xd; then &#xd; (:let
            $login:=login:set-user($domain, (), false()):)&#xd; (: return:)&#xd; (:if
            (not(request:get-attribute($domain||".user")=$allowed-users)):) &#xd; if
            (not($user-may)) &#xd; then&#xd; (: let
            $log:=util:log("INFO",'user='||request:get-attribute($domain||".user")):)&#xd; (:
            return:)&#xd; &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd;
            &lt;forward url="{$exist:controller}/modules/access-control/login.html"/&gt;&#xd;
            &lt;view&gt;&#xd; &lt;forward url="{$exist:controller}/core/view.xql"&gt;&#xd;
            &lt;add-parameter name="project" value="{$project}"/&gt;&#xd; &lt;add-parameter
            name="x-context" value="{$x-context}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist-resource-index}"/&gt;&#xd; &lt;add-parameter name="exist-controller"
            value="{$exist:controller}"/&gt;&#xd; &lt;add-parameter name="exist-root"
            value="{$exist:root}"/&gt;&#xd; &lt;add-parameter name="exist-prefix"
            value="{$exist:prefix}"/&gt;&#xd; &lt;set-header name="Cache-Control"
            value="no-cache"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/view&gt;&#xd;
            &lt;/dispatch&gt;&#xd; (: it is an allowed user, so just go to the second part :)&#xd;
            else () &#xd; (: not protected, so also go to second part :)&#xd; else (), &#xd; &#xd;
            (: step 2: only delivers result if login is not necessary (i.e. project not protected or
            user already logged-in) :)&#xd; if (not($protected) or $user-may) &#xd; then&#xd; (: let
            $user := request:get-attribute($domain||".user"):)&#xd; let $path :=
            config:resolve-template-to-uri($project-config-map, if
            ($exist-resource-index='index.html') then $exist-resource-index else $rel-path )&#xd; (:
            &lt;add-parameter name="user" value="{$user}"/&gt;:)&#xd; return &#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;forward url="{$path}" /&gt;
            &#xd; &lt;view&gt;&#xd; &lt;forward url="{$exist:controller}/core/view.xql" &gt;&#xd;
            &lt;add-parameter name="project" value="{$project}"/&gt;&#xd; &lt;add-parameter
            name="x-context" value="{$x-context}"/&gt;&#xd; &#xd; &lt;add-parameter
            name="exist-path" value="{$exist:path}"/&gt;&#xd; &lt;add-parameter
            name="exist-resource" value="{$exist:resource}"/&gt;&#xd; &lt;add-parameter
            name="exist-controller" value="{$exist:controller}"/&gt;&#xd; &lt;add-parameter
            name="exist-root" value="{$exist:root}"/&gt;&#xd; &lt;add-parameter name="exist-prefix"
            value="{$exist:prefix}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;error-handler&gt;&#xd;
            &lt;forward url="{$exist:controller}/error-page.html" method="get"/&gt;&#xd; &lt;forward
            url="{$exist:controller}/core/view.xql"/&gt;&#xd; &lt;/error-handler&gt;&#xd;
            &lt;/view&gt;&#xd; &lt;/dispatch&gt;&#xd; (: else login :)&#xd; else () &#xd; )&#xd;
            &#xd; &#xd; (:~ &#xd; : Requests for web resources like JS or CSS are resolved via our
            special resolver. &#xd; : Requests for facsimilia which are likely to reside somewhere
            else, are prefixed &#xd; : with a "/facs" url-step, and are resolved by the facswiewer
            module. &#xd; ~:)&#xd; case ($file-type = $web-resources) return&#xd; (: If the request
            is made from a module (with separate path-step (currently only /get) :)&#xd; let
            $corr-rel-path := &#xd; if (starts-with($rel-path, "/get")) &#xd; then
            substring-after($rel-path, '/get') &#xd; else $rel-path&#xd; let $path :=
            config:resolve-template-to-uri($project-config-map, $corr-rel-path)&#xd; let
            $facs-requested:=starts-with($path,'/facs')&#xd; return&#xd; if ($facs-requested)&#xd;
            then&#xd; &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd;
            &lt;forward url="{$exist:controller}/modules/facsviewer/facsviewer.xql" &gt;&#xd;
            &lt;add-parameter name="project" value="{$project}"/&gt;&#xd; &lt;add-parameter
            name="exist-path" value="{$exist:path}"/&gt;&#xd; &lt;add-parameter
            name="exist-resource" value="{$exist:resource}"/&gt;&#xd; &lt;/forward&gt;&#xd;
            &lt;/dispatch&gt; &#xd; else&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;forward url="{$path}" /&gt;
            &#xd; &lt;/dispatch&gt;&#xd; &#xd; &#xd; (:~&#xd; : projectAdmin module&#xd; ~:)&#xd;
            case ($module = "projectAdmin" ) return&#xd; (: let $user :=
            request:get-attribute($domain||".user"):)&#xd; let $path :=
            config:resolve-template-to-uri($project-config-map, $rel-path)&#xd; return&#xd; let
            $target := &#xd; (: requests for xql endpoints (like store.xql) are passed on, &#xd;
            everything else is forwarded to the main xquery projectAdmin.xql :)&#xd; if
            (ends-with($exist:resource, "xql"))&#xd; then $exist:resource&#xd; else
            "projectAdmin.xql"&#xd; let $url :=
            $exist:controller||"/modules/"||$module||"/"||$target&#xd; let $path-steps :=
            tokenize($exist:path,'/'), &#xd; $form := projectAdmin:form($path-steps[4]),&#xd;
            $form-id := if (exists($form))&#xd; then $path-steps[4]&#xd; else false()&#xd; let
            $project := $path-steps[2]&#xd; return&#xd; switch(true())&#xd; case $target =
            "store.xql" return&#xd; let $parameters := &#xd; let $maps := &#xd; (for $p in
            request:get-parameter-names() &#xd; let $value := request:get-parameter($p,"")&#xd;
            return &#xd; if ($value!='') &#xd; then () &#xd; else map:entry($p,$value),&#xd; for $h
            in request:get-header-names()&#xd; let $val := request:get-header($h)&#xd; return &#xd;
            if ($val!='') &#xd; then () &#xd; else map:entry($h,$val),&#xd;
            map:entry("project-pid",$project)&#xd; )&#xd; return map:new($maps)&#xd; let $process :=
            projectAdmin:store(request:get-data(),$parameters)&#xd; return $process&#xd; &#xd; case
            $target = "get.xql" return&#xd; let $entity := request:get-parameter("entity",""),&#xd;
            $log := util:log("INFO", $entity)&#xd; return projectAdmin:data($project, $entity)&#xd;
            &#xd; case ($form-id or $target != 'projectAdmin.xql') return&#xd; (: &lt;add-parameter
            name="user" value="{$user}"/&gt;:)&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt; &#xd; &lt;forward
            url="{$url}"&gt;&#xd; &lt;add-parameter name="project" value="{$project}"/&gt;&#xd;
            &#xd; &lt;add-parameter name="path" value="{$path}"/&gt;&#xd; &lt;add-parameter
            name="exist-path" value="{$exist:path}"/&gt;&#xd; &lt;add-parameter
            name="exist-resource" value="{$exist:resource}"/&gt;&#xd; &lt;/forward&gt;&#xd;
            &lt;/dispatch&gt;&#xd; &#xd; default return&#xd; let $log := util:log("INFO",
            "redirected request to
            /exist/"||$exist:prefix||$exist:controller||"/"||$project||"/projectAdmin/start")&#xd;
            return&#xd; &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt; &#xd;
            &lt;redirect
            url="/exist/{$exist:prefix}{$exist:controller}/{$project}/projectAdmin/start"/&gt;&#xd;
            &lt;/dispatch&gt;&#xd; &#xd; (:~&#xd; : Requests for a specific module are forwarded
            after having checked user authorization. &#xd; ~:)&#xd; case (not($module=''))
            return&#xd; (if ($module-protected) &#xd; then &#xd; (: CHECK: $logout ?? :)&#xd; (: let
            $logout:= login:set-user($domain, (), false())&#xd; return :)&#xd; if (not($user-may))
            &#xd; then&#xd; &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd;
            &lt;forward url="{$exist:controller}/modules/access-control/login.html"/&gt;&#xd;
            &lt;view&gt;&#xd; &lt;forward url="{$exist:controller}/core/view.xql"&gt;&#xd;
            &lt;add-parameter name="project" value="{$project}"/&gt;&#xd; &lt;add-parameter
            name="exist-path" value="{$exist:path}"/&gt;&#xd; &lt;add-parameter
            name="exist-resource" value="{$exist:resource}"/&gt;&#xd; &lt;add-parameter
            name="exist-controller" value="{$exist:controller}"/&gt;&#xd; &lt;add-parameter
            name="exist-root" value="{$exist:root}"/&gt;&#xd; &lt;add-parameter name="exist-prefix"
            value="{$exist:prefix}"/&gt;&#xd; &lt;set-header name="Cache-Control"
            value="no-cache"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/view&gt;&#xd;
            &lt;/dispatch&gt;&#xd; (: it is an allowed user, so just go to the second part :)&#xd;
            else ()&#xd; (: not protected, so also go to second part :)&#xd; else (), &#xd; &#xd; if
            (not($module-protected) or $user-may) &#xd; then&#xd; (: let $user :=
            request:get-attribute($domain||".user") :)&#xd; (: used by get-module :) &#xd; let
            $corr-rel-path := if (starts-with($rel-path, "/"||$module)) &#xd; then
            substring-after($rel-path, "/"||$module) &#xd; else $rel-path&#xd; let $path :=
            config:resolve-template-to-uri($project-config-map, $rel-path)&#xd; return&#xd; let
            $target := $module||".xql"&#xd; let $url :=
            $exist:controller||"/modules/"||$module||"/"||$target&#xd; (: &lt;add-parameter
            name="user" value="{$user}"/&gt;:)&#xd; return &#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt; &#xd; &lt;forward
            url="{$url}"&gt;&#xd; &lt;add-parameter name="project" value="{$project}"/&gt;&#xd;
            &#xd; &lt;add-parameter name="path" value="{$path}"/&gt;&#xd; &lt;add-parameter
            name="exist-path" value="{$exist:path}"/&gt;&#xd; &lt;add-parameter
            name="exist-resource" value="{$exist:resource}"/&gt;&#xd; &lt;add-parameter
            name="exist-controller" value="{$exist:controller}"/&gt;&#xd; &lt;add-parameter
            name="exist-root" value="{$exist:root}"/&gt;&#xd; &lt;add-parameter name="exist-prefix"
            value="{$exist:prefix}"/&gt;&#xd; &lt;add-parameter name="rel-path"
            value="{$corr-rel-path}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/dispatch&gt;&#xd; (: login
            :)&#xd; else ()&#xd; )&#xd; &#xd; (:~ &#xd; : FCS requests are forwarded to the FCS
            module. &#xd; ~:)&#xd; case (contains($exist:path, "fcs")) return&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;forward
            url="{$exist:controller}/modules/fcs/fcs.xql" &gt;&#xd; &lt;add-parameter name="project"
            value="{$project}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist:resource}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/dispatch&gt;&#xd; &#xd;
            &#xd; (:~&#xd; : AQAY Requests are forwarded to the aqay module: &#xd; ~:)&#xd; case
            (contains($exist:path, "aqay")) return&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;forward
            url="{$exist:controller}/modules/aqay/aqay.xql" &gt;&#xd; &lt;add-parameter
            name="project" value="{$project}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist:resource}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/dispatch&gt;&#xd;
            (:~&#xd; : Requests for specific resources are forwarded to the resource module: &#xd;
            ~:)&#xd; case (contains($exist:path, "resource")) return&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;forward
            url="{$exist:controller}/modules/resource/resource.xql" &gt;&#xd; &lt;add-parameter
            name="project" value="{$project}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist:resource}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/dispatch&gt;&#xd; &#xd;
            &#xd; (: case (starts-with($rel-path, "/get")) return&#xd; let $id :=
            request:get-parameter
            ('id',substring-before(substring-after($rel-path,'/get/'),'/'))&#xd; let $format :=
            request:get-parameter('format','xml')&#xd; return&#xd; if ($format='xml') &#xd;
            then&#xd; &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd;
            &lt;forward url="{$exist:controller}/modules/get/get.xql"&gt;&#xd; &lt;add-parameter
            name="resource-id" value="{$id}"/&gt;&#xd; &lt;add-parameter name="project"
            value="{$project}"/&gt;&#xd; &lt;add-parameter name="rel-path"
            value="{$rel-path}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist:resource}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/dispatch&gt;&#xd;
            else&#xd; &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd;
            &lt;forward url="{$exist:controller}/modules/get/get.xql"&gt;&#xd; &lt;add-parameter
            name="resource-id" value="{$id}"/&gt;&#xd; &lt;add-parameter name="project"
            value="{$project}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="rel-path"
            value="{$rel-path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist:resource}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;view&gt;&#xd; &lt;forward
            url="{$exist:controller}/core/view.xql"&gt;&#xd; &lt;add-parameter name="project"
            value="{$project}"/&gt;&#xd; &lt;add-parameter name="exist-path"
            value="{$exist:path}"/&gt;&#xd; &lt;add-parameter name="exist-resource"
            value="{$exist:resource}"/&gt;&#xd; &lt;add-parameter name="exist-controller"
            value="{$exist:controller}"/&gt;&#xd; &lt;add-parameter name="exist-root"
            value="{$exist:root}"/&gt;&#xd; &lt;add-parameter name="exist-prefix"
            value="{$exist:prefix}"/&gt;&#xd; &lt;/forward&gt;&#xd; &lt;/view&gt;&#xd;
            &lt;/dispatch&gt;&#xd; :)&#xd; default return&#xd; (:~&#xd; : everything else is passed
            through &#xd; ~:)&#xd; &lt;dispatch
            xmlns="http://exist.sourceforge.net/NS/exist"&gt;&#xd; &lt;cache-control
            cache="yes"/&gt;&#xd; &lt;/dispatch&gt;</f>
        <f n="lookup-test.xql">xquery version "3.0";&#xd; &#xd; declare namespace
            fcs="http://clarin.eu/fcs/1.0";&#xd; declare namespace
            cr="http://aac.ac.at/content_repository";&#xd; declare namespace
            tei="http://www.tei-c.org/ns/1.0";&#xd; declare namespace mets =
            "http://www.loc.gov/METS/";&#xd; &#xd; import module namespace
            config="http://exist-db.org/xquery/apps/config" at "core/config.xqm"; &#xd; import
            module namespace project = "http://aac.ac.at/content_repository/project" at
            "core/project.xqm";&#xd; import module namespace wc =
            "http://aac.ac.at/content_repository/workingcopy" at "core/wc.xqm";&#xd; import module
            namespace master = "http://aac.ac.at/content_repository/master" at
            "core/master.xqm";&#xd; import module namespace rf =
            "http://aac.ac.at/content_repository/resourcefragment" at
            "core/resourcefragment.xqm";&#xd; &#xd; (: declaration of helper namespaces for better
            code structuring :)&#xd; declare namespace param="userinput.parameters";&#xd; declare
            namespace this="current.object";&#xd; &#xd; declare function
            cr:get-resourcefragment-pids($project-pid as xs:string, $resource-pid as xs:string,
            $elt-id as xs:string) as xs:string* {&#xd; (: lookup via table -&gt; faster, but needs
            own index file + processing :)&#xd; let
            $lts:="/db/cr-data/_lookup_tables"||"/"||$project-pid&#xd; let
            $table:=collection($lts)//fcs:lookup-table[@pid eq $resource-pid]&#xd; return
            $table//fcs:ResourceFragment[cr:id/@cr:id eq
            $elt-id]/xs:string(@resourcefragment-pid)&#xd; &#xd; (: lookup via
            rescourcefragments-cache, slower, but needs less space + processing at ingest :)&#xd; (:
            let $rfc:="/db/cr-data/_resourcefragments"||"/"||$project-pid,:)&#xd; (:
            $rf:=collection($rfc)//*[@cr:id eq $elt-id and @cr:resource-pid eq
            $resource-pid]/ancestor::fcs:ResourceFragment:)&#xd; (: return
            $rf/@resourcefragment-pid:)&#xd; };&#xd; &#xd; &#xd; &#xd; declare function
            cr:get-pids($param:elt as item()) as map() {&#xd; let $elt:=&#xd; typeswitch
            ($param:elt)&#xd; case element() return $param:elt&#xd; default return
            $param:elt/parent::*&#xd; let $elt-id:= $elt/@cr:id,&#xd;
            $elt-ns:=namespace-uri($param:elt),&#xd; $elt-name:=name($param:elt)&#xd; &#xd; let
            $project-pid:=$elt/@cr:project-id,&#xd; $resource-pid:=$elt/@cr:resource-pid,&#xd;
            $resourcefragment-pids:=cr:get-resourcefragment-pids($project-pid,$resource-pid,$elt-id)&#xd;
            &#xd; let $maps:=(&#xd; map:entry("elt-id",$elt/@cr:id),&#xd;
            map:entry("elt-ns",$elt-ns),&#xd; map:entry("elt-name",$elt-name),&#xd;
            map:entry("project-pid",$project-pid),&#xd;
            map:entry("resource-pid",$resource-pid),&#xd; for $f at $pos in $resourcefragment-pids
            return map:entry('resourcefragment-pid-'||$pos, $f),&#xd;
            map:entry("data",util:serialize($elt,'method=xml'))&#xd; )&#xd; return
            map:new($maps)&#xd; };&#xd; &#xd; let $project:="abacus"&#xd; &#xd; (:let
            $cr-data-path:="/db/cr-data",&#xd; $rf-path:=$cr-data-path||"/_resourcefragments",&#xd;
            $wc-path:=$cr-data-path||"/_working_copies"&#xd; &#xd; let
            $project-rf:=collection($rf-path||"/"||$project),&#xd;
            $project-wc:=$wc-path||"/"||$project&#xd; &#xd; let $searchpath:=$project-wc&#xd; let
            $base:=collection($searchpath)&#xd; &#xd; let $match:=$base//@lemma[.='Haus']&#xd; let
            $pids:=for $m in $match return cr:get-pids($m)&#xd; let
            $number-of-matches:=count($match)&#xd; return &#xd; ("number of matches:
            "||$number-of-matches,&#xd; for $p in $pids &#xd; return &#xd; ("*****",for $key in
            map:keys($p) return $key||": "||map:get($p, $key))&#xd; )&#xd; (\:return $match:\)&#xd;
            :)&#xd; (:let $rf-pid:="res21b4ce57ff094ba79b55_frag00000017",&#xd;
            $r-pid:="res21b4ce57ff094ba79b55"&#xd; return wc:generate($r-pid,$project):)&#xd; let
            $data:=&lt;sm:permission xmlns:sm="http://exist-db.org/xquery/securitymanager"
            owner="admin" group="dba" mode="rwxr-xr-x"&gt;&#xd; &lt;sm:acl entries="0"/&gt;&#xd;
            &lt;/sm:permission&gt;&#xd; return project:acl("someProject",())</f>
        <f n="proxy.xql">xquery version "3.0";&#xd; &#xd; import module namespace
            http="http://expath.org/ns/http-client";&#xd; declare namespace
            xlink="http://www.w3.org/1999/xlink";&#xd; declare namespace
            mets="http://www.loc.gov/METS/";&#xd; &#xd; (:~&#xd; : This XQuery Script acts as a
            simple proxy which requests &#xd; : a given img resource via http (remote or local),
            giving the possibility &#xd; : to add complex authorization setups etc. not to be
            visible from &#xd; : within the eXist-context.&#xd; :&#xd; : @param resource the
            resource to be fetched from remote server in the form "ob"&#xd; : @param debug return
            http response as content or just header information (default='no') &#xd; ~:)&#xd; &#xd;
            let $url:=request:get-parameter('url',''),&#xd;
            $token:=request:get-parameter($url||'-token',''),&#xd;
            $client-ip:=request:get-remote-addr(),&#xd;
            $user:=session:get-attribute($url||"-username"),&#xd;
            $pw:=session:get-attribute($url||"-password"),&#xd;
            $auth-type:=request:get-parameter('auth-method','basic'),&#xd;
            $send-authorization:=request:get-parameter('send-authorization','false')&#xd; let
            $debug:=request:get-parameter('debug','no')&#xd; &#xd; let $request:= &lt;http:request
            &#xd; href="{$url}" &#xd; method="get"&#xd; &gt;{&#xd; if ($user!='' and $pw!='')&#xd;
            then &#xd; (attribute username {$user},&#xd; attribute password {$pw},&#xd; attribute
            auth-method {$auth-type},&#xd; attribute send-authorization {$send-authorization})&#xd;
            else ()&#xd; &#xd; }&lt;/http:request&gt;&#xd; let $response:= &#xd; if ($token =
            xs:string(session:get-attribute($url||"-token"))) &#xd; then http:send-request($request)
            &#xd; else &lt;error&gt;Proxying only allowed for localhost.&lt;/error&gt;&#xd; let
            $response-header:=$response[1][self::http:response]&#xd; let
            $response-content:=$response[2]&#xd; let $clean-session := (&#xd;
            session:remove-attribute($url||"-username"),&#xd;
            session:remove-attribute($url||"-password"),&#xd;
            session:remove-attribute($url||"-token")&#xd; )&#xd; return&#xd; if ($debug =
            'yes')&#xd; then &#xd; &lt;debug&gt;&#xd; {$response-header}&#xd;
            &lt;client-ip&gt;{$client-ip}&lt;/client-ip&gt;&#xd; {for $p in
            request:get-parameter-names()&#xd; return &lt;param name="{$p}"
            value="{request:get-parameter($p,'')}"/&gt;}&#xd; &lt;/debug&gt;&#xd; else&#xd; if
            ($response-header/@status = '200')&#xd; then &#xd; if ($response-content instance of
            xs:base64Binary)&#xd; then response:stream-binary(&#xd; $response-content,&#xd;
            xs:string($response-header/http:body/@media-type)&#xd; )&#xd; else
            $response-content&#xd; else&#xd; let $set-status:=&#xd;
            if(exists($response-header))&#xd; then
            response:set-status-code($response-header/@status)&#xd; else ()&#xd; return&#xd;
            &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&#xd; &lt;head&gt;&#xd;
            &lt;title&gt;srrrry ... &lt;/title&gt;&#xd; &lt;/head&gt;&#xd; &lt;body&gt;&#xd;
            &lt;p&gt;There was a problem:&lt;/p&gt;&#xd; &lt;p&gt;msg:
            &lt;i&gt;{data(($response-header/@message,$response))}&lt;/i&gt;&lt;/p&gt;&#xd;
            &lt;/body&gt;&#xd; &lt;/html&gt;&#xd; </f>
        <f n="restxq.xql">xquery version "3.0";&#xd; &#xd; module namespace api =
            "http://www.aac.ac.at/content_repository/api";&#xd; declare namespace
            rest="http://exquery.org/ns/restxq";&#xd; declare namespace
            output="http://www.w3.org/2010/xslt-xquery-serialization";&#xd; &#xd; declare namespace
            cr="http://aac.ac.at/content_repository";&#xd; declare namespace mets =
            "http://www.loc.gov/METS/";&#xd; declare namespace
            mods="http://www.loc.gov/mods/v3";&#xd; declare namespace metsrights =
            "http://cosimo.stanford.edu/sdr/metsrights/";&#xd; declare namespace
            sm="http://exist-db.org/xquery/securitymanager";&#xd; &#xd; (: *** project.xqm ***
            :)&#xd; declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq")&#xd; function
            api:project_project-pids() {&#xd; ()&#xd; (:project:project-pids():)&#xd; };&#xd; &#xd;
            declare &#xd; %rest:POST&#xd; %rest:path("/cr_xq")&#xd; function api:project_new()
            {&#xd; ()&#xd; (:project:new():)&#xd; };&#xd; &#xd; &#xd; declare&#xd; %rest:POST&#xd;
            %rest:path("/cr_xq/{$project-pid}")&#xd; function api:project_new($project-pid as
            xs:string) {&#xd; ()&#xd; (:project:new($project-pid as xs:string):)&#xd; };&#xd; &#xd;
            declare&#xd; %rest:PUT("{$data}")&#xd; %rest:path("/cr_xq/{$project-pid}")&#xd; function
            api:project_new($data as element(mets:mets),$project-pid as xs:string?) as
            element(mets:mets)? {&#xd; ()&#xd; (:project:new($data as
            element(mets:mets),$project-pid as xs:string?) as element(mets:mets)? ):)&#xd; };&#xd;
            &#xd; &#xd; declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/label")&#xd;
            %output:method("xml")&#xd; %output:media-type("text/xml")&#xd; function
            api:project_label($project-pid as xs:string) as element(data) {&#xd; ()&#xd;
            (:project:label($project-pid as xs:string) as element(data):)&#xd; };&#xd; &#xd;
            declare&#xd; %rest:PUT("{$data}")&#xd; %rest:path("/cr_xq/{$project-pid}/label")&#xd;
            function api:project_label($project-pid as xs:string, $data as document-node()) as
            document-node() {&#xd; ()&#xd; (:project:label($project-pid as xs:string, $data as
            document-node()) as document-node():)&#xd; };&#xd; &#xd; declare &#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project}")&#xd; function api:project_get($project) as
            element(mets:mets)? {&#xd; ()&#xd; (:project:get($project) as
            element(mets:mets)?):)&#xd; };&#xd; &#xd; &#xd; declare&#xd; %rest:DELETE&#xd;
            %rest:path("/cr_xq/{$project-pid}")&#xd; function api:project_purge($project-pid as
            xs:string) as empty() {&#xd; ()&#xd; (:project:purge($project-pid as xs:string) as
            empty():)&#xd; };&#xd; &#xd; declare&#xd; %rest:DELETE&#xd;
            %rest:query-param("delete-data", "{$delete-data}")&#xd;
            %rest:path("/cr_xq/{$project-pid}")&#xd; function api:project_purge($project-pid as
            xs:string, $delete-data as xs:boolean*) as empty() {&#xd; ()&#xd;
            (:project:purge($project-pid as xs:string, $delete-data as xs:boolean*) as
            empty():)&#xd; };&#xd; &#xd; &#xd; declare &#xd;
            %rest:path("/cr_xq/{$project-pid}/status")&#xd; %rest:PUT("{$data}")&#xd; function
            api:project_status($project-pid as xs:string, $data as document-node()) as
            document-node()? {&#xd; ()&#xd; (:project:status($project-pid as xs:string, $data as
            document-node()) as document-node()?):)&#xd; };&#xd; &#xd; declare &#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/status")&#xd; function api:project_status($project-pid
            as xs:string) as element(data) {&#xd; ()&#xd; (:project:status($project-pid as
            xs:string) as element(data):)&#xd; };&#xd; &#xd; declare&#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/status-code")&#xd; function
            api:project_status-code($project-pid as xs:string) as element(data) {&#xd; ()&#xd;
            (:project:status-code($project-pid as xs:string) as element(data):)&#xd; };&#xd; &#xd;
            declare &#xd; %rest:path("/cr_xq/{$project-pid}/status-code")&#xd;
            %rest:PUT("{$data}")&#xd; function api:project_status-code($project-pid as xs:string,
            $data as xs:integer) as empty() {&#xd; ()&#xd; (:project:status-code($project-pid as
            xs:string, $data as xs:integer) as empty():)&#xd; };&#xd; &#xd; declare&#xd;
            %rest:GET&#xd; %rest:path("/cr_xq/status-list") &#xd; function
            api:project_list-defined-status() as element(status){&#xd; ()&#xd; };&#xd; &#xd;
            declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/resources")&#xd; function
            api:project_resources($project-pid as xs:string) as element(mets:div)* {&#xd; ()&#xd;
            (:project:list-defined-status() as element(status){&#xd; ()&#xd; };&#xd; &#xd;
            declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/resources")&#xd; function
            api:project_resources($project-pid as xs:string) as element(mets:div)*):)&#xd; };&#xd;
            &#xd; declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/resource-pids")&#xd;
            function api:project_resource-pids($project-pid as xs:string) as xs:string* {&#xd;
            ()&#xd; (:project:resource-pids($project-pid as xs:string) as xs:string*):)&#xd; };&#xd;
            &#xd; declare &#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/metsHdr")&#xd;
            function api:project_metsHdr($project-pid as xs:string) as element(mets:metsHdr){&#xd;
            ()&#xd; };&#xd; &#xd; declare&#xd; %rest:path("/cr_xq/{$project-pid}/metsHdr")&#xd;
            %rest:PUT("{$data}")&#xd; function api:project_metsHdr($project-pid as xs:string, $data
            as element(mets:metsHdr)) as empty() {&#xd; ()&#xd; (:project:metsHdr($project-pid)
            :)&#xd; ()&#xd; };&#xd; &#xd; declare&#xd;
            %rest:path("/cr_xq/{$project-pid}/metsHdr")&#xd; %rest:PUT("{$data}")&#xd; function
            api:project_metsHdr($project-pid as xs:string, $data as element(mets:metsHdr)) as
            empty() {&#xd; ()&#xd; };&#xd; &#xd; declare &#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/dmd")&#xd; function api:project_dmd($project-pid as
            xs:string) as element(mods:mods){&#xd; ()&#xd; };&#xd; &#xd; declare&#xd;
            %rest:path("/cr_xq/{$project-pid}/dmd")&#xd; %rest:PUT("{$data}")&#xd; function
            api:project_dmd($project-pid as xs:string, $data as element(mods:mods)) as empty()
            {&#xd; ()&#xd; (:project:dmd($project-pid as xs:string):)&#xd; };&#xd; &#xd; &#xd;
            declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project}/map") &#xd; function
            api:project_map($project) as element(map)? {&#xd; ()&#xd; (:project:map($project) as
            element(map)?):)&#xd; };&#xd; &#xd; declare&#xd;
            %rest:path("/cr_xq/{$project-pid}/map")&#xd; %rest:PUT("{$data}")&#xd; function
            api:project_map($project-pid as xs:string, $data as element(map)) as empty() {&#xd;
            ()&#xd; (:project:map($project-pid as xs:string, $data as element(map)) as
            empty():)&#xd; };&#xd; &#xd; declare &#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/parameters") &#xd; function
            api:project_parameters($project-pid as xs:string) as element(param)* {&#xd; ()&#xd;
            (:project:parameters($project-pid as xs:string) as element(param)*):)&#xd; };&#xd; &#xd;
            declare&#xd; %rest:path("/cr_xq/{$project-pid}/parameters")&#xd;
            %rest:PUT("{$data}")&#xd; function api:project_parameters($project-pid as xs:string,
            $data as element(param)*) as empty() {&#xd; ()&#xd; (:project:parameters($project-pid as
            xs:string, $data as element(param)*) as empty():)&#xd; };&#xd; &#xd; declare&#xd;
            %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/moduleconfig")&#xd; function
            api:project_moduleconfig($project-pid as xs:string) as element(module)* {&#xd; ()&#xd;
            (:project:moduleconfig($project-pid as xs:string) as element(module)*):)&#xd; };&#xd;
            &#xd; declare&#xd; %rest:path("/cr_xq/{$project-pid}/moduleconfig")&#xd;
            %rest:PUT("{$data}")&#xd; function api:project_moduleconfig($project-pid as xs:string,
            $data as element(module)*) as empty() {&#xd; ()&#xd; (:project:moduleconfig($project-pid
            as xs:string, $data as element(module)*) as empty():)&#xd; };&#xd; &#xd; &#xd;
            declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/license")&#xd; function
            api:project_license($project-pid as xs:string) as
            element(metsrights:RightsDeclarationMD)? {&#xd; ()&#xd; (:project:license($project-pid
            as xs:string) as element(metsrights:RightsDeclarationMD)?):)&#xd; };&#xd; &#xd;
            declare&#xd; %rest:path("/cr_xq/{$project-pid}/license")&#xd; %rest:PUT("{$data}")&#xd;
            function api:project_license($project-pid as xs:string, $data as
            element(metsrights:RightsDeclarationMD)?) as empty() {&#xd; ()&#xd;
            (:project:license($project-pid as xs:string, $data as
            element(metsrights:RightsDeclarationMD)?) as empty():)&#xd; };&#xd; &#xd; &#xd;
            declare&#xd; %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/acl")&#xd; function
            api:project_acl($project-pid as xs:string) as element(sm:permission)? {&#xd; ()&#xd;
            (:project:acl($project-pid as xs:string) as element(sm:permission)?):)&#xd; };&#xd;
            &#xd; declare &#xd; %rest:path("/cr_xq/{$project-pid}/acl")&#xd;
            %rest:PUT("{$data}")&#xd; function api:project_acl($project-pid as xs:string, $data as
            element(sm:permission)?) as empty() {&#xd; ()&#xd; (:project:acl($project-pid as
            xs:string, $data as element(sm:permission)?) as empty():)&#xd; };&#xd; &#xd; &#xd; (:
            *** resource.xqm *** :)&#xd; declare &#xd; %rest:DELETE&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}")&#xd; function
            api:resource_purge($resource-pid as xs:string, $project-pid as xs:string){&#xd; ()&#xd;
            };&#xd; &#xd; declare&#xd; %rest:DELETE&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}")&#xd;
            %rest:query-param("delete-data","{$delete-data}")&#xd; function
            api:resource_purge($resource-pid as xs:string, $project-pid as xs:string, $delete-data
            as xs:boolean*) as empty() {&#xd; ()&#xd; (:resource:purge($resource-pid as xs:string,
            $project-pid as xs:string):)&#xd; };&#xd; &#xd; declare&#xd; %rest:DELETE&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}")&#xd;
            %rest:query-param("delete-data","{$delete-data}")&#xd; function
            api:resource_purge($resource-pid as xs:string, $project-pid as xs:string, $delete-data
            as xs:boolean*) as empty() {&#xd; ()&#xd; (:resource:purge($resource-pid, $project-pid,
            $delete-data):)&#xd; };&#xd; &#xd; declare&#xd; %rest:POST("{$data}")&#xd;
            %rest:path("/cr_xq/{$project-pid}/newResourceWithLabel")&#xd;
            %rest:header-param("resource-label", "{$resource-label}")&#xd; function
            api:resource_new-with-label($data as document-node(), $project-pid as xs:string,
            $resource-label as xs:string*) {&#xd; ()&#xd; (:resource:new-with-label($data as
            document-node(), $project-pid as xs:string, $resource-label as xs:string*):)&#xd;
            };&#xd; &#xd; declare&#xd; %rest:POST("{$data}")&#xd;
            %rest:path("/cr_xq/{$project-pid}/newResource")&#xd; function api:resource_new($data as
            document-node(), $project-pid as xs:string){&#xd; ()&#xd; };&#xd; &#xd; declare&#xd;
            %rest:POST("{$data}")&#xd; %rest:path("/cr_xq/{$project-pid}/newResource")&#xd;
            %rest:query-param("make-fragments","{$make-fragments}")&#xd; function
            api:resource_new($data as document-node(), $project-pid as xs:string, $make-fragments as
            xs:boolean*) as xs:string? {&#xd; ()&#xd; (: resource:new($data, $project-pid):)&#xd;
            };&#xd; &#xd; declare&#xd; %rest:POST("{$data}")&#xd;
            %rest:path("/cr_xq/{$project-pid}/newResource")&#xd;
            %rest:query-param("make-fragments","{$make-fragments}")&#xd; function
            api:resource_new($data as document-node(), $project-pid as xs:string, $make-fragments as
            xs:boolean*) as xs:string? {&#xd; ()&#xd; (: resource:new($data,
            $project-pid,$make-fragments):)&#xd; };&#xd; &#xd; declare&#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/entry")&#xd; function
            api:resource_get($resource-pid as xs:string,$project-pid as xs:string) as
            element(mets:div)? {&#xd; ()&#xd; (: resource:get($resource-pid,$project-pid) :) &#xd;
            };&#xd; &#xd; declare&#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/files")&#xd; function
            api:resource_files($resource-pid as xs:string,$project-pid as xs:string) as
            element(mets:fileGrp)? {&#xd; ()&#xd;
            (:resource:files($resource-pid,$project-pid):)&#xd; };&#xd; &#xd; declare&#xd;
            %rest:GET&#xd; %rest:path("/cr_xq/{$project-pid}/{$resource-pid}")&#xd; function
            api:resource_master($resource-pid as xs:string, $project-pid as xs:string) as
            document-node()? {&#xd; ()&#xd; (:resource:master($resource-pid, $project-pid):)&#xd;
            };&#xd; &#xd; declare&#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/dmd")&#xd; function
            api:resource_dmd-from-id($resource-pid as xs:string,$project-pid as xs:string) as
            element()? {&#xd; ()&#xd; (:resource:dmd-from-id($resource-pid,$project-pid):)&#xd;
            };&#xd; &#xd; declare&#xd; %rest:PUT("{$data}")&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/dmd")&#xd;
            %rest:query-param("mdtype","{$mdtype}","TEI")&#xd; function
            api:resource_dmd($resource-pid as xs:string, $project-pid as xs:string, $data as item(),
            $mdtype as xs:string*) as empty() {&#xd; ()&#xd; (:resource:dmd($resource-pid,
            $project-pid, $data, $mdtype):)&#xd; };&#xd; &#xd; declare&#xd;
            %rest:PUT("{$data}")&#xd; %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/dmd")&#xd;
            function api:resource_dmd($resource-pid as xs:string, $project-pid as xs:string, $data
            as item(), $mdtype as xs:string, $store-to-db as xs:boolean?) as empty() {&#xd; ()&#xd;
            (:resource:dmd($resource-pid, $project-pid, $data, $mdtype, $store-to-db):)&#xd; };&#xd;
            &#xd; &#xd; declare&#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/label")&#xd; function
            api:resource_label($resource-pid as xs:string, $project-pid as xs:string) as
            element(cr:response) {&#xd; ()&#xd; (:resource:label($resource-pid, $project-pid):)&#xd;
            };&#xd; &#xd; declare&#xd; %rest:PUT("{$data}")&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/label")&#xd; function
            api:resource_label($data as document-node(), $resource-pid as xs:string, $project-pid as
            xs:string) as element(cr:response)? {&#xd; ()&#xd; (:resource:label($data,
            $resource-pid, $project-pid):)&#xd; };&#xd; &#xd; &#xd; (: *** resourcefragment.xqm ***
            :)&#xd; declare&#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/{$resourcefragment-pid}/entry")&#xd;
            function api:rf_record($resourcefragment-pid as xs:string, $resource-pid as xs:string,
            $project-pid as xs:string) as element(mets:div)? {&#xd; ()&#xd;
            (:rf:record($resourcefragment-pid, $resource-pid, $project-pid):)&#xd; };&#xd; &#xd;
            declare&#xd; %rest:GET&#xd;
            %rest:path("/cr_xq/{$project-pid}/{$resource-pid}/{$resourcefragment-pid}")&#xd;
            function api:rf_get($resourcefragment-pid as xs:string, $resource-pid as xs:string,
            $project-pid as xs:string) as element()? {&#xd; ()&#xd; (:rf:get($resourcefragment-pid,
            $resource-pid, $project-pid) :)&#xd; };</f>
        <f n="sandbox.xql">xquery version "3.0";&#xd; &#xd; declare namespace
            cr="http://aac.ac.at/content_repository";&#xd; declare namespace
            tei="http://www.tei-c.org/ns/1.0";&#xd; declare namespace mets =
            "http://www.loc.gov/METS/";&#xd; &#xd; &#xd; (:import module namespace
            repo-utils="http://aac.ac.at/content_repository/utils" at "core/repo-utils.xqm";:)&#xd;
            import module namespace fcs="http://clarin.eu/fcs/1.0" at "modules/fcs/fcs.xqm";&#xd;
            import module namespace config="http://exist-db.org/xquery/apps/config" at
            "core/config.xqm"; &#xd; import module namespace toc =
            "http://aac.ac.at/content_repository/toc" at "core/toc.xqm";&#xd; &#xd; let
            $resource-pid := "abacus2.5", &#xd; $project-pid := "abacus2",&#xd; $indexes :=
            "chapter"&#xd; &#xd; return toc:generate($indexes,$resource-pid,$project-pid)</f>
        <f n="sandbox_init_project.xql">xquery version "3.0"; declare namespace
            cr="http://aac.ac.at/content_repository"; declare namespace
            tei="http://www.tei-c.org/ns/1.0"; declare namespace mets = "http://www.loc.gov/METS/";
            import module namespace repo-utils="http://aac.ac.at/content_repository/utils" at
            "core/repo-utils.xqm"; import module namespace
            config="http://exist-db.org/xquery/apps/config" at "core/config.xqm"; import module
            namespace project = "http://aac.ac.at/content_repository/project" at "core/project.xqm";
            import module namespace index = "http://aac.ac.at/content_repository/index" at
            "core/index.xqm"; let $project-pid := 'abacus' (:return project:new($project-pid):) (:
            return index:store-xconf($project-pid ):) </f>
        <f n="sandbox_init_resource.xql">xquery version "3.0"; import module namespace
            repo-utils="http://aac.ac.at/content_repository/utils" at "core/repo-utils.xqm"; import
            module namespace project="http://aac.ac.at/content_repository/project" at
            "core/project.xqm"; import module namespace
            resource="http://aac.ac.at/content_repository/resource" at "core/resource.xqm"; import
            module namespace rf="http://aac.ac.at/content_repository/resourcefragment" at
            "core/resourcefragment.xqm"; import module namespace
            facs="http://aac.ac.at/content_repository/facs" at "core/facs.xqm"; import module
            namespace wc="http://aac.ac.at/content_repository/workingcopy" at "core/wc.xqm"; import
            module namespace config="http://exist-db.org/xquery/apps/config" at "core/config.xqm";
            import module namespace cr="http://aac.ac.at/content_repository" at "core/cr.xqm";
            declare namespace cmd="http://www.clarin.eu/cmd/"; declare namespace mets =
            "http://www.loc.gov/METS/"; declare namespace fcs = "http://clarin.eu/fcs/1.0"; declare
            namespace xlink="http://www.w3.org/1999/xlink"; declare namespace tei =
            "http://www.tei-c.org/ns/1.0"; let $resource-pid := "abacus.3", $project-pid := "abacus"
            (: let $resource-pid := "dict-gate.3", $project-pid := "dict-gate" :) (:let $md :=
            doc("/db/cr-data/_tmp/dict-gate/dict-gate.cmd.xml")/*:) (: let $md :=
            doc("/db/cr-data/_temp/abacus_md/TEIHDR/md-abacus.9.xml"):) let $data :=
            doc("/db/cr-data/_tmp/Abraham-Loesch_Wienn_persKeys-rm-toks-ids-pos.xml") (:let
            $resource-pid := resource:new-with-label(doc($temp-file-path),$project-pid,
            $resource-label):) (: return $resource-pid:) (:let $rf-gen := rf:generate($resource-pid,
            $project-pid):) (: :) (:let $lt-gen := lt:generate($resource-pid, $project-pid):) (::)
            (:let $toc-gen := toc:generate(('front','chapter'), $resource-pid, $project-pid):) (: :)
            (: return ($resource-pid, $rf-gen):) (:return resource:get-toc-resolved($project-pid):)
            (::) let $gen-aux := resource:refresh-aux-files($resource-pid, $project-pid) (::) (:let
            $gen-facs := facs:generate($resource-pid,$project-pid):) return $gen-aux (:return
            ($resource-pid, $gen-aux, $gen-facs):) (: return ($lt-gen, $toc-gen):) (:return
            resource:dmd($resource-pid,$project-pid):) (:return
            resource:dmd($resource-pid,$project-pid,$md,"TEIHDR",true()):) (:return
            resource:dmd("CMDI",$resource-pid,$project-pid):) (:return
            resource:set-handle("data",$resource-pid,$project-pid):) (:return
            resource:label($resource-pid,$project-pid):) (: return resource:dmd2dc($resource-pid,
            $project-pid):) </f>
        <f n="setup.xql">xquery version "3.0"; import module namespace
            xdb="http://exist-db.org/xquery/xmldb"; import module namespace
            config="http://exist-db.org/xquery/apps/config-params" at "core/config.xql"; import
            module namespace configm="http://exist-db.org/xquery/apps/config" at "core/config.xqm";
            import module namespace project="http://aac.ac.at/content_repository/project" at
            "core/project.xqm"; (: The following external variables are set by the repo:deploy
            function :) (: file path pointing to the exist installation directory :) declare
            variable $home external; (: path to the directory containing the unpacked .xar package
            :) declare variable $dir external; (: the target collection into which the app is
            deployed :) declare variable $target external; declare function
            local:mkcol-recursive($collection, $components) { if (exists($components)) then let
            $newColl := concat($collection, "/", $components[1]) return (
            xdb:create-collection($collection, $components[1]), local:mkcol-recursive($newColl,
            subsequence($components, 2)) ) else () }; (: Helper function to recursively create a
            collection hierarchy. :) declare function local:mkcol($collection, $path) {
            local:mkcol-recursive($collection, tokenize($path, "/")) }; declare variable
            $local:cr-writer:=doc($target||"/modules/access-control/writer.xml")/write; declare
            variable $local:projects-xconf := doc($target||"_cr-projects.xconf"); (: setup
            projects-dir :) local:mkcol("", $config:projects-dir), local:mkcol("",
            $config:data-dir), (: store the collection configuration :)
            local:mkcol("/db/system/config", $target),
            xdb:store-files-from-pattern(concat("/system/config", $target), $dir, "*.xconf"), (:
            store the cr-projects collection configuration :) local:mkcol("/db/system/config",
            $config:projects-dir),
            xdb:store("/db/system/config/"||$config:projects-dir,'collection.xconf',$local:projects-xconf),
            (: we need two system users for the data maangement :) (: TODO merge these into one? :)
            util:log("INFO", "** setting up writer account **"), if
            (not(sm:user-exists(xs:string($local:cr-writer/write-user)))) then
            sm:create-account(xs:string($local:cr-writer/write-user),xs:string($local:cr-writer/write-user-cred),())
            else
            sm:passwd(xs:string($local:cr-writer/write-user),xs:string($local:cr-writer/write-user-cred)),
            util:log("INFO", "** setting up cr-xq system account **"), if
            (not(sm:user-exists($config:system-account-user))) then
            sm:create-account($config:system-account-user,$config:system-account-pwd,()) else
            sm:passwd($config:system-account-user,$config:system-account-pwd), if
            (not(sm:group-exists("cr-admin"))) then
            sm:create-group("cr-admin",$config:system-account-user,"admin") else (),
            util:log("INFO", "** chown "||$config:projects-dir||"
            "||$config:system-account-user||":cr-admin"),
            sm:chown(xs:anyURI($config:projects-dir),$config:system-account-user),
            sm:chgrp(xs:anyURI($config:data-dir),'cr-admin'), util:log("INFO", "** chown
            "||$config:data-dir||" "||$config:system-account-user||":cr-admin"),
            sm:chown(xs:anyURI($config:projects-dir),$config:system-account-user),
            sm:chgrp(xs:anyURI($config:data-dir),'cr-admin'), util:log("INFO", "** setting up
            default project 'defaultProject' **"), project:new("defaultProject") </f>
        <f n="setup_project.xql">xquery version "3.0";&#xd; &#xd; import module namespace
            config="http://exist-db.org/xquery/apps/config" at
            "/db/apps/cr-xq/core/config.xqm";&#xd; &#xd; (:~ setup project :)&#xd; &#xd; &#xd;
            declare function local:mkcol-recursive($collection, $components) {&#xd; if
            (exists($components)) then&#xd; let $newColl := concat($collection, "/",
            $components[1])&#xd; return (&#xd; xmldb:create-collection($collection,
            $components[1]),&#xd; local:mkcol-recursive($newColl, subsequence($components, 2))&#xd;
            )&#xd; else&#xd; ()&#xd; };&#xd; &#xd; (: Helper function to recursively create a
            collection hierarchy. :)&#xd; declare function local:mkcol($collection, $path) {&#xd;
            local:mkcol-recursive($collection, tokenize($path, "/"))&#xd; };&#xd; &#xd; &#xd; let
            $project := 'mdrepo'&#xd; let $config := config:config($project)&#xd; let $model := map
            { "config" := $config}&#xd; let $project-dir := config:param-value($model,
            "project-dir")&#xd; let $data-dir := config:param-value($model, "data.path")&#xd; &#xd;
            return xmldb:copy($project-dir, concat("/db/system/config", $data-dir),
            "collection.xconf")&#xd; (: (local:mkcol("/db/system/config", $data.path),:)&#xd; (:
            xmldb:copy(concat("/project.template"),$config:projects-dir) ):)&#xd;
            (:xdb:store-files-from-pattern(concat("/system/config", $target), $dir,
            "*.xconf"):)&#xd; </f>
        <f n="sync.xql">xquery version "3.0"; try{ let $source :=
            request:get-parameter("source","/db/apps/cr-xq-mets") let $target-base :=
            request:get-parameter("target-base","/opt/repo") (: let $cr-xq-mets-log :=
            file:sync($source, $target-base||"/cr-xq-mets/src", ()) :) (: let $cs-xsl-log :=
            file:sync($source||"/modules/cs-xsl", $target-base||"/cs-xsl", ()) :) (: return
            ($cr-xq-mets-log, $cs-xsl-log):) let $cr-project-abacus :=
            file:sync("/db/cr-projects/abacus", $target-base||"/cr-projects/abacus-mets",
            xs:dateTime("2014-05-01T10:10:00")) return $cr-project-abacus } catch * { let $log :=
            util:log("ERROR", ($err:code, $err:description) ) return &lt;ERROR&gt;{($err:code,
            $err:description)}&lt;/ERROR&gt; (: let $col := "/db/apps/cr-xq-dev0913":) (: let
            $target := "/opt/repo/SADE/src":) (: return file:sync($col, $target, ()) :) } </f>
    </d>
</root>
